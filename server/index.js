#!/usr/bin/env node

const { execFile } = require('child_process');
const { promisify } = require('util');

const execFileAsync = promisify(execFile);

console.error("Finder AppleScript MCP server starting...");

// Constants
const APPLESCRIPT_TIMEOUT = 10000; // 10 seconds
const MAX_RETRIES = 3;
const RETRY_DELAY = 1000; // 1 second

// Universal type caster for AppleScript values
function universalCast(value) {
  if (value === null || value === undefined) return null;
  
  const str = String(value).trim();
  if (str === '') return '';
  
  // Boolean
  const lower = str.toLowerCase();
  if (['true', 'yes'].includes(lower)) return true;
  if (['false', 'no'].includes(lower)) return false;
  
  // Number
  if (/^-?\d+(\.\d+)?$/.test(str)) {
    const num = Number(str);
    return Number.isInteger(num) ? num : num;
  }
  
  // List/Record - anything in braces, return as-is for AppleScript
  if (str.startsWith('{') && str.endsWith('}')) {
    return str; // AppleScript will handle the parsing
  }
  
  // Auto-detect comma-separated values that should be lists/rectangles
  if (str.includes(',') && !str.startsWith('{')) {
    const parts = str.split(',').map(p => p.trim());
    
    // Rectangle pattern: 4 numbers (x, y, width, height)
    if (parts.length === 4 && parts.every(p => /^-?\d+(\.\d+)?$/.test(p))) {
      return `{${str}}`; // Add brackets for rectangle
    }
    
    // Generic list: 2+ comma-separated values
    if (parts.length >= 2) {
      return `{${str}}`; // Add brackets for list
    }
  }
  
  // Date patterns
  if (str.startsWith('date "') || /^\d{4}-\d{2}-\d{2}/.test(str)) {
    return `date "${str}"`;
  }
  
  // String - remove quotes if present
  if ((str.startsWith('"') && str.endsWith('"')) || 
      (str.startsWith("'") && str.endsWith("'"))) {
    return str.slice(1, -1);
  }
  
  return str;
}

// Cast and escape for AppleScript injection
function castAndEscape(value) {
  const casted = universalCast(value);
  
  // If it's a string that doesn't start with {, escape it
  if (typeof casted === 'string' && !casted.startsWith('{') && !casted.startsWith('date')) {
    return escapeForAppleScript(casted);
  }
  
  // Numbers, booleans, and AppleScript literals go as-is
  return casted;
}

// Helper function to escape strings for AppleScript
function escapeForAppleScript(str) {
  if (typeof str !== "string") return str;
  return str
    .replace(/\\/g, "\\\\") // Escape backslashes first
    .replace(/"/g, '\"') // Then escape double quotes
    .replace(/\n/g, "\\n") // Escape newlines
    .replace(/\r/g, "\\r"); // Escape carriage returns
}

// Test if Finder is available
async function checkFinderAvailable() {
  try {
    const script = 'tell application "Finder" to return "available"';
    const result = await executeAppleScript(script);
    return result === "available";
  } catch (error) {
    return false;
  }
}

// Execute AppleScript with retry logic
async function executeAppleScript(script, retries = MAX_RETRIES) {
  for (let attempt = 0; attempt <= retries; attempt++) {
    try {
      const { stdout, stderr } = await execFileAsync(
        "osascript",
        ["-e", script],
        {
          timeout: APPLESCRIPT_TIMEOUT,
          maxBuffer: 1024 * 1024, // 1MB buffer
        },
      );
      if (stderr) {
        console.error("AppleScript stderr:", stderr);
      }
      return stdout.trim();
    } catch (error) {
      if (attempt === retries) {
        console.error("AppleScript execution error after retries:", error);
        throw new Error(`AppleScript error: ${error.message}`);
      }
      await new Promise((resolve) =>
        setTimeout(resolve, RETRY_DELAY * Math.pow(2, attempt)),
      );
    }
  }
}

// MCP server implementation
class FinderMCPServer {
  constructor() {
    this.initialized = false;
    this.setupStdio();
  }

  setupStdio() {
    process.stdin.setEncoding('utf8');
    
    let buffer = '';
    process.stdin.on('data', (data) => {
      buffer += data;
      const lines = buffer.split('\n');
      buffer = lines.pop() || ''; // Keep incomplete line in buffer
      
      lines.forEach(line => {
        if (line.trim()) {
          this.handleMessage(line.trim());
        }
      });
    });
  }

  async handleMessage(data) {
    try {
      const request = JSON.parse(data);
      console.error("Received request:", request.method, request.id);
      
      if (request.method === 'initialize') {
        await this.handleInitialize(request);
      } else if (request.method === 'initialized') {
        await this.handleInitialized(request);
      } else if (request.method === 'tools/list') {
        await this.handleToolsList(request);
      } else if (request.method === 'tools/call') {
        await this.handleToolsCall(request);
      } else {
        console.error("Unknown method:", request.method);
      }
    } catch (error) {
      console.error("Error processing message:", error);
    }
  }

  async handleInitialize(request) {
    console.error("Handling initialize request");
    const response = {
      jsonrpc: '2.0',
      id: request.id,
      result: {
        protocolVersion: '2024-11-05',
        capabilities: {
          tools: {}
        },
        serverInfo: {
          name: 'finder-applescript',
          version: '0.1.0'
        }
      }
    };
    this.sendResponse(response);
  }

  async handleInitialized(request) {
    console.error("Handling initialized notification");
    this.initialized = true;
  }

  async handleToolsList(request) {
    console.error("Handling tools/list request");
    const response = {
      jsonrpc: '2.0',
      id: request.id,
      result: {
        tools: [
          {
  name: 'save_for_window',
  description: 'Save a window.',
  inputSchema: {
    type: 'object',
    properties: {
      target_window_required_string: {
        type: 'string',
        description: 'The window object'
      },
      inParam_optional_file: {
        type: 'string',
        description: 'The file in which to save the document.'
      },
      as_optional_saveable_file_format: {
        type: 'string',
        description: 'The file format to use.'
      }
    },
    required: ['target_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'save_for_document',
  description: 'Save a document.',
  inputSchema: {
    type: 'object',
    properties: {
      target_document_required_string: {
        type: 'string',
        description: 'The document object'
      },
      inParam_optional_file: {
        type: 'string',
        description: 'The file in which to save the document.'
      },
      as_optional_saveable_file_format: {
        type: 'string',
        description: 'The file format to use.'
      }
    },
    required: ['target_document_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_name_of_application',
  description: 'Get The name of the application.',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_required_string: {
        type: 'string',
        description: 'The application object'
      }
    },
    required: ['target_application_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_frontmost_of_application',
  description: 'Get Is this the active application?',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_required_string: {
        type: 'string',
        description: 'The application object'
      }
    },
    required: ['target_application_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_version_of_application',
  description: 'Get The version number of the application.',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_required_string: {
        type: 'string',
        description: 'The application object'
      }
    },
    required: ['target_application_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_name_of_document',
  description: 'Get Its name. of document',
  inputSchema: {
    type: 'object',
    properties: {
      target_document_required_string: {
        type: 'string',
        description: 'The document object'
      }
    },
    required: ['target_document_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_modified_of_document',
  description: 'Get Has it been modified since the last save? of document',
  inputSchema: {
    type: 'object',
    properties: {
      target_document_required_string: {
        type: 'string',
        description: 'The document object'
      }
    },
    required: ['target_document_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_file_of_document',
  description: 'Get Its location on disk, if it has one. of document',
  inputSchema: {
    type: 'object',
    properties: {
      target_document_required_string: {
        type: 'string',
        description: 'The document object'
      }
    },
    required: ['target_document_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_name_of_window',
  description: 'Get The title of the window.',
  inputSchema: {
    type: 'object',
    properties: {
      target_window_required_string: {
        type: 'string',
        description: 'The window object'
      }
    },
    required: ['target_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_id_of_window',
  description: 'Get The unique identifier of the window.',
  inputSchema: {
    type: 'object',
    properties: {
      target_window_required_string: {
        type: 'string',
        description: 'The window object'
      }
    },
    required: ['target_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_index_of_window',
  description: 'Get The index of the window, ordered front to back.',
  inputSchema: {
    type: 'object',
    properties: {
      target_window_required_string: {
        type: 'string',
        description: 'The window object'
      }
    },
    required: ['target_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_index_of_window',
  description: 'Set The index of the window, ordered front to back.',
  inputSchema: {
    type: 'object',
    properties: {
      target_window_required_string: {
        type: 'string',
        description: 'The window object'
      },
      value_required_integer: {
        type: 'number',
        description: 'New value for The index of the window, ordered front to back.'
      }
    },
    required: ['target_window_required_string', 'value_required_integer'],
    additionalProperties: false
  }
},
          {
  name: 'get_bounds_of_window',
  description: 'Get The bounding rectangle of the window.',
  inputSchema: {
    type: 'object',
    properties: {
      target_window_required_string: {
        type: 'string',
        description: 'The window object'
      }
    },
    required: ['target_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_bounds_of_window',
  description: 'Set The bounding rectangle of the window.',
  inputSchema: {
    type: 'object',
    properties: {
      target_window_required_string: {
        type: 'string',
        description: 'The window object'
      },
      value_required_rectangle: {
        type: 'string',
        description: 'New value for The bounding rectangle of the window.'
      }
    },
    required: ['target_window_required_string', 'value_required_rectangle'],
    additionalProperties: false
  }
},
          {
  name: 'get_closeable_of_window',
  description: 'Get Does the window have a close button?',
  inputSchema: {
    type: 'object',
    properties: {
      target_window_required_string: {
        type: 'string',
        description: 'The window object'
      }
    },
    required: ['target_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_miniaturizable_of_window',
  description: 'Get Does the window have a minimize button?',
  inputSchema: {
    type: 'object',
    properties: {
      target_window_required_string: {
        type: 'string',
        description: 'The window object'
      }
    },
    required: ['target_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_miniaturized_of_window',
  description: 'Get Is the window minimized right now?',
  inputSchema: {
    type: 'object',
    properties: {
      target_window_required_string: {
        type: 'string',
        description: 'The window object'
      }
    },
    required: ['target_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_miniaturized_of_window',
  description: 'Set Is the window minimized right now?',
  inputSchema: {
    type: 'object',
    properties: {
      target_window_required_string: {
        type: 'string',
        description: 'The window object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Is the window minimized right now?'
      }
    },
    required: ['target_window_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_resizable_of_window',
  description: 'Get Can the window be resized?',
  inputSchema: {
    type: 'object',
    properties: {
      target_window_required_string: {
        type: 'string',
        description: 'The window object'
      }
    },
    required: ['target_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_visible_of_window',
  description: 'Get Is the window visible right now?',
  inputSchema: {
    type: 'object',
    properties: {
      target_window_required_string: {
        type: 'string',
        description: 'The window object'
      }
    },
    required: ['target_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_visible_of_window',
  description: 'Set Is the window visible right now?',
  inputSchema: {
    type: 'object',
    properties: {
      target_window_required_string: {
        type: 'string',
        description: 'The window object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Is the window visible right now?'
      }
    },
    required: ['target_window_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_zoomable_of_window',
  description: 'Get Does the window have a zoom button?',
  inputSchema: {
    type: 'object',
    properties: {
      target_window_required_string: {
        type: 'string',
        description: 'The window object'
      }
    },
    required: ['target_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_zoomed_of_window',
  description: 'Get Is the window zoomed right now?',
  inputSchema: {
    type: 'object',
    properties: {
      target_window_required_string: {
        type: 'string',
        description: 'The window object'
      }
    },
    required: ['target_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_zoomed_of_window',
  description: 'Set Is the window zoomed right now?',
  inputSchema: {
    type: 'object',
    properties: {
      target_window_required_string: {
        type: 'string',
        description: 'The window object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Is the window zoomed right now?'
      }
    },
    required: ['target_window_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_document_of_window',
  description: 'Get The document whose contents are displayed in the window.',
  inputSchema: {
    type: 'object',
    properties: {
      target_window_required_string: {
        type: 'string',
        description: 'The window object'
      }
    },
    required: ['target_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'open',
  description: 'Open the specified object(s)',
  inputSchema: {
    type: 'object',
    properties: {
      direct_parameter_required_specifier: {
        type: 'string',
        description: 'list of objects to open'
      },
      using_optional_specifier: {
        type: 'string',
        description: 'the application file to open the object with'
      },
      with_properties_optional_record: {
        type: 'string',
        description: 'the initial values for the properties, to be included with the open command sent to the application that opens the direct object'
      }
    },
    required: ['direct_parameter_required_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'print_for_window',
  description: 'Print the specified object(s) for window',
  inputSchema: {
    type: 'object',
    properties: {
      target_window_required_string: {
        type: 'string',
        description: 'The window object'
      },
      with_properties_optional_record: {
        type: 'string',
        description: 'optional properties to be included with the print command sent to the application that prints the direct object'
      }
    },
    required: ['target_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'print_for_document',
  description: 'Print the specified object(s) for document',
  inputSchema: {
    type: 'object',
    properties: {
      target_document_required_string: {
        type: 'string',
        description: 'The document object'
      },
      with_properties_optional_record: {
        type: 'string',
        description: 'optional properties to be included with the print command sent to the application that prints the direct object'
      }
    },
    required: ['target_document_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'quit',
  description: 'Quit the Finder',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'activate',
  description: 'Activate the specified window (or the Finder)',
  inputSchema: {
    type: 'object',
    properties: {
      direct_parameter_optional_specifier: {
        type: 'string',
        description: 'the window to activate (if not specified, activates the Finder)'
      }
    },
    additionalProperties: false
  }
},
          {
  name: 'close_for_window',
  description: 'Close a window',
  inputSchema: {
    type: 'object',
    properties: {
      target_window_required_string: {
        type: 'string',
        description: 'The window object'
      }
    },
    required: ['target_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'close_for_document',
  description: 'Close a document',
  inputSchema: {
    type: 'object',
    properties: {
      target_document_required_string: {
        type: 'string',
        description: 'The document object'
      }
    },
    required: ['target_document_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'count_file_of_container',
  description: 'Return the number of elements of a particular class within a file',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object to access'
      }
    },
    required: ['target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'count_desk_accessory_process',
  description: 'Return the number of elements of a particular class within a desk accessory process',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'count_list_view_options',
  description: 'Return the number of elements of a particular class within a list view options',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'count_internet_location_file_of_container',
  description: 'Return the number of elements of a particular class within a internet location file',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object to access'
      }
    },
    required: ['target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'count_window',
  description: 'Return the number of elements of a particular class within a window',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'count_desktop_object',
  description: 'Return the number of elements of a particular class within a desktop-object',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'count_preferences',
  description: 'Return the number of elements of a particular class within a preferences',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'count_label',
  description: 'Return the number of elements of a particular class within a label',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'count_folder_of_container',
  description: 'Return the number of elements of a particular class within a folder',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object to access'
      }
    },
    required: ['target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'count_process',
  description: 'Return the number of elements of a particular class within a process',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'count_icon_view_options',
  description: 'Return the number of elements of a particular class within a icon view options',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'count_container_of_container',
  description: 'Return the number of elements of a particular class within a container',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object to access'
      }
    },
    required: ['target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'count_finder_window',
  description: 'Return the number of elements of a particular class within a Finder window',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'count_column_view_options',
  description: 'Return the number of elements of a particular class within a column view options',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'count_column_of_list_view_options',
  description: 'Return the number of elements of a particular class within a column of list view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_list_view_options_required_string: {
        type: 'string',
        description: 'The list view options object to access'
      }
    },
    required: ['target_list_view_options_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'count_preferences_window',
  description: 'Return the number of elements of a particular class within a preferences window',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'count_computer_object',
  description: 'Return the number of elements of a particular class within a computer-object',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'count_alias_file_of_container',
  description: 'Return the number of elements of a particular class within a alias file',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object to access'
      }
    },
    required: ['target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'count_application_file_of_container',
  description: 'Return the number of elements of a particular class within a application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object to access'
      }
    },
    required: ['target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'count_information_window',
  description: 'Return the number of elements of a particular class within a information window',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'count_item_of_container',
  description: 'Return the number of elements of a particular class within a item',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object to access'
      }
    },
    required: ['target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'count_application_process',
  description: 'Return the number of elements of a particular class within a application process',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'count_clipping_of_container',
  description: 'Return the number of elements of a particular class within a clipping',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object to access'
      }
    },
    required: ['target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'count_document_file_of_container',
  description: 'Return the number of elements of a particular class within a document file',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object to access'
      }
    },
    required: ['target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'count_alias_list',
  description: 'Return the number of elements of a particular class within a alias list',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'count_desktop_window',
  description: 'Return the number of elements of a particular class within a desktop window',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'count_icon_family',
  description: 'Return the number of elements of a particular class within a icon family',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'count_package_of_container',
  description: 'Return the number of elements of a particular class within a package',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object to access'
      }
    },
    required: ['target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'count_clipping_window',
  description: 'Return the number of elements of a particular class within a clipping window',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'count_document',
  description: 'Return the number of elements of a particular class within a document',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'count_trash_object',
  description: 'Return the number of elements of a particular class within a trash-object',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'count_disk_of_desktop_object',
  description: 'Return the number of elements of a particular class within a disk',
  inputSchema: {
    type: 'object',
    properties: {
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object object to access'
      }
    },
    required: ['target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'data_size_file_of_container',
  description: 'Return the size in bytes of a file',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object to access'
      }
    },
    required: ['target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'data_size_desk_accessory_process',
  description: 'Return the size in bytes of a desk accessory process',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'data_size_list_view_options',
  description: 'Return the size in bytes of a list view options',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'data_size_internet_location_file_of_container',
  description: 'Return the size in bytes of a internet location file',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object to access'
      }
    },
    required: ['target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'data_size_window',
  description: 'Return the size in bytes of a window',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'data_size_desktop_object',
  description: 'Return the size in bytes of a desktop-object',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'data_size_preferences',
  description: 'Return the size in bytes of a preferences',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'data_size_label',
  description: 'Return the size in bytes of a label',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'data_size_folder_of_container',
  description: 'Return the size in bytes of a folder',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object to access'
      }
    },
    required: ['target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'data_size_process',
  description: 'Return the size in bytes of a process',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'data_size_icon_view_options',
  description: 'Return the size in bytes of a icon view options',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'data_size_container_of_container',
  description: 'Return the size in bytes of a container',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object to access'
      }
    },
    required: ['target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'data_size_finder_window',
  description: 'Return the size in bytes of a Finder window',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'data_size_column_view_options',
  description: 'Return the size in bytes of a column view options',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'data_size_column_of_list_view_options',
  description: 'Return the size in bytes of a column of list view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_list_view_options_required_string: {
        type: 'string',
        description: 'The list view options object to access'
      }
    },
    required: ['target_list_view_options_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'data_size_preferences_window',
  description: 'Return the size in bytes of a preferences window',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'data_size_computer_object',
  description: 'Return the size in bytes of a computer-object',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'data_size_alias_file_of_container',
  description: 'Return the size in bytes of a alias file',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object to access'
      }
    },
    required: ['target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'data_size_application_file_of_container',
  description: 'Return the size in bytes of a application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object to access'
      }
    },
    required: ['target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'data_size_information_window',
  description: 'Return the size in bytes of a information window',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'data_size_item_of_container',
  description: 'Return the size in bytes of a item',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object to access'
      }
    },
    required: ['target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'data_size_application_process',
  description: 'Return the size in bytes of a application process',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'data_size_clipping_of_container',
  description: 'Return the size in bytes of a clipping',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object to access'
      }
    },
    required: ['target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'data_size_document_file_of_container',
  description: 'Return the size in bytes of a document file',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object to access'
      }
    },
    required: ['target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'data_size_alias_list',
  description: 'Return the size in bytes of a alias list',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'data_size_desktop_window',
  description: 'Return the size in bytes of a desktop window',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'data_size_icon_family',
  description: 'Return the size in bytes of a icon family',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'data_size_package_of_container',
  description: 'Return the size in bytes of a package',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object to access'
      }
    },
    required: ['target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'data_size_clipping_window',
  description: 'Return the size in bytes of a clipping window',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'data_size_document',
  description: 'Return the size in bytes of a document',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'data_size_trash_object',
  description: 'Return the size in bytes of a trash-object',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'data_size_disk_of_desktop_object',
  description: 'Return the size in bytes of a disk',
  inputSchema: {
    type: 'object',
    properties: {
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object object to access'
      }
    },
    required: ['target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'delete',
  description: 'Move an item from its container to the trash',
  inputSchema: {
    type: 'object',
    properties: {
      direct_parameter_required_specifier: {
        type: 'string',
        description: 'the item to delete'
      }
    },
    required: ['direct_parameter_required_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'duplicate',
  description: 'Duplicate one or more object(s)',
  inputSchema: {
    type: 'object',
    properties: {
      direct_parameter_required_specifier: {
        type: 'string',
        description: 'the object(s) to duplicate'
      },
      to_optional_location_specifier: {
        type: 'string',
        description: 'the new location for the object(s)'
      },
      replacing_optional_boolean: {
        type: 'boolean',
        description: 'Specifies whether or not to replace items in the destination that have the same name as items being duplicated'
      },
      routing_suppressed_optional_boolean: {
        type: 'boolean',
        description: 'Specifies whether or not to autoroute items (default is false). Only applies when copying to the system folder.'
      },
      exact_copy_optional_boolean: {
        type: 'boolean',
        description: 'Specifies whether or not to copy permissions/ownership as is'
      }
    },
    required: ['direct_parameter_required_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'exists',
  description: 'Verify if an object exists',
  inputSchema: {
    type: 'object',
    properties: {
      direct_parameter_required_specifier: {
        type: 'string',
        description: 'the object in question'
      }
    },
    required: ['direct_parameter_required_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'make_file_of_container',
  description: 'Make a new element for file',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier_container: {
        type: 'string',
        description: 'The container location where the file should be created'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      },
      with_properties_optional_boolean_stationery: {
        type: 'boolean',
        description: 'Optional stationery property: Is the file a stationery pad?'
      }
    },
    required: ['at_required_location_specifier_container'],
    additionalProperties: false
  }
},
          {
  name: 'make_desk_accessory_process',
  description: 'Make a new element for desk accessory process',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier: {
        type: 'string',
        description: 'the location at which to insert the element'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      }
    },
    required: ['at_required_location_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'make_list_view_options',
  description: 'Make a new element for list view options',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier: {
        type: 'string',
        description: 'the location at which to insert the element'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      },
      with_properties_optional_boolean_uses_relative_dates: {
        type: 'boolean',
        description: 'Optional uses relative dates property: Are relative dates (e.g., today, yesterday) shown in the list view?'
      },
      with_properties_optional_lvic_icon_size: {
        type: 'string',
        description: 'Optional icon size property: the size of icons displayed in the list view'
      },
      with_properties_optional_integer_text_size: {
        type: 'number',
        description: 'Optional text size property: the size of the text displayed in the list view'
      },
      with_properties_optional_boolean_calculates_folder_sizes: {
        type: 'boolean',
        description: 'Optional calculates folder sizes property: Are folder sizes calculated and displayed in the window?'
      },
      with_properties_optional_boolean_shows_icon_preview: {
        type: 'boolean',
        description: 'Optional shows icon preview property: displays a preview of the item in list view'
      },
      with_properties_optional_column_sort_column: {
        type: 'string',
        description: 'Optional sort column property: the column that the list view is sorted on'
      }
    },
    required: ['at_required_location_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'make_internet_location_file_of_container',
  description: 'Make a new element for internet location file',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier_container: {
        type: 'string',
        description: 'The container location where the internet location file should be created'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      }
    },
    required: ['at_required_location_specifier_container'],
    additionalProperties: false
  }
},
          {
  name: 'make_window',
  description: 'Make a new element for window',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier: {
        type: 'string',
        description: 'the location at which to insert the element'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      },
      with_properties_optional_integer_index: {
        type: 'number',
        description: 'Optional index property: the number of the window in the front-to-back layer ordering'
      },
      with_properties_optional_point_position: {
        type: 'string',
        description: 'Optional position property: the upper left position of the window'
      },
      with_properties_optional_boolean_zoomed: {
        type: 'boolean',
        description: 'Optional zoomed property: Is the window zoomed?'
      },
      with_properties_optional_boolean_collapsed: {
        type: 'boolean',
        description: 'Optional collapsed property: Is the window collapsed'
      },
      with_properties_optional_boolean_miniaturized: {
        type: 'boolean',
        description: 'Optional miniaturized property: Is the window minimized right now?'
      },
      with_properties_optional_record_properties: {
        type: 'string',
        description: 'Optional properties property: every property of a window'
      },
      with_properties_optional_rectangle_bounds: {
        type: 'string',
        description: 'Optional bounds property: the boundary rectangle for the window'
      }
    },
    required: ['at_required_location_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'make_desktop_object',
  description: 'Make a new element for desktop-object',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier: {
        type: 'string',
        description: 'the location at which to insert the element'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      }
    },
    required: ['at_required_location_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'make_preferences',
  description: 'Make a new element for preferences',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier: {
        type: 'string',
        description: 'the location at which to insert the element'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      },
      with_properties_optional_real_delay_before_springing: {
        type: 'number',
        description: 'Optional delay before springing property: the delay before springing open a container in seconds (from 0.167 to 1.169)'
      },
      with_properties_optional_boolean_new_windows_open_in_column_view: {
        type: 'boolean',
        description: 'Optional new windows open in column view property: Open new windows in column view?'
      },
      with_properties_optional_boolean_desktop_shows_removable_media: {
        type: 'boolean',
        description: 'Optional desktop shows removable media property: CDs, DVDs, and iPods appear on the desktop?'
      },
      with_properties_optional_boolean_folders_spring_open: {
        type: 'boolean',
        description: 'Optional folders spring open property: Spring open folders after the specified delay?'
      },
      with_properties_optional_boolean_all_name_extensions_showing: {
        type: 'boolean',
        description: 'Optional all name extensions showing property: Show name extensions, even for items whose “extension hidden” is true?'
      },
      with_properties_optional_boolean_desktop_shows_external_hard_disks: {
        type: 'boolean',
        description: 'Optional desktop shows external hard disks property: External hard disks appear on the desktop?'
      },
      with_properties_optional_boolean_folders_open_in_new_tabs: {
        type: 'boolean',
        description: 'Optional folders open in new tabs property: Folders open into new tabs?'
      },
      with_properties_optional_boolean_desktop_shows_hard_disks: {
        type: 'boolean',
        description: 'Optional desktop shows hard disks property: Hard disks appear on the desktop?'
      },
      with_properties_optional_specifier_new_window_target: {
        type: 'string',
        description: 'Optional new window target property: target location for a newly-opened Finder window'
      },
      with_properties_optional_boolean_folders_open_in_new_windows: {
        type: 'boolean',
        description: 'Optional folders open in new windows property: Folders open into new windows?'
      },
      with_properties_optional_boolean_desktop_shows_connected_servers: {
        type: 'boolean',
        description: 'Optional desktop shows connected servers property: Connected servers appear on the desktop?'
      }
    },
    required: ['at_required_location_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'make_label',
  description: 'Make a new element for label',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier: {
        type: 'string',
        description: 'the location at which to insert the element'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      },
      with_properties_optional_text_name: {
        type: 'string',
        description: 'Optional name property: the name associated with the label'
      },
      with_properties_optional_integer_index: {
        type: 'number',
        description: 'Optional index property: the index in the front-to-back ordering within its container'
      },
      with_properties_optional_rgb_color_color: {
        type: 'string',
        description: 'Optional color property: the color associated with the label'
      }
    },
    required: ['at_required_location_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'make_folder_of_container',
  description: 'Make a new element for folder',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier_container: {
        type: 'string',
        description: 'The container location where the folder should be created'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      }
    },
    required: ['at_required_location_specifier_container'],
    additionalProperties: false
  }
},
          {
  name: 'make_process',
  description: 'Make a new element for process',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier: {
        type: 'string',
        description: 'the location at which to insert the element'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      },
      with_properties_optional_boolean_visible: {
        type: 'boolean',
        description: 'Optional visible property: Is the process\' layer visible?'
      },
      with_properties_optional_boolean_frontmost: {
        type: 'boolean',
        description: 'Optional frontmost property: Is the process the frontmost process?'
      }
    },
    required: ['at_required_location_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'make_icon_view_options',
  description: 'Make a new element for icon view options',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier: {
        type: 'string',
        description: 'the location at which to insert the element'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      },
      with_properties_optional_boolean_shows_icon_preview: {
        type: 'boolean',
        description: 'Optional shows icon preview property: displays a preview of the item in icon view'
      },
      with_properties_optional_boolean_shows_item_info: {
        type: 'boolean',
        description: 'Optional shows item info property: additional info about an item displayed in icon view'
      },
      with_properties_optional_file_background_picture: {
        type: 'string',
        description: 'Optional background picture property: the background picture of the icon view'
      },
      with_properties_optional_epos_label_position: {
        type: 'string',
        description: 'Optional label position property: the location of the label in reference to the icon'
      },
      with_properties_optional_earr_arrangement: {
        type: 'string',
        description: 'Optional arrangement property: the property by which to keep icons arranged'
      },
      with_properties_optional_rgb_color_background_color: {
        type: 'string',
        description: 'Optional background color property: the background color of the icon view'
      },
      with_properties_optional_integer_text_size: {
        type: 'number',
        description: 'Optional text size property: the size of the text displayed in the icon view'
      },
      with_properties_optional_integer_icon_size: {
        type: 'number',
        description: 'Optional icon size property: the size of icons displayed in the icon view'
      }
    },
    required: ['at_required_location_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'make_container_of_container',
  description: 'Make a new element for container',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier_container: {
        type: 'string',
        description: 'The container location where the container should be created'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      },
      with_properties_optional_boolean_expanded: {
        type: 'boolean',
        description: 'Optional expanded property: (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)'
      },
      with_properties_optional_boolean_completely_expanded: {
        type: 'boolean',
        description: 'Optional completely expanded property: (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)'
      }
    },
    required: ['at_required_location_specifier_container'],
    additionalProperties: false
  }
},
          {
  name: 'make_finder_window',
  description: 'Make a new element for Finder window',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier: {
        type: 'string',
        description: 'the location at which to insert the element'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      },
      with_properties_optional_specifier_target: {
        type: 'string',
        description: 'Optional target property: the container at which this file viewer is targeted'
      },
      with_properties_optional_boolean_toolbar_visible: {
        type: 'boolean',
        description: 'Optional toolbar visible property: Is the window\'s toolbar visible?'
      },
      with_properties_optional_boolean_pathbar_visible: {
        type: 'boolean',
        description: 'Optional pathbar visible property: Is the window\'s path bar visible?'
      },
      with_properties_optional_integer_sidebar_width: {
        type: 'number',
        description: 'Optional sidebar width property: the width of the sidebar for the container window'
      },
      with_properties_optional_ecvw_current_view: {
        type: 'string',
        description: 'Optional current view property: the current view for the container window'
      },
      with_properties_optional_boolean_statusbar_visible: {
        type: 'boolean',
        description: 'Optional statusbar visible property: Is the window\'s status bar visible?'
      }
    },
    required: ['at_required_location_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'make_column_view_options',
  description: 'Make a new element for column view options',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier: {
        type: 'string',
        description: 'the location at which to insert the element'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      },
      with_properties_optional_boolean_shows_icon: {
        type: 'boolean',
        description: 'Optional shows icon property: displays an icon next to the label in column view'
      },
      with_properties_optional_integer_text_size: {
        type: 'number',
        description: 'Optional text size property: the size of the text displayed in the column view'
      },
      with_properties_optional_boolean_shows_preview_column: {
        type: 'boolean',
        description: 'Optional shows preview column property: displays the preview column in column view'
      },
      with_properties_optional_boolean_shows_icon_preview: {
        type: 'boolean',
        description: 'Optional shows icon preview property: displays a preview of the item in column view'
      },
      with_properties_optional_boolean_discloses_preview_pane: {
        type: 'boolean',
        description: 'Optional discloses preview pane property: discloses the preview pane of the preview column in column view'
      }
    },
    required: ['at_required_location_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'make_column_of_list_view_options',
  description: 'Make a new element for column of list view options',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier_list_view_options: {
        type: 'string',
        description: 'The list view options location where the column should be created'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      },
      with_properties_optional_sodr_sort_direction: {
        type: 'string',
        description: 'Optional sort direction property: The direction in which the window is sorted'
      },
      with_properties_optional_boolean_visible: {
        type: 'boolean',
        description: 'Optional visible property: is this column visible'
      },
      with_properties_optional_integer_width: {
        type: 'number',
        description: 'Optional width property: the width of this column'
      },
      with_properties_optional_integer_index: {
        type: 'number',
        description: 'Optional index property: the index in the front-to-back ordering within its container'
      }
    },
    required: ['at_required_location_specifier_list_view_options'],
    additionalProperties: false
  }
},
          {
  name: 'make_preferences_window',
  description: 'Make a new element for preferences window',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier: {
        type: 'string',
        description: 'the location at which to insert the element'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      },
      with_properties_optional_pple_current_panel: {
        type: 'string',
        description: 'Optional current panel property: The current panel in the Finder preferences window'
      }
    },
    required: ['at_required_location_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'make_computer_object',
  description: 'Make a new element for computer-object',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier: {
        type: 'string',
        description: 'the location at which to insert the element'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      }
    },
    required: ['at_required_location_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'make_alias_file_of_container',
  description: 'Make a new element for alias file',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier_container: {
        type: 'string',
        description: 'The container location where the alias file should be created'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      },
      with_properties_optional_specifier_original_item: {
        type: 'string',
        description: 'Optional original item property: the original item pointed to by the alias'
      }
    },
    required: ['at_required_location_specifier_container'],
    additionalProperties: false
  }
},
          {
  name: 'make_application_file_of_container',
  description: 'Make a new element for application file',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier_container: {
        type: 'string',
        description: 'The container location where the application file should be created'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      },
      with_properties_optional_integer_preferred_size: {
        type: 'number',
        description: 'Optional preferred size property: (AVAILABLE IN 10.1 TO 10.4) the memory size with which the application will be launched'
      },
      with_properties_optional_boolean_opens_in_classic: {
        type: 'boolean',
        description: 'Optional opens in Classic property: (AVAILABLE IN 10.1 TO 10.4) Should the application launch in the Classic environment?'
      },
      with_properties_optional_integer_minimum_size: {
        type: 'number',
        description: 'Optional minimum size property: (AVAILABLE IN 10.1 TO 10.4) the smallest memory size with which the application can be launched'
      }
    },
    required: ['at_required_location_specifier_container'],
    additionalProperties: false
  }
},
          {
  name: 'make_information_window',
  description: 'Make a new element for information window',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier: {
        type: 'string',
        description: 'the location at which to insert the element'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      },
      with_properties_optional_ipnl_current_panel: {
        type: 'string',
        description: 'Optional current panel property: the current panel in the information window'
      }
    },
    required: ['at_required_location_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'make_item_of_container',
  description: 'Make a new element for item',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier_container: {
        type: 'string',
        description: 'The container location where the item should be created'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      },
      with_properties_optional_boolean_locked: {
        type: 'boolean',
        description: 'Optional locked property: Is the file locked?'
      },
      with_properties_optional_point_position: {
        type: 'string',
        description: 'Optional position property: the position of the item within its parent window (can only be set for an item in a window viewed as icons or buttons)'
      },
      with_properties_optional_priv_everyones_privileges: {
        type: 'string',
        description: 'Optional everyones privileges property: missing value'
      },
      with_properties_optional_icon_family_icon: {
        type: 'string',
        description: 'Optional icon property: the icon bitmap of the item'
      },
      with_properties_optional_point_desktop_position: {
        type: 'string',
        description: 'Optional desktop position property: the position of the item on the desktop'
      },
      with_properties_optional_text_owner: {
        type: 'string',
        description: 'Optional owner property: the user that owns the container'
      },
      with_properties_optional_priv_owner_privileges: {
        type: 'string',
        description: 'Optional owner privileges property: missing value'
      },
      with_properties_optional_text_name_extension: {
        type: 'string',
        description: 'Optional name extension property: the name extension of the item (such as “txt”)'
      },
      with_properties_optional_text_name: {
        type: 'string',
        description: 'Optional name property: the name of the item'
      },
      with_properties_optional_text_group: {
        type: 'string',
        description: 'Optional group property: the user or group that has special access to the container'
      },
      with_properties_optional_integer_label_index: {
        type: 'number',
        description: 'Optional label index property: the label of the item'
      },
      with_properties_optional_rectangle_bounds: {
        type: 'string',
        description: 'Optional bounds property: the bounding rectangle of the item (can only be set for an item in a window viewed as icons or buttons)'
      },
      with_properties_optional_priv_group_privileges: {
        type: 'string',
        description: 'Optional group privileges property: missing value'
      },
      with_properties_optional_boolean_extension_hidden: {
        type: 'boolean',
        description: 'Optional extension hidden property: Is the item\'s extension hidden from the user?'
      },
      with_properties_optional_date_modification_date: {
        type: 'string',
        description: 'Optional modification date property: the date on which the item was last modified'
      },
      with_properties_optional_record_properties: {
        type: 'string',
        description: 'Optional properties property: every property of an item'
      },
      with_properties_optional_text_comment: {
        type: 'string',
        description: 'Optional comment property: the comment of the item, displayed in the “Get Info” window'
      }
    },
    required: ['at_required_location_specifier_container'],
    additionalProperties: false
  }
},
          {
  name: 'make_application_process',
  description: 'Make a new element for application process',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier: {
        type: 'string',
        description: 'the location at which to insert the element'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      }
    },
    required: ['at_required_location_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'make_clipping_of_container',
  description: 'Make a new element for clipping',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier_container: {
        type: 'string',
        description: 'The container location where the clipping should be created'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      }
    },
    required: ['at_required_location_specifier_container'],
    additionalProperties: false
  }
},
          {
  name: 'make_document_file_of_container',
  description: 'Make a new element for document file',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier_container: {
        type: 'string',
        description: 'The container location where the document file should be created'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      }
    },
    required: ['at_required_location_specifier_container'],
    additionalProperties: false
  }
},
          {
  name: 'make_alias_list',
  description: 'Make a new element for alias list',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier: {
        type: 'string',
        description: 'the location at which to insert the element'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      }
    },
    required: ['at_required_location_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'make_desktop_window',
  description: 'Make a new element for desktop window',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier: {
        type: 'string',
        description: 'the location at which to insert the element'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      }
    },
    required: ['at_required_location_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'make_icon_family',
  description: 'Make a new element for icon family',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier: {
        type: 'string',
        description: 'the location at which to insert the element'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      }
    },
    required: ['at_required_location_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'make_package_of_container',
  description: 'Make a new element for package',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier_container: {
        type: 'string',
        description: 'The container location where the package should be created'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      }
    },
    required: ['at_required_location_specifier_container'],
    additionalProperties: false
  }
},
          {
  name: 'make_clipping_window',
  description: 'Make a new element for clipping window',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier: {
        type: 'string',
        description: 'the location at which to insert the element'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      }
    },
    required: ['at_required_location_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'make_document',
  description: 'Make a new element for document',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier: {
        type: 'string',
        description: 'the location at which to insert the element'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      }
    },
    required: ['at_required_location_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'make_trash_object',
  description: 'Make a new element for trash-object',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier: {
        type: 'string',
        description: 'the location at which to insert the element'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      },
      with_properties_optional_boolean_warns_before_emptying: {
        type: 'boolean',
        description: 'Optional warns before emptying property: Display a dialog when emptying the trash?'
      }
    },
    required: ['at_required_location_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'make_disk_of_desktop_object',
  description: 'Make a new element for disk',
  inputSchema: {
    type: 'object',
    properties: {
      at_required_location_specifier_desktop_object: {
        type: 'string',
        description: 'The desktop-object location where the disk should be created'
      },
      to_optional_specifier: {
        type: 'string',
        description: 'when creating an alias file, the original item to create an alias to or when creating a file viewer window, the target of the window'
      },
      with_properties_optional_boolean_ignore_privileges: {
        type: 'boolean',
        description: 'Optional ignore privileges property: Ignore permissions on this disk?'
      }
    },
    required: ['at_required_location_specifier_desktop_object'],
    additionalProperties: false
  }
},
          {
  name: 'move',
  description: 'Move object(s) to a new location',
  inputSchema: {
    type: 'object',
    properties: {
      direct_parameter_required_specifier: {
        type: 'string',
        description: 'the object(s) to move'
      },
      to_required_location_specifier: {
        type: 'string',
        description: 'the new location for the object(s)'
      },
      replacing_optional_boolean: {
        type: 'boolean',
        description: 'Specifies whether or not to replace items in the destination that have the same name as items being moved'
      },
      positioned_at_optional_list: {
        type: 'string',
        description: 'Gives a list (in local window coordinates) of positions for the destination items'
      },
      routing_suppressed_optional_boolean: {
        type: 'boolean',
        description: 'Specifies whether or not to autoroute items (default is false). Only applies when moving to the system folder.'
      }
    },
    required: ['direct_parameter_required_specifier', 'to_required_location_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'select',
  description: 'Select the specified object(s)',
  inputSchema: {
    type: 'object',
    properties: {
      direct_parameter_required_specifier: {
        type: 'string',
        description: 'the object to select'
      }
    },
    required: ['direct_parameter_required_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'openvirtuallocation',
  description: 'Private event to open a virtual location',
  inputSchema: {
    type: 'object',
    properties: {
      direct_parameter_required_text: {
        type: 'string',
        description: 'the location to open'
      }
    },
    required: ['direct_parameter_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'copy',
  description: '(NOT AVAILABLE YET) Copy the selected items to the clipboard (the Finder must be the front application)',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'sort',
  description: 'Return the specified object(s) in a sorted list',
  inputSchema: {
    type: 'object',
    properties: {
      direct_parameter_required_specifier: {
        type: 'string',
        description: 'a list of finder objects to sort'
      },
      by_required_property: {
        type: 'string',
        description: 'the property to sort the items by (name, index, date, etc.)'
      }
    },
    required: ['direct_parameter_required_specifier', 'by_required_property'],
    additionalProperties: false
  }
},
          {
  name: 'get_clipboard_of_application',
  description: 'Get (NOT AVAILABLE YET) the Finder’s clipboard window of application',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_required_string: {
        type: 'string',
        description: 'The application object'
      }
    },
    required: ['target_application_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_visible_of_application',
  description: 'Get Is the Finder’s layer visible? of application',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_required_string: {
        type: 'string',
        description: 'The application object'
      }
    },
    required: ['target_application_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_visible_of_application',
  description: 'Set Is the Finder’s layer visible? of application',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_required_string: {
        type: 'string',
        description: 'The application object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Is the Finder’s layer visible?'
      }
    },
    required: ['target_application_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_selection_of_application',
  description: 'Get the selection in the frontmost Finder window of application',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_required_string: {
        type: 'string',
        description: 'The application object'
      }
    },
    required: ['target_application_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_selection_of_application',
  description: 'Set the selection in the frontmost Finder window of application',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_required_string: {
        type: 'string',
        description: 'The application object'
      },
      value_required_specifier: {
        type: 'string',
        description: 'New value for the selection in the frontmost Finder window'
      }
    },
    required: ['target_application_required_string', 'value_required_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'get_insertion_location_of_application',
  description: 'Get the container in which a new folder would appear if “New Folder” was selected of application',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_required_string: {
        type: 'string',
        description: 'The application object'
      }
    },
    required: ['target_application_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_product_version_of_application',
  description: 'Get the version of the System software running on this computer of application',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_required_string: {
        type: 'string',
        description: 'The application object'
      }
    },
    required: ['target_application_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_startup_disk_of_application',
  description: 'Get the startup disk of application',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_required_string: {
        type: 'string',
        description: 'The application object'
      }
    },
    required: ['target_application_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_desktop_of_application',
  description: 'Get the desktop of application',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_required_string: {
        type: 'string',
        description: 'The application object'
      }
    },
    required: ['target_application_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_trash_of_application',
  description: 'Get the trash of application',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_required_string: {
        type: 'string',
        description: 'The application object'
      }
    },
    required: ['target_application_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_home_of_application',
  description: 'Get the home directory of application',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_required_string: {
        type: 'string',
        description: 'The application object'
      }
    },
    required: ['target_application_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_computer_container_of_application',
  description: 'Get the computer location (as in Go > Computer) of application',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_required_string: {
        type: 'string',
        description: 'The application object'
      }
    },
    required: ['target_application_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_finder_preferences_of_application',
  description: 'Get Various preferences that apply to the Finder as a whole of application',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_required_string: {
        type: 'string',
        description: 'The application object'
      }
    },
    required: ['target_application_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'clean_up',
  description: 'Arrange items in window nicely (only applies to open windows in icon view that are not kept arranged)',
  inputSchema: {
    type: 'object',
    properties: {
      direct_parameter_required_specifier: {
        type: 'string',
        description: 'the window to clean up'
      },
      by_optional_property: {
        type: 'string',
        description: 'the order in which to clean up the objects (name, index, date, etc.)'
      }
    },
    required: ['direct_parameter_required_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'eject',
  description: 'Eject the specified disk(s)',
  inputSchema: {
    type: 'object',
    properties: {
      direct_parameter_optional_specifier: {
        type: 'string',
        description: 'the disk(s) to eject'
      }
    },
    additionalProperties: false
  }
},
          {
  name: 'empty',
  description: 'Empty the trash',
  inputSchema: {
    type: 'object',
    properties: {
      direct_parameter_optional_specifier: {
        type: 'string',
        description: '“empty” and “empty trash” both do the same thing'
      },
      security_optional_boolean: {
        type: 'boolean',
        description: '(obsolete)'
      }
    },
    additionalProperties: false
  }
},
          {
  name: 'erase',
  description: '(NOT AVAILABLE) Erase the specified disk(s)',
  inputSchema: {
    type: 'object',
    properties: {
      direct_parameter_required_specifier: {
        type: 'string',
        description: 'the items to erase'
      }
    },
    required: ['direct_parameter_required_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'reveal',
  description: 'Bring the specified object(s) into view',
  inputSchema: {
    type: 'object',
    properties: {
      direct_parameter_required_specifier: {
        type: 'string',
        description: 'the object to be made visible'
      }
    },
    required: ['direct_parameter_required_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'update',
  description: 'Update the display of the specified object(s) to match their on-disk representation',
  inputSchema: {
    type: 'object',
    properties: {
      direct_parameter_required_specifier: {
        type: 'string',
        description: 'the item to update'
      },
      necessity_optional_boolean: {
        type: 'boolean',
        description: 'only update if necessary (i.e. a finder window is open). default is false'
      },
      registering_applications_optional_boolean: {
        type: 'boolean',
        description: 'register applications. default is true'
      }
    },
    required: ['direct_parameter_required_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'get_name_of_item',
  description: 'Get the name of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      }
    },
    required: ['target_item_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_name_of_item',
  description: 'Set the name of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      value_required_text: {
        type: 'string',
        description: 'New value for the name of the item'
      }
    },
    required: ['target_item_required_string', 'value_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'get_name_of_item_of_container',
  description: 'Get the name of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_name_of_item_of_container',
  description: 'Set the name of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      },
      value_required_text: {
        type: 'string',
        description: 'New value for the name of the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string', 'value_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'get_name_of_item_of_disk',
  description: 'Get the name of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_name_of_item_of_disk',
  description: 'Set the name of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      },
      value_required_text: {
        type: 'string',
        description: 'New value for the name of the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string', 'value_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'get_name_of_item_of_folder',
  description: 'Get the name of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_name_of_item_of_folder',
  description: 'Set the name of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      },
      value_required_text: {
        type: 'string',
        description: 'New value for the name of the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string', 'value_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'get_name_of_item_of_desktop_object',
  description: 'Get the name of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_name_of_item_of_desktop_object',
  description: 'Set the name of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      },
      value_required_text: {
        type: 'string',
        description: 'New value for the name of the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string', 'value_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'get_name_of_item_of_trash_object',
  description: 'Get the name of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_name_of_item_of_trash_object',
  description: 'Set the name of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      },
      value_required_text: {
        type: 'string',
        description: 'New value for the name of the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string', 'value_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'get_displayed_name_of_item',
  description: 'Get the user-visible name of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      }
    },
    required: ['target_item_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_displayed_name_of_item_of_container',
  description: 'Get the user-visible name of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_displayed_name_of_item_of_disk',
  description: 'Get the user-visible name of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_displayed_name_of_item_of_folder',
  description: 'Get the user-visible name of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_displayed_name_of_item_of_desktop_object',
  description: 'Get the user-visible name of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_displayed_name_of_item_of_trash_object',
  description: 'Get the user-visible name of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_name_extension_of_item',
  description: 'Get the name extension of the item (such as “txt”)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      }
    },
    required: ['target_item_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_name_extension_of_item',
  description: 'Set the name extension of the item (such as “txt”)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      value_required_text: {
        type: 'string',
        description: 'New value for the name extension of the item (such as “txt”)'
      }
    },
    required: ['target_item_required_string', 'value_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'get_name_extension_of_item_of_container',
  description: 'Get the name extension of the item (such as “txt”)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_name_extension_of_item_of_container',
  description: 'Set the name extension of the item (such as “txt”)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      },
      value_required_text: {
        type: 'string',
        description: 'New value for the name extension of the item (such as “txt”)'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string', 'value_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'get_name_extension_of_item_of_disk',
  description: 'Get the name extension of the item (such as “txt”)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_name_extension_of_item_of_disk',
  description: 'Set the name extension of the item (such as “txt”)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      },
      value_required_text: {
        type: 'string',
        description: 'New value for the name extension of the item (such as “txt”)'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string', 'value_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'get_name_extension_of_item_of_folder',
  description: 'Get the name extension of the item (such as “txt”)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_name_extension_of_item_of_folder',
  description: 'Set the name extension of the item (such as “txt”)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      },
      value_required_text: {
        type: 'string',
        description: 'New value for the name extension of the item (such as “txt”)'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string', 'value_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'get_name_extension_of_item_of_desktop_object',
  description: 'Get the name extension of the item (such as “txt”)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_name_extension_of_item_of_desktop_object',
  description: 'Set the name extension of the item (such as “txt”)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      },
      value_required_text: {
        type: 'string',
        description: 'New value for the name extension of the item (such as “txt”)'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string', 'value_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'get_name_extension_of_item_of_trash_object',
  description: 'Get the name extension of the item (such as “txt”)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_name_extension_of_item_of_trash_object',
  description: 'Set the name extension of the item (such as “txt”)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      },
      value_required_text: {
        type: 'string',
        description: 'New value for the name extension of the item (such as “txt”)'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string', 'value_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'get_extension_hidden_of_item',
  description: 'Get Is the item\'s extension hidden from the user?',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      }
    },
    required: ['target_item_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_extension_hidden_of_item',
  description: 'Set Is the item\'s extension hidden from the user?',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Is the item\'s extension hidden from the user?'
      }
    },
    required: ['target_item_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_extension_hidden_of_item_of_container',
  description: 'Get Is the item\'s extension hidden from the user?',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_extension_hidden_of_item_of_container',
  description: 'Set Is the item\'s extension hidden from the user?',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Is the item\'s extension hidden from the user?'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_extension_hidden_of_item_of_disk',
  description: 'Get Is the item\'s extension hidden from the user?',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_extension_hidden_of_item_of_disk',
  description: 'Set Is the item\'s extension hidden from the user?',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Is the item\'s extension hidden from the user?'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_extension_hidden_of_item_of_folder',
  description: 'Get Is the item\'s extension hidden from the user?',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_extension_hidden_of_item_of_folder',
  description: 'Set Is the item\'s extension hidden from the user?',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Is the item\'s extension hidden from the user?'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_extension_hidden_of_item_of_desktop_object',
  description: 'Get Is the item\'s extension hidden from the user?',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_extension_hidden_of_item_of_desktop_object',
  description: 'Set Is the item\'s extension hidden from the user?',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Is the item\'s extension hidden from the user?'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_extension_hidden_of_item_of_trash_object',
  description: 'Get Is the item\'s extension hidden from the user?',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_extension_hidden_of_item_of_trash_object',
  description: 'Set Is the item\'s extension hidden from the user?',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Is the item\'s extension hidden from the user?'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_index_of_item',
  description: 'Get the index in the front-to-back ordering within its container of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      }
    },
    required: ['target_item_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_index_of_item_of_container',
  description: 'Get the index in the front-to-back ordering within its container of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_index_of_item_of_disk',
  description: 'Get the index in the front-to-back ordering within its container of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_index_of_item_of_folder',
  description: 'Get the index in the front-to-back ordering within its container of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_index_of_item_of_desktop_object',
  description: 'Get the index in the front-to-back ordering within its container of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_index_of_item_of_trash_object',
  description: 'Get the index in the front-to-back ordering within its container of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_container_of_item',
  description: 'Get the container of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      }
    },
    required: ['target_item_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_container_of_item_of_container',
  description: 'Get the container of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_container_of_item_of_disk',
  description: 'Get the container of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_container_of_item_of_folder',
  description: 'Get the container of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_container_of_item_of_desktop_object',
  description: 'Get the container of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_container_of_item_of_trash_object',
  description: 'Get the container of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_disk_of_item',
  description: 'Get the disk on which the item is stored',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      }
    },
    required: ['target_item_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_disk_of_item_of_container',
  description: 'Get the disk on which the item is stored',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_disk_of_item_of_disk',
  description: 'Get the disk on which the item is stored',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_disk_of_item_of_folder',
  description: 'Get the disk on which the item is stored',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_disk_of_item_of_desktop_object',
  description: 'Get the disk on which the item is stored',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_disk_of_item_of_trash_object',
  description: 'Get the disk on which the item is stored',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_position_of_item',
  description: 'Get the position of the item within its parent window (can only be set for an item in a window viewed as icons or buttons)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      }
    },
    required: ['target_item_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_position_of_item',
  description: 'Set the position of the item within its parent window (can only be set for an item in a window viewed as icons or buttons)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      value_required_point: {
        type: 'string',
        description: 'New value for the position of the item within its parent window (can only be set for an item in a window viewed as icons or buttons)'
      }
    },
    required: ['target_item_required_string', 'value_required_point'],
    additionalProperties: false
  }
},
          {
  name: 'get_position_of_item_of_container',
  description: 'Get the position of the item within its parent window (can only be set for an item in a window viewed as icons or buttons)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_position_of_item_of_container',
  description: 'Set the position of the item within its parent window (can only be set for an item in a window viewed as icons or buttons)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      },
      value_required_point: {
        type: 'string',
        description: 'New value for the position of the item within its parent window (can only be set for an item in a window viewed as icons or buttons)'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string', 'value_required_point'],
    additionalProperties: false
  }
},
          {
  name: 'get_position_of_item_of_disk',
  description: 'Get the position of the item within its parent window (can only be set for an item in a window viewed as icons or buttons)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_position_of_item_of_disk',
  description: 'Set the position of the item within its parent window (can only be set for an item in a window viewed as icons or buttons)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      },
      value_required_point: {
        type: 'string',
        description: 'New value for the position of the item within its parent window (can only be set for an item in a window viewed as icons or buttons)'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string', 'value_required_point'],
    additionalProperties: false
  }
},
          {
  name: 'get_position_of_item_of_folder',
  description: 'Get the position of the item within its parent window (can only be set for an item in a window viewed as icons or buttons)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_position_of_item_of_folder',
  description: 'Set the position of the item within its parent window (can only be set for an item in a window viewed as icons or buttons)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      },
      value_required_point: {
        type: 'string',
        description: 'New value for the position of the item within its parent window (can only be set for an item in a window viewed as icons or buttons)'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string', 'value_required_point'],
    additionalProperties: false
  }
},
          {
  name: 'get_position_of_item_of_desktop_object',
  description: 'Get the position of the item within its parent window (can only be set for an item in a window viewed as icons or buttons)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_position_of_item_of_desktop_object',
  description: 'Set the position of the item within its parent window (can only be set for an item in a window viewed as icons or buttons)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      },
      value_required_point: {
        type: 'string',
        description: 'New value for the position of the item within its parent window (can only be set for an item in a window viewed as icons or buttons)'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string', 'value_required_point'],
    additionalProperties: false
  }
},
          {
  name: 'get_position_of_item_of_trash_object',
  description: 'Get the position of the item within its parent window (can only be set for an item in a window viewed as icons or buttons)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_position_of_item_of_trash_object',
  description: 'Set the position of the item within its parent window (can only be set for an item in a window viewed as icons or buttons)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      },
      value_required_point: {
        type: 'string',
        description: 'New value for the position of the item within its parent window (can only be set for an item in a window viewed as icons or buttons)'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string', 'value_required_point'],
    additionalProperties: false
  }
},
          {
  name: 'get_desktop_position_of_item',
  description: 'Get the position of the item on the desktop',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      }
    },
    required: ['target_item_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_desktop_position_of_item',
  description: 'Set the position of the item on the desktop',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      value_required_point: {
        type: 'string',
        description: 'New value for the position of the item on the desktop'
      }
    },
    required: ['target_item_required_string', 'value_required_point'],
    additionalProperties: false
  }
},
          {
  name: 'get_desktop_position_of_item_of_container',
  description: 'Get the position of the item on the desktop',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_desktop_position_of_item_of_container',
  description: 'Set the position of the item on the desktop',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      },
      value_required_point: {
        type: 'string',
        description: 'New value for the position of the item on the desktop'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string', 'value_required_point'],
    additionalProperties: false
  }
},
          {
  name: 'get_desktop_position_of_item_of_disk',
  description: 'Get the position of the item on the desktop',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_desktop_position_of_item_of_disk',
  description: 'Set the position of the item on the desktop',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      },
      value_required_point: {
        type: 'string',
        description: 'New value for the position of the item on the desktop'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string', 'value_required_point'],
    additionalProperties: false
  }
},
          {
  name: 'get_desktop_position_of_item_of_folder',
  description: 'Get the position of the item on the desktop',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_desktop_position_of_item_of_folder',
  description: 'Set the position of the item on the desktop',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      },
      value_required_point: {
        type: 'string',
        description: 'New value for the position of the item on the desktop'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string', 'value_required_point'],
    additionalProperties: false
  }
},
          {
  name: 'get_desktop_position_of_item_of_desktop_object',
  description: 'Get the position of the item on the desktop',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_desktop_position_of_item_of_desktop_object',
  description: 'Set the position of the item on the desktop',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      },
      value_required_point: {
        type: 'string',
        description: 'New value for the position of the item on the desktop'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string', 'value_required_point'],
    additionalProperties: false
  }
},
          {
  name: 'get_desktop_position_of_item_of_trash_object',
  description: 'Get the position of the item on the desktop',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_desktop_position_of_item_of_trash_object',
  description: 'Set the position of the item on the desktop',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      },
      value_required_point: {
        type: 'string',
        description: 'New value for the position of the item on the desktop'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string', 'value_required_point'],
    additionalProperties: false
  }
},
          {
  name: 'get_bounds_of_item',
  description: 'Get the bounding rectangle of the item (can only be set for an item in a window viewed as icons or buttons)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      }
    },
    required: ['target_item_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_bounds_of_item',
  description: 'Set the bounding rectangle of the item (can only be set for an item in a window viewed as icons or buttons)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      value_required_rectangle: {
        type: 'string',
        description: 'New value for the bounding rectangle of the item (can only be set for an item in a window viewed as icons or buttons)'
      }
    },
    required: ['target_item_required_string', 'value_required_rectangle'],
    additionalProperties: false
  }
},
          {
  name: 'get_bounds_of_item_of_container',
  description: 'Get the bounding rectangle of the item (can only be set for an item in a window viewed as icons or buttons)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_bounds_of_item_of_container',
  description: 'Set the bounding rectangle of the item (can only be set for an item in a window viewed as icons or buttons)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      },
      value_required_rectangle: {
        type: 'string',
        description: 'New value for the bounding rectangle of the item (can only be set for an item in a window viewed as icons or buttons)'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string', 'value_required_rectangle'],
    additionalProperties: false
  }
},
          {
  name: 'get_bounds_of_item_of_disk',
  description: 'Get the bounding rectangle of the item (can only be set for an item in a window viewed as icons or buttons)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_bounds_of_item_of_disk',
  description: 'Set the bounding rectangle of the item (can only be set for an item in a window viewed as icons or buttons)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      },
      value_required_rectangle: {
        type: 'string',
        description: 'New value for the bounding rectangle of the item (can only be set for an item in a window viewed as icons or buttons)'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string', 'value_required_rectangle'],
    additionalProperties: false
  }
},
          {
  name: 'get_bounds_of_item_of_folder',
  description: 'Get the bounding rectangle of the item (can only be set for an item in a window viewed as icons or buttons)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_bounds_of_item_of_folder',
  description: 'Set the bounding rectangle of the item (can only be set for an item in a window viewed as icons or buttons)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      },
      value_required_rectangle: {
        type: 'string',
        description: 'New value for the bounding rectangle of the item (can only be set for an item in a window viewed as icons or buttons)'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string', 'value_required_rectangle'],
    additionalProperties: false
  }
},
          {
  name: 'get_bounds_of_item_of_desktop_object',
  description: 'Get the bounding rectangle of the item (can only be set for an item in a window viewed as icons or buttons)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_bounds_of_item_of_desktop_object',
  description: 'Set the bounding rectangle of the item (can only be set for an item in a window viewed as icons or buttons)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      },
      value_required_rectangle: {
        type: 'string',
        description: 'New value for the bounding rectangle of the item (can only be set for an item in a window viewed as icons or buttons)'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string', 'value_required_rectangle'],
    additionalProperties: false
  }
},
          {
  name: 'get_bounds_of_item_of_trash_object',
  description: 'Get the bounding rectangle of the item (can only be set for an item in a window viewed as icons or buttons)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_bounds_of_item_of_trash_object',
  description: 'Set the bounding rectangle of the item (can only be set for an item in a window viewed as icons or buttons)',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      },
      value_required_rectangle: {
        type: 'string',
        description: 'New value for the bounding rectangle of the item (can only be set for an item in a window viewed as icons or buttons)'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string', 'value_required_rectangle'],
    additionalProperties: false
  }
},
          {
  name: 'get_label_index_of_item',
  description: 'Get the label of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      }
    },
    required: ['target_item_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_label_index_of_item',
  description: 'Set the label of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      value_required_integer: {
        type: 'number',
        description: 'New value for the label of the item'
      }
    },
    required: ['target_item_required_string', 'value_required_integer'],
    additionalProperties: false
  }
},
          {
  name: 'get_label_index_of_item_of_container',
  description: 'Get the label of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_label_index_of_item_of_container',
  description: 'Set the label of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      },
      value_required_integer: {
        type: 'number',
        description: 'New value for the label of the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string', 'value_required_integer'],
    additionalProperties: false
  }
},
          {
  name: 'get_label_index_of_item_of_disk',
  description: 'Get the label of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_label_index_of_item_of_disk',
  description: 'Set the label of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      },
      value_required_integer: {
        type: 'number',
        description: 'New value for the label of the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string', 'value_required_integer'],
    additionalProperties: false
  }
},
          {
  name: 'get_label_index_of_item_of_folder',
  description: 'Get the label of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_label_index_of_item_of_folder',
  description: 'Set the label of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      },
      value_required_integer: {
        type: 'number',
        description: 'New value for the label of the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string', 'value_required_integer'],
    additionalProperties: false
  }
},
          {
  name: 'get_label_index_of_item_of_desktop_object',
  description: 'Get the label of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_label_index_of_item_of_desktop_object',
  description: 'Set the label of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      },
      value_required_integer: {
        type: 'number',
        description: 'New value for the label of the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string', 'value_required_integer'],
    additionalProperties: false
  }
},
          {
  name: 'get_label_index_of_item_of_trash_object',
  description: 'Get the label of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_label_index_of_item_of_trash_object',
  description: 'Set the label of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      },
      value_required_integer: {
        type: 'number',
        description: 'New value for the label of the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string', 'value_required_integer'],
    additionalProperties: false
  }
},
          {
  name: 'get_locked_of_item',
  description: 'Get Is the file locked? of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      }
    },
    required: ['target_item_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_locked_of_item',
  description: 'Set Is the file locked? of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Is the file locked?'
      }
    },
    required: ['target_item_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_locked_of_item_of_container',
  description: 'Get Is the file locked? of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_locked_of_item_of_container',
  description: 'Set Is the file locked? of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Is the file locked?'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_locked_of_item_of_disk',
  description: 'Get Is the file locked? of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_locked_of_item_of_disk',
  description: 'Set Is the file locked? of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Is the file locked?'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_locked_of_item_of_folder',
  description: 'Get Is the file locked? of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_locked_of_item_of_folder',
  description: 'Set Is the file locked? of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Is the file locked?'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_locked_of_item_of_desktop_object',
  description: 'Get Is the file locked? of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_locked_of_item_of_desktop_object',
  description: 'Set Is the file locked? of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Is the file locked?'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_locked_of_item_of_trash_object',
  description: 'Get Is the file locked? of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_locked_of_item_of_trash_object',
  description: 'Set Is the file locked? of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Is the file locked?'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_kind_of_item',
  description: 'Get the kind of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      }
    },
    required: ['target_item_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_kind_of_item_of_container',
  description: 'Get the kind of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_kind_of_item_of_disk',
  description: 'Get the kind of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_kind_of_item_of_folder',
  description: 'Get the kind of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_kind_of_item_of_desktop_object',
  description: 'Get the kind of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_kind_of_item_of_trash_object',
  description: 'Get the kind of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_description_of_item',
  description: 'Get a description of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      }
    },
    required: ['target_item_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_description_of_item_of_container',
  description: 'Get a description of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_description_of_item_of_disk',
  description: 'Get a description of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_description_of_item_of_folder',
  description: 'Get a description of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_description_of_item_of_desktop_object',
  description: 'Get a description of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_description_of_item_of_trash_object',
  description: 'Get a description of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_comment_of_item',
  description: 'Get the comment of the item, displayed in the “Get Info” window',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      }
    },
    required: ['target_item_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_comment_of_item',
  description: 'Set the comment of the item, displayed in the “Get Info” window',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      value_required_text: {
        type: 'string',
        description: 'New value for the comment of the item, displayed in the “Get Info” window'
      }
    },
    required: ['target_item_required_string', 'value_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'get_comment_of_item_of_container',
  description: 'Get the comment of the item, displayed in the “Get Info” window',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_comment_of_item_of_container',
  description: 'Set the comment of the item, displayed in the “Get Info” window',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      },
      value_required_text: {
        type: 'string',
        description: 'New value for the comment of the item, displayed in the “Get Info” window'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string', 'value_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'get_comment_of_item_of_disk',
  description: 'Get the comment of the item, displayed in the “Get Info” window',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_comment_of_item_of_disk',
  description: 'Set the comment of the item, displayed in the “Get Info” window',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      },
      value_required_text: {
        type: 'string',
        description: 'New value for the comment of the item, displayed in the “Get Info” window'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string', 'value_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'get_comment_of_item_of_folder',
  description: 'Get the comment of the item, displayed in the “Get Info” window',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_comment_of_item_of_folder',
  description: 'Set the comment of the item, displayed in the “Get Info” window',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      },
      value_required_text: {
        type: 'string',
        description: 'New value for the comment of the item, displayed in the “Get Info” window'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string', 'value_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'get_comment_of_item_of_desktop_object',
  description: 'Get the comment of the item, displayed in the “Get Info” window',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_comment_of_item_of_desktop_object',
  description: 'Set the comment of the item, displayed in the “Get Info” window',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      },
      value_required_text: {
        type: 'string',
        description: 'New value for the comment of the item, displayed in the “Get Info” window'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string', 'value_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'get_comment_of_item_of_trash_object',
  description: 'Get the comment of the item, displayed in the “Get Info” window',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_comment_of_item_of_trash_object',
  description: 'Set the comment of the item, displayed in the “Get Info” window',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      },
      value_required_text: {
        type: 'string',
        description: 'New value for the comment of the item, displayed in the “Get Info” window'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string', 'value_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'get_size_of_item',
  description: 'Get the logical size of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      }
    },
    required: ['target_item_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_size_of_item_of_container',
  description: 'Get the logical size of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_size_of_item_of_disk',
  description: 'Get the logical size of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_size_of_item_of_folder',
  description: 'Get the logical size of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_size_of_item_of_desktop_object',
  description: 'Get the logical size of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_size_of_item_of_trash_object',
  description: 'Get the logical size of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_physical_size_of_item',
  description: 'Get the actual space used by the item on disk',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      }
    },
    required: ['target_item_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_physical_size_of_item_of_container',
  description: 'Get the actual space used by the item on disk',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_physical_size_of_item_of_disk',
  description: 'Get the actual space used by the item on disk',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_physical_size_of_item_of_folder',
  description: 'Get the actual space used by the item on disk',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_physical_size_of_item_of_desktop_object',
  description: 'Get the actual space used by the item on disk',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_physical_size_of_item_of_trash_object',
  description: 'Get the actual space used by the item on disk',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_creation_date_of_item',
  description: 'Get the date on which the item was created',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      }
    },
    required: ['target_item_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_creation_date_of_item_of_container',
  description: 'Get the date on which the item was created',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_creation_date_of_item_of_disk',
  description: 'Get the date on which the item was created',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_creation_date_of_item_of_folder',
  description: 'Get the date on which the item was created',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_creation_date_of_item_of_desktop_object',
  description: 'Get the date on which the item was created',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_creation_date_of_item_of_trash_object',
  description: 'Get the date on which the item was created',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_modification_date_of_item',
  description: 'Get the date on which the item was last modified',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      }
    },
    required: ['target_item_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_modification_date_of_item',
  description: 'Set the date on which the item was last modified',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      value_required_date: {
        type: 'string',
        description: 'New value for the date on which the item was last modified'
      }
    },
    required: ['target_item_required_string', 'value_required_date'],
    additionalProperties: false
  }
},
          {
  name: 'get_modification_date_of_item_of_container',
  description: 'Get the date on which the item was last modified',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_modification_date_of_item_of_container',
  description: 'Set the date on which the item was last modified',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      },
      value_required_date: {
        type: 'string',
        description: 'New value for the date on which the item was last modified'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string', 'value_required_date'],
    additionalProperties: false
  }
},
          {
  name: 'get_modification_date_of_item_of_disk',
  description: 'Get the date on which the item was last modified',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_modification_date_of_item_of_disk',
  description: 'Set the date on which the item was last modified',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      },
      value_required_date: {
        type: 'string',
        description: 'New value for the date on which the item was last modified'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string', 'value_required_date'],
    additionalProperties: false
  }
},
          {
  name: 'get_modification_date_of_item_of_folder',
  description: 'Get the date on which the item was last modified',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_modification_date_of_item_of_folder',
  description: 'Set the date on which the item was last modified',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      },
      value_required_date: {
        type: 'string',
        description: 'New value for the date on which the item was last modified'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string', 'value_required_date'],
    additionalProperties: false
  }
},
          {
  name: 'get_modification_date_of_item_of_desktop_object',
  description: 'Get the date on which the item was last modified',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_modification_date_of_item_of_desktop_object',
  description: 'Set the date on which the item was last modified',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      },
      value_required_date: {
        type: 'string',
        description: 'New value for the date on which the item was last modified'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string', 'value_required_date'],
    additionalProperties: false
  }
},
          {
  name: 'get_modification_date_of_item_of_trash_object',
  description: 'Get the date on which the item was last modified',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_modification_date_of_item_of_trash_object',
  description: 'Set the date on which the item was last modified',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      },
      value_required_date: {
        type: 'string',
        description: 'New value for the date on which the item was last modified'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string', 'value_required_date'],
    additionalProperties: false
  }
},
          {
  name: 'get_icon_of_item',
  description: 'Get the icon bitmap of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      }
    },
    required: ['target_item_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_icon_of_item',
  description: 'Set the icon bitmap of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      value_required_icon_family: {
        type: 'string',
        description: 'New value for the icon bitmap of the item'
      }
    },
    required: ['target_item_required_string', 'value_required_icon_family'],
    additionalProperties: false
  }
},
          {
  name: 'get_icon_of_item_of_container',
  description: 'Get the icon bitmap of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_icon_of_item_of_container',
  description: 'Set the icon bitmap of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      },
      value_required_icon_family: {
        type: 'string',
        description: 'New value for the icon bitmap of the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string', 'value_required_icon_family'],
    additionalProperties: false
  }
},
          {
  name: 'get_icon_of_item_of_disk',
  description: 'Get the icon bitmap of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_icon_of_item_of_disk',
  description: 'Set the icon bitmap of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      },
      value_required_icon_family: {
        type: 'string',
        description: 'New value for the icon bitmap of the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string', 'value_required_icon_family'],
    additionalProperties: false
  }
},
          {
  name: 'get_icon_of_item_of_folder',
  description: 'Get the icon bitmap of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_icon_of_item_of_folder',
  description: 'Set the icon bitmap of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      },
      value_required_icon_family: {
        type: 'string',
        description: 'New value for the icon bitmap of the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string', 'value_required_icon_family'],
    additionalProperties: false
  }
},
          {
  name: 'get_icon_of_item_of_desktop_object',
  description: 'Get the icon bitmap of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_icon_of_item_of_desktop_object',
  description: 'Set the icon bitmap of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      },
      value_required_icon_family: {
        type: 'string',
        description: 'New value for the icon bitmap of the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string', 'value_required_icon_family'],
    additionalProperties: false
  }
},
          {
  name: 'get_icon_of_item_of_trash_object',
  description: 'Get the icon bitmap of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_icon_of_item_of_trash_object',
  description: 'Set the icon bitmap of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      },
      value_required_icon_family: {
        type: 'string',
        description: 'New value for the icon bitmap of the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string', 'value_required_icon_family'],
    additionalProperties: false
  }
},
          {
  name: 'get_url_of_item',
  description: 'Get the URL of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      }
    },
    required: ['target_item_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_url_of_item_of_container',
  description: 'Get the URL of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_url_of_item_of_disk',
  description: 'Get the URL of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_url_of_item_of_folder',
  description: 'Get the URL of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_url_of_item_of_desktop_object',
  description: 'Get the URL of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_url_of_item_of_trash_object',
  description: 'Get the URL of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_owner_of_item',
  description: 'Get the user that owns the container of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      }
    },
    required: ['target_item_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_owner_of_item',
  description: 'Set the user that owns the container of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      value_required_text: {
        type: 'string',
        description: 'New value for the user that owns the container'
      }
    },
    required: ['target_item_required_string', 'value_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'get_owner_of_item_of_container',
  description: 'Get the user that owns the container of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_owner_of_item_of_container',
  description: 'Set the user that owns the container of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      },
      value_required_text: {
        type: 'string',
        description: 'New value for the user that owns the container'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string', 'value_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'get_owner_of_item_of_disk',
  description: 'Get the user that owns the container of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_owner_of_item_of_disk',
  description: 'Set the user that owns the container of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      },
      value_required_text: {
        type: 'string',
        description: 'New value for the user that owns the container'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string', 'value_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'get_owner_of_item_of_folder',
  description: 'Get the user that owns the container of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_owner_of_item_of_folder',
  description: 'Set the user that owns the container of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      },
      value_required_text: {
        type: 'string',
        description: 'New value for the user that owns the container'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string', 'value_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'get_owner_of_item_of_desktop_object',
  description: 'Get the user that owns the container of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_owner_of_item_of_desktop_object',
  description: 'Set the user that owns the container of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      },
      value_required_text: {
        type: 'string',
        description: 'New value for the user that owns the container'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string', 'value_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'get_owner_of_item_of_trash_object',
  description: 'Get the user that owns the container of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_owner_of_item_of_trash_object',
  description: 'Set the user that owns the container of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      },
      value_required_text: {
        type: 'string',
        description: 'New value for the user that owns the container'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string', 'value_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'get_group_of_item',
  description: 'Get the user or group that has special access to the container of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      }
    },
    required: ['target_item_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_group_of_item',
  description: 'Set the user or group that has special access to the container of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      value_required_text: {
        type: 'string',
        description: 'New value for the user or group that has special access to the container'
      }
    },
    required: ['target_item_required_string', 'value_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'get_group_of_item_of_container',
  description: 'Get the user or group that has special access to the container of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_group_of_item_of_container',
  description: 'Set the user or group that has special access to the container of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      },
      value_required_text: {
        type: 'string',
        description: 'New value for the user or group that has special access to the container'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string', 'value_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'get_group_of_item_of_disk',
  description: 'Get the user or group that has special access to the container of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_group_of_item_of_disk',
  description: 'Set the user or group that has special access to the container of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      },
      value_required_text: {
        type: 'string',
        description: 'New value for the user or group that has special access to the container'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string', 'value_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'get_group_of_item_of_folder',
  description: 'Get the user or group that has special access to the container of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_group_of_item_of_folder',
  description: 'Set the user or group that has special access to the container of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      },
      value_required_text: {
        type: 'string',
        description: 'New value for the user or group that has special access to the container'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string', 'value_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'get_group_of_item_of_desktop_object',
  description: 'Get the user or group that has special access to the container of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_group_of_item_of_desktop_object',
  description: 'Set the user or group that has special access to the container of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      },
      value_required_text: {
        type: 'string',
        description: 'New value for the user or group that has special access to the container'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string', 'value_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'get_group_of_item_of_trash_object',
  description: 'Get the user or group that has special access to the container of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_group_of_item_of_trash_object',
  description: 'Set the user or group that has special access to the container of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      },
      value_required_text: {
        type: 'string',
        description: 'New value for the user or group that has special access to the container'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string', 'value_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'get_owner_privileges_of_item',
  description: 'Get  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      }
    },
    required: ['target_item_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_owner_privileges_of_item',
  description: 'Set  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      value_required_priv: {
        type: 'string',
        description: 'New value for '
      }
    },
    required: ['target_item_required_string', 'value_required_priv'],
    additionalProperties: false
  }
},
          {
  name: 'get_owner_privileges_of_item_of_container',
  description: 'Get  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_owner_privileges_of_item_of_container',
  description: 'Set  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      },
      value_required_priv: {
        type: 'string',
        description: 'New value for '
      }
    },
    required: ['target_item_required_string', 'target_container_required_string', 'value_required_priv'],
    additionalProperties: false
  }
},
          {
  name: 'get_owner_privileges_of_item_of_disk',
  description: 'Get  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_owner_privileges_of_item_of_disk',
  description: 'Set  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      },
      value_required_priv: {
        type: 'string',
        description: 'New value for '
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string', 'value_required_priv'],
    additionalProperties: false
  }
},
          {
  name: 'get_owner_privileges_of_item_of_folder',
  description: 'Get  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_owner_privileges_of_item_of_folder',
  description: 'Set  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      },
      value_required_priv: {
        type: 'string',
        description: 'New value for '
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string', 'value_required_priv'],
    additionalProperties: false
  }
},
          {
  name: 'get_owner_privileges_of_item_of_desktop_object',
  description: 'Get  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_owner_privileges_of_item_of_desktop_object',
  description: 'Set  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      },
      value_required_priv: {
        type: 'string',
        description: 'New value for '
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string', 'value_required_priv'],
    additionalProperties: false
  }
},
          {
  name: 'get_owner_privileges_of_item_of_trash_object',
  description: 'Get  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_owner_privileges_of_item_of_trash_object',
  description: 'Set  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      },
      value_required_priv: {
        type: 'string',
        description: 'New value for '
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string', 'value_required_priv'],
    additionalProperties: false
  }
},
          {
  name: 'get_group_privileges_of_item',
  description: 'Get  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      }
    },
    required: ['target_item_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_group_privileges_of_item',
  description: 'Set  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      value_required_priv: {
        type: 'string',
        description: 'New value for '
      }
    },
    required: ['target_item_required_string', 'value_required_priv'],
    additionalProperties: false
  }
},
          {
  name: 'get_group_privileges_of_item_of_container',
  description: 'Get  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_group_privileges_of_item_of_container',
  description: 'Set  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      },
      value_required_priv: {
        type: 'string',
        description: 'New value for '
      }
    },
    required: ['target_item_required_string', 'target_container_required_string', 'value_required_priv'],
    additionalProperties: false
  }
},
          {
  name: 'get_group_privileges_of_item_of_disk',
  description: 'Get  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_group_privileges_of_item_of_disk',
  description: 'Set  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      },
      value_required_priv: {
        type: 'string',
        description: 'New value for '
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string', 'value_required_priv'],
    additionalProperties: false
  }
},
          {
  name: 'get_group_privileges_of_item_of_folder',
  description: 'Get  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_group_privileges_of_item_of_folder',
  description: 'Set  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      },
      value_required_priv: {
        type: 'string',
        description: 'New value for '
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string', 'value_required_priv'],
    additionalProperties: false
  }
},
          {
  name: 'get_group_privileges_of_item_of_desktop_object',
  description: 'Get  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_group_privileges_of_item_of_desktop_object',
  description: 'Set  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      },
      value_required_priv: {
        type: 'string',
        description: 'New value for '
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string', 'value_required_priv'],
    additionalProperties: false
  }
},
          {
  name: 'get_group_privileges_of_item_of_trash_object',
  description: 'Get  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_group_privileges_of_item_of_trash_object',
  description: 'Set  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      },
      value_required_priv: {
        type: 'string',
        description: 'New value for '
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string', 'value_required_priv'],
    additionalProperties: false
  }
},
          {
  name: 'get_everyones_privileges_of_item',
  description: 'Get  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      }
    },
    required: ['target_item_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_everyones_privileges_of_item',
  description: 'Set  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      value_required_priv: {
        type: 'string',
        description: 'New value for '
      }
    },
    required: ['target_item_required_string', 'value_required_priv'],
    additionalProperties: false
  }
},
          {
  name: 'get_everyones_privileges_of_item_of_container',
  description: 'Get  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_everyones_privileges_of_item_of_container',
  description: 'Set  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      },
      value_required_priv: {
        type: 'string',
        description: 'New value for '
      }
    },
    required: ['target_item_required_string', 'target_container_required_string', 'value_required_priv'],
    additionalProperties: false
  }
},
          {
  name: 'get_everyones_privileges_of_item_of_disk',
  description: 'Get  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_everyones_privileges_of_item_of_disk',
  description: 'Set  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      },
      value_required_priv: {
        type: 'string',
        description: 'New value for '
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string', 'value_required_priv'],
    additionalProperties: false
  }
},
          {
  name: 'get_everyones_privileges_of_item_of_folder',
  description: 'Get  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_everyones_privileges_of_item_of_folder',
  description: 'Set  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      },
      value_required_priv: {
        type: 'string',
        description: 'New value for '
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string', 'value_required_priv'],
    additionalProperties: false
  }
},
          {
  name: 'get_everyones_privileges_of_item_of_desktop_object',
  description: 'Get  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_everyones_privileges_of_item_of_desktop_object',
  description: 'Set  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      },
      value_required_priv: {
        type: 'string',
        description: 'New value for '
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string', 'value_required_priv'],
    additionalProperties: false
  }
},
          {
  name: 'get_everyones_privileges_of_item_of_trash_object',
  description: 'Get  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_everyones_privileges_of_item_of_trash_object',
  description: 'Set  of item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      },
      value_required_priv: {
        type: 'string',
        description: 'New value for '
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string', 'value_required_priv'],
    additionalProperties: false
  }
},
          {
  name: 'get_information_window_of_item',
  description: 'Get the information window for the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      }
    },
    required: ['target_item_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_information_window_of_item_of_container',
  description: 'Get the information window for the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_information_window_of_item_of_disk',
  description: 'Get the information window for the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_information_window_of_item_of_folder',
  description: 'Get the information window for the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_information_window_of_item_of_desktop_object',
  description: 'Get the information window for the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_information_window_of_item_of_trash_object',
  description: 'Get the information window for the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_properties_of_item',
  description: 'Get every property of an item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      }
    },
    required: ['target_item_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_properties_of_item',
  description: 'Set every property of an item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      value_required_record: {
        type: 'string',
        description: 'New value for every property of an item'
      }
    },
    required: ['target_item_required_string', 'value_required_record'],
    additionalProperties: false
  }
},
          {
  name: 'get_properties_of_item_of_container',
  description: 'Get every property of an item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_properties_of_item_of_container',
  description: 'Set every property of an item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      },
      value_required_record: {
        type: 'string',
        description: 'New value for every property of an item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string', 'value_required_record'],
    additionalProperties: false
  }
},
          {
  name: 'get_properties_of_item_of_disk',
  description: 'Get every property of an item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_properties_of_item_of_disk',
  description: 'Set every property of an item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      },
      value_required_record: {
        type: 'string',
        description: 'New value for every property of an item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string', 'value_required_record'],
    additionalProperties: false
  }
},
          {
  name: 'get_properties_of_item_of_folder',
  description: 'Get every property of an item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_properties_of_item_of_folder',
  description: 'Set every property of an item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      },
      value_required_record: {
        type: 'string',
        description: 'New value for every property of an item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string', 'value_required_record'],
    additionalProperties: false
  }
},
          {
  name: 'get_properties_of_item_of_desktop_object',
  description: 'Get every property of an item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_properties_of_item_of_desktop_object',
  description: 'Set every property of an item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      },
      value_required_record: {
        type: 'string',
        description: 'New value for every property of an item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string', 'value_required_record'],
    additionalProperties: false
  }
},
          {
  name: 'get_properties_of_item_of_trash_object',
  description: 'Get every property of an item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_properties_of_item_of_trash_object',
  description: 'Set every property of an item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      },
      value_required_record: {
        type: 'string',
        description: 'New value for every property of an item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string', 'value_required_record'],
    additionalProperties: false
  }
},
          {
  name: 'get_class_of_item',
  description: 'Get the class of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      }
    },
    required: ['target_item_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_class_of_item_of_container',
  description: 'Get the class of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the item'
      }
    },
    required: ['target_item_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_class_of_item_of_disk',
  description: 'Get the class of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the item'
      }
    },
    required: ['target_item_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_class_of_item_of_folder',
  description: 'Get the class of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the item'
      }
    },
    required: ['target_item_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_class_of_item_of_desktop_object',
  description: 'Get the class of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_class_of_item_of_trash_object',
  description: 'Get the class of the item',
  inputSchema: {
    type: 'object',
    properties: {
      target_item_required_string: {
        type: 'string',
        description: 'The item object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the item'
      }
    },
    required: ['target_item_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_entire_contents_of_container',
  description: 'Get the entire contents of the container, including the contents of its children',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      }
    },
    required: ['target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_entire_contents_of_container_of_disk',
  description: 'Get the entire contents of the container, including the contents of its children',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the container'
      }
    },
    required: ['target_container_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_entire_contents_of_container_of_folder',
  description: 'Get the entire contents of the container, including the contents of its children',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the container'
      }
    },
    required: ['target_container_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_entire_contents_of_container_of_desktop_object',
  description: 'Get the entire contents of the container, including the contents of its children',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the container'
      }
    },
    required: ['target_container_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_entire_contents_of_container_of_trash_object',
  description: 'Get the entire contents of the container, including the contents of its children',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the container'
      }
    },
    required: ['target_container_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_expandable_of_container',
  description: 'Get (NOT AVAILABLE YET) Is the container capable of being expanded as an outline?',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      }
    },
    required: ['target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_expandable_of_container_of_disk',
  description: 'Get (NOT AVAILABLE YET) Is the container capable of being expanded as an outline?',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the container'
      }
    },
    required: ['target_container_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_expandable_of_container_of_folder',
  description: 'Get (NOT AVAILABLE YET) Is the container capable of being expanded as an outline?',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the container'
      }
    },
    required: ['target_container_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_expandable_of_container_of_desktop_object',
  description: 'Get (NOT AVAILABLE YET) Is the container capable of being expanded as an outline?',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the container'
      }
    },
    required: ['target_container_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_expandable_of_container_of_trash_object',
  description: 'Get (NOT AVAILABLE YET) Is the container capable of being expanded as an outline?',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the container'
      }
    },
    required: ['target_container_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_expanded_of_container',
  description: 'Get (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      }
    },
    required: ['target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_expanded_of_container',
  description: 'Set (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)'
      }
    },
    required: ['target_container_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_expanded_of_container_of_disk',
  description: 'Get (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the container'
      }
    },
    required: ['target_container_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_expanded_of_container_of_disk',
  description: 'Set (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the container'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)'
      }
    },
    required: ['target_container_required_string', 'target_disk_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_expanded_of_container_of_folder',
  description: 'Get (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the container'
      }
    },
    required: ['target_container_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_expanded_of_container_of_folder',
  description: 'Set (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the container'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)'
      }
    },
    required: ['target_container_required_string', 'target_folder_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_expanded_of_container_of_desktop_object',
  description: 'Get (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the container'
      }
    },
    required: ['target_container_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_expanded_of_container_of_desktop_object',
  description: 'Set (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the container'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)'
      }
    },
    required: ['target_container_required_string', 'target_desktop_object_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_expanded_of_container_of_trash_object',
  description: 'Get (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the container'
      }
    },
    required: ['target_container_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_expanded_of_container_of_trash_object',
  description: 'Set (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the container'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)'
      }
    },
    required: ['target_container_required_string', 'target_trash_object_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_completely_expanded_of_container',
  description: 'Get (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      }
    },
    required: ['target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_completely_expanded_of_container',
  description: 'Set (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)'
      }
    },
    required: ['target_container_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_completely_expanded_of_container_of_disk',
  description: 'Get (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the container'
      }
    },
    required: ['target_container_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_completely_expanded_of_container_of_disk',
  description: 'Set (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the container'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)'
      }
    },
    required: ['target_container_required_string', 'target_disk_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_completely_expanded_of_container_of_folder',
  description: 'Get (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the container'
      }
    },
    required: ['target_container_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_completely_expanded_of_container_of_folder',
  description: 'Set (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the container'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)'
      }
    },
    required: ['target_container_required_string', 'target_folder_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_completely_expanded_of_container_of_desktop_object',
  description: 'Get (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the container'
      }
    },
    required: ['target_container_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_completely_expanded_of_container_of_desktop_object',
  description: 'Set (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the container'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)'
      }
    },
    required: ['target_container_required_string', 'target_desktop_object_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_completely_expanded_of_container_of_trash_object',
  description: 'Get (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the container'
      }
    },
    required: ['target_container_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_completely_expanded_of_container_of_trash_object',
  description: 'Set (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the container'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)'
      }
    },
    required: ['target_container_required_string', 'target_trash_object_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_container_window_of_container',
  description: 'Get the container window for this folder',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      }
    },
    required: ['target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_container_window_of_container_of_disk',
  description: 'Get the container window for this folder',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the container'
      }
    },
    required: ['target_container_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_container_window_of_container_of_folder',
  description: 'Get the container window for this folder',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the container'
      }
    },
    required: ['target_container_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_container_window_of_container_of_desktop_object',
  description: 'Get the container window for this folder',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the container'
      }
    },
    required: ['target_container_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_container_window_of_container_of_trash_object',
  description: 'Get the container window for this folder',
  inputSchema: {
    type: 'object',
    properties: {
      target_container_required_string: {
        type: 'string',
        description: 'The container object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the container'
      }
    },
    required: ['target_container_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_id_of_disk',
  description: 'Get the unique id for this disk (unchanged while disk remains connected and Finder remains running)',
  inputSchema: {
    type: 'object',
    properties: {
      target_disk_required_string: {
        type: 'string',
        description: 'The disk object'
      }
    },
    required: ['target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_id_of_disk_of_desktop_object',
  description: 'Get the unique id for this disk (unchanged while disk remains connected and Finder remains running)',
  inputSchema: {
    type: 'object',
    properties: {
      target_disk_required_string: {
        type: 'string',
        description: 'The disk object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the disk'
      }
    },
    required: ['target_disk_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_capacity_of_disk',
  description: 'Get the total number of bytes (free or used) on the disk',
  inputSchema: {
    type: 'object',
    properties: {
      target_disk_required_string: {
        type: 'string',
        description: 'The disk object'
      }
    },
    required: ['target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_capacity_of_disk_of_desktop_object',
  description: 'Get the total number of bytes (free or used) on the disk',
  inputSchema: {
    type: 'object',
    properties: {
      target_disk_required_string: {
        type: 'string',
        description: 'The disk object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the disk'
      }
    },
    required: ['target_disk_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_free_space_of_disk',
  description: 'Get the number of free bytes left on the disk',
  inputSchema: {
    type: 'object',
    properties: {
      target_disk_required_string: {
        type: 'string',
        description: 'The disk object'
      }
    },
    required: ['target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_free_space_of_disk_of_desktop_object',
  description: 'Get the number of free bytes left on the disk',
  inputSchema: {
    type: 'object',
    properties: {
      target_disk_required_string: {
        type: 'string',
        description: 'The disk object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the disk'
      }
    },
    required: ['target_disk_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_ejectable_of_disk',
  description: 'Get Can the media be ejected (floppies, CDs, and so on)? of disk',
  inputSchema: {
    type: 'object',
    properties: {
      target_disk_required_string: {
        type: 'string',
        description: 'The disk object'
      }
    },
    required: ['target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_ejectable_of_disk_of_desktop_object',
  description: 'Get Can the media be ejected (floppies, CDs, and so on)? of disk',
  inputSchema: {
    type: 'object',
    properties: {
      target_disk_required_string: {
        type: 'string',
        description: 'The disk object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the disk'
      }
    },
    required: ['target_disk_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_local_volume_of_disk',
  description: 'Get Is the media a local volume (as opposed to a file server)? of disk',
  inputSchema: {
    type: 'object',
    properties: {
      target_disk_required_string: {
        type: 'string',
        description: 'The disk object'
      }
    },
    required: ['target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_local_volume_of_disk_of_desktop_object',
  description: 'Get Is the media a local volume (as opposed to a file server)? of disk',
  inputSchema: {
    type: 'object',
    properties: {
      target_disk_required_string: {
        type: 'string',
        description: 'The disk object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the disk'
      }
    },
    required: ['target_disk_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_startup_of_disk',
  description: 'Get Is this disk the boot disk?',
  inputSchema: {
    type: 'object',
    properties: {
      target_disk_required_string: {
        type: 'string',
        description: 'The disk object'
      }
    },
    required: ['target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_startup_of_disk_of_desktop_object',
  description: 'Get Is this disk the boot disk?',
  inputSchema: {
    type: 'object',
    properties: {
      target_disk_required_string: {
        type: 'string',
        description: 'The disk object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the disk'
      }
    },
    required: ['target_disk_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_format_of_disk',
  description: 'Get the filesystem format of this disk',
  inputSchema: {
    type: 'object',
    properties: {
      target_disk_required_string: {
        type: 'string',
        description: 'The disk object'
      }
    },
    required: ['target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_format_of_disk_of_desktop_object',
  description: 'Get the filesystem format of this disk',
  inputSchema: {
    type: 'object',
    properties: {
      target_disk_required_string: {
        type: 'string',
        description: 'The disk object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the disk'
      }
    },
    required: ['target_disk_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_journaling_enabled_of_disk',
  description: 'Get Does this disk do file system journaling?',
  inputSchema: {
    type: 'object',
    properties: {
      target_disk_required_string: {
        type: 'string',
        description: 'The disk object'
      }
    },
    required: ['target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_journaling_enabled_of_disk_of_desktop_object',
  description: 'Get Does this disk do file system journaling?',
  inputSchema: {
    type: 'object',
    properties: {
      target_disk_required_string: {
        type: 'string',
        description: 'The disk object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the disk'
      }
    },
    required: ['target_disk_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_ignore_privileges_of_disk',
  description: 'Get Ignore permissions on this disk?',
  inputSchema: {
    type: 'object',
    properties: {
      target_disk_required_string: {
        type: 'string',
        description: 'The disk object'
      }
    },
    required: ['target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_ignore_privileges_of_disk',
  description: 'Set Ignore permissions on this disk?',
  inputSchema: {
    type: 'object',
    properties: {
      target_disk_required_string: {
        type: 'string',
        description: 'The disk object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Ignore permissions on this disk?'
      }
    },
    required: ['target_disk_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_ignore_privileges_of_disk_of_desktop_object',
  description: 'Get Ignore permissions on this disk?',
  inputSchema: {
    type: 'object',
    properties: {
      target_disk_required_string: {
        type: 'string',
        description: 'The disk object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the disk'
      }
    },
    required: ['target_disk_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_ignore_privileges_of_disk_of_desktop_object',
  description: 'Set Ignore permissions on this disk?',
  inputSchema: {
    type: 'object',
    properties: {
      target_disk_required_string: {
        type: 'string',
        description: 'The disk object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the disk'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Ignore permissions on this disk?'
      }
    },
    required: ['target_disk_required_string', 'target_desktop_object_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_warns_before_emptying_of_trash_object',
  description: 'Get Display a dialog when emptying the trash? of trash-object',
  inputSchema: {
    type: 'object',
    properties: {
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object object'
      }
    },
    required: ['target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_warns_before_emptying_of_trash_object',
  description: 'Set Display a dialog when emptying the trash? of trash-object',
  inputSchema: {
    type: 'object',
    properties: {
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Display a dialog when emptying the trash?'
      }
    },
    required: ['target_trash_object_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_file_type_of_file',
  description: 'Get the OSType identifying the type of data contained in the item of file',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      }
    },
    required: ['target_file_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_file_type_of_file',
  description: 'Set the OSType identifying the type of data contained in the item of file',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      value_required_type: {
        type: 'string',
        description: 'New value for the OSType identifying the type of data contained in the item'
      }
    },
    required: ['target_file_required_string', 'value_required_type'],
    additionalProperties: false
  }
},
          {
  name: 'get_file_type_of_file_of_container',
  description: 'Get the OSType identifying the type of data contained in the item of file',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the file'
      }
    },
    required: ['target_file_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_file_type_of_file_of_container',
  description: 'Set the OSType identifying the type of data contained in the item of file',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the file'
      },
      value_required_type: {
        type: 'string',
        description: 'New value for the OSType identifying the type of data contained in the item'
      }
    },
    required: ['target_file_required_string', 'target_container_required_string', 'value_required_type'],
    additionalProperties: false
  }
},
          {
  name: 'get_file_type_of_file_of_disk',
  description: 'Get the OSType identifying the type of data contained in the item of file',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the file'
      }
    },
    required: ['target_file_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_file_type_of_file_of_disk',
  description: 'Set the OSType identifying the type of data contained in the item of file',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the file'
      },
      value_required_type: {
        type: 'string',
        description: 'New value for the OSType identifying the type of data contained in the item'
      }
    },
    required: ['target_file_required_string', 'target_disk_required_string', 'value_required_type'],
    additionalProperties: false
  }
},
          {
  name: 'get_file_type_of_file_of_folder',
  description: 'Get the OSType identifying the type of data contained in the item of file',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the file'
      }
    },
    required: ['target_file_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_file_type_of_file_of_folder',
  description: 'Set the OSType identifying the type of data contained in the item of file',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the file'
      },
      value_required_type: {
        type: 'string',
        description: 'New value for the OSType identifying the type of data contained in the item'
      }
    },
    required: ['target_file_required_string', 'target_folder_required_string', 'value_required_type'],
    additionalProperties: false
  }
},
          {
  name: 'get_file_type_of_file_of_desktop_object',
  description: 'Get the OSType identifying the type of data contained in the item of file',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the file'
      }
    },
    required: ['target_file_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_file_type_of_file_of_desktop_object',
  description: 'Set the OSType identifying the type of data contained in the item of file',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the file'
      },
      value_required_type: {
        type: 'string',
        description: 'New value for the OSType identifying the type of data contained in the item'
      }
    },
    required: ['target_file_required_string', 'target_desktop_object_required_string', 'value_required_type'],
    additionalProperties: false
  }
},
          {
  name: 'get_file_type_of_file_of_trash_object',
  description: 'Get the OSType identifying the type of data contained in the item of file',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the file'
      }
    },
    required: ['target_file_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_file_type_of_file_of_trash_object',
  description: 'Set the OSType identifying the type of data contained in the item of file',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the file'
      },
      value_required_type: {
        type: 'string',
        description: 'New value for the OSType identifying the type of data contained in the item'
      }
    },
    required: ['target_file_required_string', 'target_trash_object_required_string', 'value_required_type'],
    additionalProperties: false
  }
},
          {
  name: 'get_creator_type_of_file',
  description: 'Get the OSType identifying the application that created the item of file',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      }
    },
    required: ['target_file_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_creator_type_of_file',
  description: 'Set the OSType identifying the application that created the item of file',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      value_required_type: {
        type: 'string',
        description: 'New value for the OSType identifying the application that created the item'
      }
    },
    required: ['target_file_required_string', 'value_required_type'],
    additionalProperties: false
  }
},
          {
  name: 'get_creator_type_of_file_of_container',
  description: 'Get the OSType identifying the application that created the item of file',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the file'
      }
    },
    required: ['target_file_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_creator_type_of_file_of_container',
  description: 'Set the OSType identifying the application that created the item of file',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the file'
      },
      value_required_type: {
        type: 'string',
        description: 'New value for the OSType identifying the application that created the item'
      }
    },
    required: ['target_file_required_string', 'target_container_required_string', 'value_required_type'],
    additionalProperties: false
  }
},
          {
  name: 'get_creator_type_of_file_of_disk',
  description: 'Get the OSType identifying the application that created the item of file',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the file'
      }
    },
    required: ['target_file_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_creator_type_of_file_of_disk',
  description: 'Set the OSType identifying the application that created the item of file',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the file'
      },
      value_required_type: {
        type: 'string',
        description: 'New value for the OSType identifying the application that created the item'
      }
    },
    required: ['target_file_required_string', 'target_disk_required_string', 'value_required_type'],
    additionalProperties: false
  }
},
          {
  name: 'get_creator_type_of_file_of_folder',
  description: 'Get the OSType identifying the application that created the item of file',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the file'
      }
    },
    required: ['target_file_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_creator_type_of_file_of_folder',
  description: 'Set the OSType identifying the application that created the item of file',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the file'
      },
      value_required_type: {
        type: 'string',
        description: 'New value for the OSType identifying the application that created the item'
      }
    },
    required: ['target_file_required_string', 'target_folder_required_string', 'value_required_type'],
    additionalProperties: false
  }
},
          {
  name: 'get_creator_type_of_file_of_desktop_object',
  description: 'Get the OSType identifying the application that created the item of file',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the file'
      }
    },
    required: ['target_file_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_creator_type_of_file_of_desktop_object',
  description: 'Set the OSType identifying the application that created the item of file',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the file'
      },
      value_required_type: {
        type: 'string',
        description: 'New value for the OSType identifying the application that created the item'
      }
    },
    required: ['target_file_required_string', 'target_desktop_object_required_string', 'value_required_type'],
    additionalProperties: false
  }
},
          {
  name: 'get_creator_type_of_file_of_trash_object',
  description: 'Get the OSType identifying the application that created the item of file',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the file'
      }
    },
    required: ['target_file_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_creator_type_of_file_of_trash_object',
  description: 'Set the OSType identifying the application that created the item of file',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the file'
      },
      value_required_type: {
        type: 'string',
        description: 'New value for the OSType identifying the application that created the item'
      }
    },
    required: ['target_file_required_string', 'target_trash_object_required_string', 'value_required_type'],
    additionalProperties: false
  }
},
          {
  name: 'get_stationery_of_file',
  description: 'Get Is the file a stationery pad?',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      }
    },
    required: ['target_file_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_stationery_of_file',
  description: 'Set Is the file a stationery pad?',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Is the file a stationery pad?'
      }
    },
    required: ['target_file_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_stationery_of_file_of_container',
  description: 'Get Is the file a stationery pad?',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the file'
      }
    },
    required: ['target_file_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_stationery_of_file_of_container',
  description: 'Set Is the file a stationery pad?',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the file'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Is the file a stationery pad?'
      }
    },
    required: ['target_file_required_string', 'target_container_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_stationery_of_file_of_disk',
  description: 'Get Is the file a stationery pad?',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the file'
      }
    },
    required: ['target_file_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_stationery_of_file_of_disk',
  description: 'Set Is the file a stationery pad?',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the file'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Is the file a stationery pad?'
      }
    },
    required: ['target_file_required_string', 'target_disk_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_stationery_of_file_of_folder',
  description: 'Get Is the file a stationery pad?',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the file'
      }
    },
    required: ['target_file_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_stationery_of_file_of_folder',
  description: 'Set Is the file a stationery pad?',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the file'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Is the file a stationery pad?'
      }
    },
    required: ['target_file_required_string', 'target_folder_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_stationery_of_file_of_desktop_object',
  description: 'Get Is the file a stationery pad?',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the file'
      }
    },
    required: ['target_file_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_stationery_of_file_of_desktop_object',
  description: 'Set Is the file a stationery pad?',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the file'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Is the file a stationery pad?'
      }
    },
    required: ['target_file_required_string', 'target_desktop_object_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_stationery_of_file_of_trash_object',
  description: 'Get Is the file a stationery pad?',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the file'
      }
    },
    required: ['target_file_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_stationery_of_file_of_trash_object',
  description: 'Set Is the file a stationery pad?',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the file'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Is the file a stationery pad?'
      }
    },
    required: ['target_file_required_string', 'target_trash_object_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_product_version_of_file',
  description: 'Get the version of the product (visible at the top of the “Get Info” window) of file',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      }
    },
    required: ['target_file_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_product_version_of_file_of_container',
  description: 'Get the version of the product (visible at the top of the “Get Info” window) of file',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the file'
      }
    },
    required: ['target_file_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_product_version_of_file_of_disk',
  description: 'Get the version of the product (visible at the top of the “Get Info” window) of file',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the file'
      }
    },
    required: ['target_file_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_product_version_of_file_of_folder',
  description: 'Get the version of the product (visible at the top of the “Get Info” window) of file',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the file'
      }
    },
    required: ['target_file_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_product_version_of_file_of_desktop_object',
  description: 'Get the version of the product (visible at the top of the “Get Info” window) of file',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the file'
      }
    },
    required: ['target_file_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_product_version_of_file_of_trash_object',
  description: 'Get the version of the product (visible at the top of the “Get Info” window) of file',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the file'
      }
    },
    required: ['target_file_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_version_of_file',
  description: 'Get the version of the file (visible at the bottom of the “Get Info” window)',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      }
    },
    required: ['target_file_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_version_of_file_of_container',
  description: 'Get the version of the file (visible at the bottom of the “Get Info” window)',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the file'
      }
    },
    required: ['target_file_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_version_of_file_of_disk',
  description: 'Get the version of the file (visible at the bottom of the “Get Info” window)',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the file'
      }
    },
    required: ['target_file_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_version_of_file_of_folder',
  description: 'Get the version of the file (visible at the bottom of the “Get Info” window)',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the file'
      }
    },
    required: ['target_file_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_version_of_file_of_desktop_object',
  description: 'Get the version of the file (visible at the bottom of the “Get Info” window)',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the file'
      }
    },
    required: ['target_file_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_version_of_file_of_trash_object',
  description: 'Get the version of the file (visible at the bottom of the “Get Info” window)',
  inputSchema: {
    type: 'object',
    properties: {
      target_file_required_string: {
        type: 'string',
        description: 'The file object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the file'
      }
    },
    required: ['target_file_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_original_item_of_alias_file',
  description: 'Get the original item pointed to by the alias of alias file',
  inputSchema: {
    type: 'object',
    properties: {
      target_alias_file_required_string: {
        type: 'string',
        description: 'The alias file object'
      }
    },
    required: ['target_alias_file_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_original_item_of_alias_file',
  description: 'Set the original item pointed to by the alias of alias file',
  inputSchema: {
    type: 'object',
    properties: {
      target_alias_file_required_string: {
        type: 'string',
        description: 'The alias file object'
      },
      value_required_specifier: {
        type: 'string',
        description: 'New value for the original item pointed to by the alias'
      }
    },
    required: ['target_alias_file_required_string', 'value_required_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'get_original_item_of_alias_file_of_container',
  description: 'Get the original item pointed to by the alias of alias file',
  inputSchema: {
    type: 'object',
    properties: {
      target_alias_file_required_string: {
        type: 'string',
        description: 'The alias file object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the alias file'
      }
    },
    required: ['target_alias_file_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_original_item_of_alias_file_of_container',
  description: 'Set the original item pointed to by the alias of alias file',
  inputSchema: {
    type: 'object',
    properties: {
      target_alias_file_required_string: {
        type: 'string',
        description: 'The alias file object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the alias file'
      },
      value_required_specifier: {
        type: 'string',
        description: 'New value for the original item pointed to by the alias'
      }
    },
    required: ['target_alias_file_required_string', 'target_container_required_string', 'value_required_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'get_original_item_of_alias_file_of_disk',
  description: 'Get the original item pointed to by the alias of alias file',
  inputSchema: {
    type: 'object',
    properties: {
      target_alias_file_required_string: {
        type: 'string',
        description: 'The alias file object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the alias file'
      }
    },
    required: ['target_alias_file_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_original_item_of_alias_file_of_disk',
  description: 'Set the original item pointed to by the alias of alias file',
  inputSchema: {
    type: 'object',
    properties: {
      target_alias_file_required_string: {
        type: 'string',
        description: 'The alias file object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the alias file'
      },
      value_required_specifier: {
        type: 'string',
        description: 'New value for the original item pointed to by the alias'
      }
    },
    required: ['target_alias_file_required_string', 'target_disk_required_string', 'value_required_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'get_original_item_of_alias_file_of_folder',
  description: 'Get the original item pointed to by the alias of alias file',
  inputSchema: {
    type: 'object',
    properties: {
      target_alias_file_required_string: {
        type: 'string',
        description: 'The alias file object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the alias file'
      }
    },
    required: ['target_alias_file_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_original_item_of_alias_file_of_folder',
  description: 'Set the original item pointed to by the alias of alias file',
  inputSchema: {
    type: 'object',
    properties: {
      target_alias_file_required_string: {
        type: 'string',
        description: 'The alias file object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the alias file'
      },
      value_required_specifier: {
        type: 'string',
        description: 'New value for the original item pointed to by the alias'
      }
    },
    required: ['target_alias_file_required_string', 'target_folder_required_string', 'value_required_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'get_original_item_of_alias_file_of_desktop_object',
  description: 'Get the original item pointed to by the alias of alias file',
  inputSchema: {
    type: 'object',
    properties: {
      target_alias_file_required_string: {
        type: 'string',
        description: 'The alias file object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the alias file'
      }
    },
    required: ['target_alias_file_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_original_item_of_alias_file_of_desktop_object',
  description: 'Set the original item pointed to by the alias of alias file',
  inputSchema: {
    type: 'object',
    properties: {
      target_alias_file_required_string: {
        type: 'string',
        description: 'The alias file object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the alias file'
      },
      value_required_specifier: {
        type: 'string',
        description: 'New value for the original item pointed to by the alias'
      }
    },
    required: ['target_alias_file_required_string', 'target_desktop_object_required_string', 'value_required_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'get_original_item_of_alias_file_of_trash_object',
  description: 'Get the original item pointed to by the alias of alias file',
  inputSchema: {
    type: 'object',
    properties: {
      target_alias_file_required_string: {
        type: 'string',
        description: 'The alias file object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the alias file'
      }
    },
    required: ['target_alias_file_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_original_item_of_alias_file_of_trash_object',
  description: 'Set the original item pointed to by the alias of alias file',
  inputSchema: {
    type: 'object',
    properties: {
      target_alias_file_required_string: {
        type: 'string',
        description: 'The alias file object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the alias file'
      },
      value_required_specifier: {
        type: 'string',
        description: 'New value for the original item pointed to by the alias'
      }
    },
    required: ['target_alias_file_required_string', 'target_trash_object_required_string', 'value_required_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'get_id_of_application_file',
  description: 'Get the bundle identifier or creator type of the application of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      }
    },
    required: ['target_application_file_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_id_of_application_file_of_container',
  description: 'Get the bundle identifier or creator type of the application of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_id_of_application_file_of_disk',
  description: 'Get the bundle identifier or creator type of the application of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_id_of_application_file_of_folder',
  description: 'Get the bundle identifier or creator type of the application of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_id_of_application_file_of_desktop_object',
  description: 'Get the bundle identifier or creator type of the application of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_id_of_application_file_of_trash_object',
  description: 'Get the bundle identifier or creator type of the application of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_suggested_size_of_application_file',
  description: 'Get (AVAILABLE IN 10.1 TO 10.4) the memory size with which the developer recommends the application be launched of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      }
    },
    required: ['target_application_file_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_suggested_size_of_application_file_of_container',
  description: 'Get (AVAILABLE IN 10.1 TO 10.4) the memory size with which the developer recommends the application be launched of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_suggested_size_of_application_file_of_disk',
  description: 'Get (AVAILABLE IN 10.1 TO 10.4) the memory size with which the developer recommends the application be launched of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_suggested_size_of_application_file_of_folder',
  description: 'Get (AVAILABLE IN 10.1 TO 10.4) the memory size with which the developer recommends the application be launched of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_suggested_size_of_application_file_of_desktop_object',
  description: 'Get (AVAILABLE IN 10.1 TO 10.4) the memory size with which the developer recommends the application be launched of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_suggested_size_of_application_file_of_trash_object',
  description: 'Get (AVAILABLE IN 10.1 TO 10.4) the memory size with which the developer recommends the application be launched of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_minimum_size_of_application_file',
  description: 'Get (AVAILABLE IN 10.1 TO 10.4) the smallest memory size with which the application can be launched of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      }
    },
    required: ['target_application_file_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_minimum_size_of_application_file',
  description: 'Set (AVAILABLE IN 10.1 TO 10.4) the smallest memory size with which the application can be launched of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      value_required_integer: {
        type: 'number',
        description: 'New value for (AVAILABLE IN 10.1 TO 10.4) the smallest memory size with which the application can be launched'
      }
    },
    required: ['target_application_file_required_string', 'value_required_integer'],
    additionalProperties: false
  }
},
          {
  name: 'get_minimum_size_of_application_file_of_container',
  description: 'Get (AVAILABLE IN 10.1 TO 10.4) the smallest memory size with which the application can be launched of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_minimum_size_of_application_file_of_container',
  description: 'Set (AVAILABLE IN 10.1 TO 10.4) the smallest memory size with which the application can be launched of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the application file'
      },
      value_required_integer: {
        type: 'number',
        description: 'New value for (AVAILABLE IN 10.1 TO 10.4) the smallest memory size with which the application can be launched'
      }
    },
    required: ['target_application_file_required_string', 'target_container_required_string', 'value_required_integer'],
    additionalProperties: false
  }
},
          {
  name: 'get_minimum_size_of_application_file_of_disk',
  description: 'Get (AVAILABLE IN 10.1 TO 10.4) the smallest memory size with which the application can be launched of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_minimum_size_of_application_file_of_disk',
  description: 'Set (AVAILABLE IN 10.1 TO 10.4) the smallest memory size with which the application can be launched of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the application file'
      },
      value_required_integer: {
        type: 'number',
        description: 'New value for (AVAILABLE IN 10.1 TO 10.4) the smallest memory size with which the application can be launched'
      }
    },
    required: ['target_application_file_required_string', 'target_disk_required_string', 'value_required_integer'],
    additionalProperties: false
  }
},
          {
  name: 'get_minimum_size_of_application_file_of_folder',
  description: 'Get (AVAILABLE IN 10.1 TO 10.4) the smallest memory size with which the application can be launched of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_minimum_size_of_application_file_of_folder',
  description: 'Set (AVAILABLE IN 10.1 TO 10.4) the smallest memory size with which the application can be launched of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the application file'
      },
      value_required_integer: {
        type: 'number',
        description: 'New value for (AVAILABLE IN 10.1 TO 10.4) the smallest memory size with which the application can be launched'
      }
    },
    required: ['target_application_file_required_string', 'target_folder_required_string', 'value_required_integer'],
    additionalProperties: false
  }
},
          {
  name: 'get_minimum_size_of_application_file_of_desktop_object',
  description: 'Get (AVAILABLE IN 10.1 TO 10.4) the smallest memory size with which the application can be launched of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_minimum_size_of_application_file_of_desktop_object',
  description: 'Set (AVAILABLE IN 10.1 TO 10.4) the smallest memory size with which the application can be launched of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the application file'
      },
      value_required_integer: {
        type: 'number',
        description: 'New value for (AVAILABLE IN 10.1 TO 10.4) the smallest memory size with which the application can be launched'
      }
    },
    required: ['target_application_file_required_string', 'target_desktop_object_required_string', 'value_required_integer'],
    additionalProperties: false
  }
},
          {
  name: 'get_minimum_size_of_application_file_of_trash_object',
  description: 'Get (AVAILABLE IN 10.1 TO 10.4) the smallest memory size with which the application can be launched of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_minimum_size_of_application_file_of_trash_object',
  description: 'Set (AVAILABLE IN 10.1 TO 10.4) the smallest memory size with which the application can be launched of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the application file'
      },
      value_required_integer: {
        type: 'number',
        description: 'New value for (AVAILABLE IN 10.1 TO 10.4) the smallest memory size with which the application can be launched'
      }
    },
    required: ['target_application_file_required_string', 'target_trash_object_required_string', 'value_required_integer'],
    additionalProperties: false
  }
},
          {
  name: 'get_preferred_size_of_application_file',
  description: 'Get (AVAILABLE IN 10.1 TO 10.4) the memory size with which the application will be launched of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      }
    },
    required: ['target_application_file_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_preferred_size_of_application_file',
  description: 'Set (AVAILABLE IN 10.1 TO 10.4) the memory size with which the application will be launched of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      value_required_integer: {
        type: 'number',
        description: 'New value for (AVAILABLE IN 10.1 TO 10.4) the memory size with which the application will be launched'
      }
    },
    required: ['target_application_file_required_string', 'value_required_integer'],
    additionalProperties: false
  }
},
          {
  name: 'get_preferred_size_of_application_file_of_container',
  description: 'Get (AVAILABLE IN 10.1 TO 10.4) the memory size with which the application will be launched of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_preferred_size_of_application_file_of_container',
  description: 'Set (AVAILABLE IN 10.1 TO 10.4) the memory size with which the application will be launched of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the application file'
      },
      value_required_integer: {
        type: 'number',
        description: 'New value for (AVAILABLE IN 10.1 TO 10.4) the memory size with which the application will be launched'
      }
    },
    required: ['target_application_file_required_string', 'target_container_required_string', 'value_required_integer'],
    additionalProperties: false
  }
},
          {
  name: 'get_preferred_size_of_application_file_of_disk',
  description: 'Get (AVAILABLE IN 10.1 TO 10.4) the memory size with which the application will be launched of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_preferred_size_of_application_file_of_disk',
  description: 'Set (AVAILABLE IN 10.1 TO 10.4) the memory size with which the application will be launched of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the application file'
      },
      value_required_integer: {
        type: 'number',
        description: 'New value for (AVAILABLE IN 10.1 TO 10.4) the memory size with which the application will be launched'
      }
    },
    required: ['target_application_file_required_string', 'target_disk_required_string', 'value_required_integer'],
    additionalProperties: false
  }
},
          {
  name: 'get_preferred_size_of_application_file_of_folder',
  description: 'Get (AVAILABLE IN 10.1 TO 10.4) the memory size with which the application will be launched of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_preferred_size_of_application_file_of_folder',
  description: 'Set (AVAILABLE IN 10.1 TO 10.4) the memory size with which the application will be launched of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the application file'
      },
      value_required_integer: {
        type: 'number',
        description: 'New value for (AVAILABLE IN 10.1 TO 10.4) the memory size with which the application will be launched'
      }
    },
    required: ['target_application_file_required_string', 'target_folder_required_string', 'value_required_integer'],
    additionalProperties: false
  }
},
          {
  name: 'get_preferred_size_of_application_file_of_desktop_object',
  description: 'Get (AVAILABLE IN 10.1 TO 10.4) the memory size with which the application will be launched of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_preferred_size_of_application_file_of_desktop_object',
  description: 'Set (AVAILABLE IN 10.1 TO 10.4) the memory size with which the application will be launched of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the application file'
      },
      value_required_integer: {
        type: 'number',
        description: 'New value for (AVAILABLE IN 10.1 TO 10.4) the memory size with which the application will be launched'
      }
    },
    required: ['target_application_file_required_string', 'target_desktop_object_required_string', 'value_required_integer'],
    additionalProperties: false
  }
},
          {
  name: 'get_preferred_size_of_application_file_of_trash_object',
  description: 'Get (AVAILABLE IN 10.1 TO 10.4) the memory size with which the application will be launched of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_preferred_size_of_application_file_of_trash_object',
  description: 'Set (AVAILABLE IN 10.1 TO 10.4) the memory size with which the application will be launched of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the application file'
      },
      value_required_integer: {
        type: 'number',
        description: 'New value for (AVAILABLE IN 10.1 TO 10.4) the memory size with which the application will be launched'
      }
    },
    required: ['target_application_file_required_string', 'target_trash_object_required_string', 'value_required_integer'],
    additionalProperties: false
  }
},
          {
  name: 'get_accepts_high_level_events_of_application_file',
  description: 'Get Is the application high-level event aware? (OBSOLETE: always returns true) of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      }
    },
    required: ['target_application_file_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_accepts_high_level_events_of_application_file_of_container',
  description: 'Get Is the application high-level event aware? (OBSOLETE: always returns true) of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_accepts_high_level_events_of_application_file_of_disk',
  description: 'Get Is the application high-level event aware? (OBSOLETE: always returns true) of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_accepts_high_level_events_of_application_file_of_folder',
  description: 'Get Is the application high-level event aware? (OBSOLETE: always returns true) of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_accepts_high_level_events_of_application_file_of_desktop',
  description: 'Get Is the application high-level event aware? (OBSOLETE: always returns true) of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_accepts_high_level_events_of_application_file_of_trash',
  description: 'Get Is the application high-level event aware? (OBSOLETE: always returns true) of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_has_scripting_terminology_of_application_file',
  description: 'Get Does the process have a scripting terminology, i.e., can it be scripted? of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      }
    },
    required: ['target_application_file_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_has_scripting_terminology_of_application_file_of_container',
  description: 'Get Does the process have a scripting terminology, i.e., can it be scripted? of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_has_scripting_terminology_of_application_file_of_disk',
  description: 'Get Does the process have a scripting terminology, i.e., can it be scripted? of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_has_scripting_terminology_of_application_file_of_folder',
  description: 'Get Does the process have a scripting terminology, i.e., can it be scripted? of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_has_scripting_terminology_of_application_file_of_desktop',
  description: 'Get Does the process have a scripting terminology, i.e., can it be scripted? of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_has_scripting_terminology_of_application_file_of_trash',
  description: 'Get Does the process have a scripting terminology, i.e., can it be scripted? of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_opens_in_classic_of_application_file',
  description: 'Get (AVAILABLE IN 10.1 TO 10.4) Should the application launch in the Classic environment? of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      }
    },
    required: ['target_application_file_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_opens_in_classic_of_application_file',
  description: 'Set (AVAILABLE IN 10.1 TO 10.4) Should the application launch in the Classic environment? of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for (AVAILABLE IN 10.1 TO 10.4) Should the application launch in the Classic environment?'
      }
    },
    required: ['target_application_file_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_opens_in_classic_of_application_file_of_container',
  description: 'Get (AVAILABLE IN 10.1 TO 10.4) Should the application launch in the Classic environment? of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_opens_in_classic_of_application_file_of_container',
  description: 'Set (AVAILABLE IN 10.1 TO 10.4) Should the application launch in the Classic environment? of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the application file'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for (AVAILABLE IN 10.1 TO 10.4) Should the application launch in the Classic environment?'
      }
    },
    required: ['target_application_file_required_string', 'target_container_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_opens_in_classic_of_application_file_of_disk',
  description: 'Get (AVAILABLE IN 10.1 TO 10.4) Should the application launch in the Classic environment? of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_opens_in_classic_of_application_file_of_disk',
  description: 'Set (AVAILABLE IN 10.1 TO 10.4) Should the application launch in the Classic environment? of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the application file'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for (AVAILABLE IN 10.1 TO 10.4) Should the application launch in the Classic environment?'
      }
    },
    required: ['target_application_file_required_string', 'target_disk_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_opens_in_classic_of_application_file_of_folder',
  description: 'Get (AVAILABLE IN 10.1 TO 10.4) Should the application launch in the Classic environment? of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_opens_in_classic_of_application_file_of_folder',
  description: 'Set (AVAILABLE IN 10.1 TO 10.4) Should the application launch in the Classic environment? of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the application file'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for (AVAILABLE IN 10.1 TO 10.4) Should the application launch in the Classic environment?'
      }
    },
    required: ['target_application_file_required_string', 'target_folder_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_opens_in_classic_of_application_file_of_desktop_object',
  description: 'Get (AVAILABLE IN 10.1 TO 10.4) Should the application launch in the Classic environment? of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_opens_in_classic_of_application_file_of_desktop_object',
  description: 'Set (AVAILABLE IN 10.1 TO 10.4) Should the application launch in the Classic environment? of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the application file'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for (AVAILABLE IN 10.1 TO 10.4) Should the application launch in the Classic environment?'
      }
    },
    required: ['target_application_file_required_string', 'target_desktop_object_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_opens_in_classic_of_application_file_of_trash_object',
  description: 'Get (AVAILABLE IN 10.1 TO 10.4) Should the application launch in the Classic environment? of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the application file'
      }
    },
    required: ['target_application_file_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_opens_in_classic_of_application_file_of_trash_object',
  description: 'Set (AVAILABLE IN 10.1 TO 10.4) Should the application launch in the Classic environment? of application file',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_file_required_string: {
        type: 'string',
        description: 'The application file object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the application file'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for (AVAILABLE IN 10.1 TO 10.4) Should the application launch in the Classic environment?'
      }
    },
    required: ['target_application_file_required_string', 'target_trash_object_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_location_of_internet_location_file',
  description: 'Get the internet location of internet location file',
  inputSchema: {
    type: 'object',
    properties: {
      target_internet_location_file_required_string: {
        type: 'string',
        description: 'The internet location file object'
      }
    },
    required: ['target_internet_location_file_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_location_of_internet_location_file_of_container',
  description: 'Get the internet location of internet location file',
  inputSchema: {
    type: 'object',
    properties: {
      target_internet_location_file_required_string: {
        type: 'string',
        description: 'The internet location file object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the internet location file'
      }
    },
    required: ['target_internet_location_file_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_location_of_internet_location_file_of_disk',
  description: 'Get the internet location of internet location file',
  inputSchema: {
    type: 'object',
    properties: {
      target_internet_location_file_required_string: {
        type: 'string',
        description: 'The internet location file object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the internet location file'
      }
    },
    required: ['target_internet_location_file_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_location_of_internet_location_file_of_folder',
  description: 'Get the internet location of internet location file',
  inputSchema: {
    type: 'object',
    properties: {
      target_internet_location_file_required_string: {
        type: 'string',
        description: 'The internet location file object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the internet location file'
      }
    },
    required: ['target_internet_location_file_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_location_of_internet_location_file_of_desktop_object',
  description: 'Get the internet location of internet location file',
  inputSchema: {
    type: 'object',
    properties: {
      target_internet_location_file_required_string: {
        type: 'string',
        description: 'The internet location file object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the internet location file'
      }
    },
    required: ['target_internet_location_file_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_location_of_internet_location_file_of_trash_object',
  description: 'Get the internet location of internet location file',
  inputSchema: {
    type: 'object',
    properties: {
      target_internet_location_file_required_string: {
        type: 'string',
        description: 'The internet location file object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the internet location file'
      }
    },
    required: ['target_internet_location_file_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_clipping_window_of_clipping',
  description: 'Get (NOT AVAILABLE YET) the clipping window for this clipping',
  inputSchema: {
    type: 'object',
    properties: {
      target_clipping_required_string: {
        type: 'string',
        description: 'The clipping object'
      }
    },
    required: ['target_clipping_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_clipping_window_of_clipping_of_container',
  description: 'Get (NOT AVAILABLE YET) the clipping window for this clipping',
  inputSchema: {
    type: 'object',
    properties: {
      target_clipping_required_string: {
        type: 'string',
        description: 'The clipping object'
      },
      target_container_required_string: {
        type: 'string',
        description: 'The container containing the clipping'
      }
    },
    required: ['target_clipping_required_string', 'target_container_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_clipping_window_of_clipping_of_disk',
  description: 'Get (NOT AVAILABLE YET) the clipping window for this clipping',
  inputSchema: {
    type: 'object',
    properties: {
      target_clipping_required_string: {
        type: 'string',
        description: 'The clipping object'
      },
      target_disk_required_string: {
        type: 'string',
        description: 'The disk containing the clipping'
      }
    },
    required: ['target_clipping_required_string', 'target_disk_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_clipping_window_of_clipping_of_folder',
  description: 'Get (NOT AVAILABLE YET) the clipping window for this clipping',
  inputSchema: {
    type: 'object',
    properties: {
      target_clipping_required_string: {
        type: 'string',
        description: 'The clipping object'
      },
      target_folder_required_string: {
        type: 'string',
        description: 'The folder containing the clipping'
      }
    },
    required: ['target_clipping_required_string', 'target_folder_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_clipping_window_of_clipping_of_desktop_object',
  description: 'Get (NOT AVAILABLE YET) the clipping window for this clipping',
  inputSchema: {
    type: 'object',
    properties: {
      target_clipping_required_string: {
        type: 'string',
        description: 'The clipping object'
      },
      target_desktop_object_required_string: {
        type: 'string',
        description: 'The desktop-object containing the clipping'
      }
    },
    required: ['target_clipping_required_string', 'target_desktop_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_clipping_window_of_clipping_of_trash_object',
  description: 'Get (NOT AVAILABLE YET) the clipping window for this clipping',
  inputSchema: {
    type: 'object',
    properties: {
      target_clipping_required_string: {
        type: 'string',
        description: 'The clipping object'
      },
      target_trash_object_required_string: {
        type: 'string',
        description: 'The trash-object containing the clipping'
      }
    },
    required: ['target_clipping_required_string', 'target_trash_object_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_position_of_window',
  description: 'Get the upper left position of the window',
  inputSchema: {
    type: 'object',
    properties: {
      target_window_required_string: {
        type: 'string',
        description: 'The window object'
      }
    },
    required: ['target_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_position_of_window',
  description: 'Set the upper left position of the window',
  inputSchema: {
    type: 'object',
    properties: {
      target_window_required_string: {
        type: 'string',
        description: 'The window object'
      },
      value_required_point: {
        type: 'string',
        description: 'New value for the upper left position of the window'
      }
    },
    required: ['target_window_required_string', 'value_required_point'],
    additionalProperties: false
  }
},
          {
  name: 'get_titled_of_window',
  description: 'Get Does the window have a title bar?',
  inputSchema: {
    type: 'object',
    properties: {
      target_window_required_string: {
        type: 'string',
        description: 'The window object'
      }
    },
    required: ['target_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_floating_of_window',
  description: 'Get Does the window have a title bar?',
  inputSchema: {
    type: 'object',
    properties: {
      target_window_required_string: {
        type: 'string',
        description: 'The window object'
      }
    },
    required: ['target_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_modal_of_window',
  description: 'Get Is the window modal?',
  inputSchema: {
    type: 'object',
    properties: {
      target_window_required_string: {
        type: 'string',
        description: 'The window object'
      }
    },
    required: ['target_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_collapsed_of_window',
  description: 'Get Is the window collapsed',
  inputSchema: {
    type: 'object',
    properties: {
      target_window_required_string: {
        type: 'string',
        description: 'The window object'
      }
    },
    required: ['target_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_collapsed_of_window',
  description: 'Set Is the window collapsed',
  inputSchema: {
    type: 'object',
    properties: {
      target_window_required_string: {
        type: 'string',
        description: 'The window object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Is the window collapsed'
      }
    },
    required: ['target_window_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_properties_of_window',
  description: 'Get every property of a window',
  inputSchema: {
    type: 'object',
    properties: {
      target_window_required_string: {
        type: 'string',
        description: 'The window object'
      }
    },
    required: ['target_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_properties_of_window',
  description: 'Set every property of a window',
  inputSchema: {
    type: 'object',
    properties: {
      target_window_required_string: {
        type: 'string',
        description: 'The window object'
      },
      value_required_record: {
        type: 'string',
        description: 'New value for every property of a window'
      }
    },
    required: ['target_window_required_string', 'value_required_record'],
    additionalProperties: false
  }
},
          {
  name: 'get_target_of_finder_window',
  description: 'Get the container at which this file viewer is targeted of Finder window',
  inputSchema: {
    type: 'object',
    properties: {
      target_finder_window_required_string: {
        type: 'string',
        description: 'The Finder window object'
      }
    },
    required: ['target_finder_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_target_of_finder_window',
  description: 'Set the container at which this file viewer is targeted of Finder window',
  inputSchema: {
    type: 'object',
    properties: {
      target_finder_window_required_string: {
        type: 'string',
        description: 'The Finder window object'
      },
      value_required_specifier: {
        type: 'string',
        description: 'New value for the container at which this file viewer is targeted'
      }
    },
    required: ['target_finder_window_required_string', 'value_required_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'get_current_view_of_finder_window',
  description: 'Get the current view for the container window of Finder window',
  inputSchema: {
    type: 'object',
    properties: {
      target_finder_window_required_string: {
        type: 'string',
        description: 'The Finder window object'
      }
    },
    required: ['target_finder_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_current_view_of_finder_window',
  description: 'Set the current view for the container window of Finder window',
  inputSchema: {
    type: 'object',
    properties: {
      target_finder_window_required_string: {
        type: 'string',
        description: 'The Finder window object'
      },
      value_required_ecvw: {
        type: 'string',
        description: 'New value for the current view for the container window'
      }
    },
    required: ['target_finder_window_required_string', 'value_required_ecvw'],
    additionalProperties: false
  }
},
          {
  name: 'get_icon_view_options_of_finder_window',
  description: 'Get the icon view options for the container window of Finder window',
  inputSchema: {
    type: 'object',
    properties: {
      target_finder_window_required_string: {
        type: 'string',
        description: 'The Finder window object'
      }
    },
    required: ['target_finder_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_list_view_options_of_finder_window',
  description: 'Get the list view options for the container window of Finder window',
  inputSchema: {
    type: 'object',
    properties: {
      target_finder_window_required_string: {
        type: 'string',
        description: 'The Finder window object'
      }
    },
    required: ['target_finder_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_column_view_options_of_finder_window',
  description: 'Get the column view options for the container window of Finder window',
  inputSchema: {
    type: 'object',
    properties: {
      target_finder_window_required_string: {
        type: 'string',
        description: 'The Finder window object'
      }
    },
    required: ['target_finder_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_toolbar_visible_of_finder_window',
  description: 'Get Is the window\'s toolbar visible? of Finder window',
  inputSchema: {
    type: 'object',
    properties: {
      target_finder_window_required_string: {
        type: 'string',
        description: 'The Finder window object'
      }
    },
    required: ['target_finder_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_toolbar_visible_of_finder_window',
  description: 'Set Is the window\'s toolbar visible? of Finder window',
  inputSchema: {
    type: 'object',
    properties: {
      target_finder_window_required_string: {
        type: 'string',
        description: 'The Finder window object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Is the window\'s toolbar visible?'
      }
    },
    required: ['target_finder_window_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_statusbar_visible_of_finder_window',
  description: 'Get Is the window\'s status bar visible? of Finder window',
  inputSchema: {
    type: 'object',
    properties: {
      target_finder_window_required_string: {
        type: 'string',
        description: 'The Finder window object'
      }
    },
    required: ['target_finder_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_statusbar_visible_of_finder_window',
  description: 'Set Is the window\'s status bar visible? of Finder window',
  inputSchema: {
    type: 'object',
    properties: {
      target_finder_window_required_string: {
        type: 'string',
        description: 'The Finder window object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Is the window\'s status bar visible?'
      }
    },
    required: ['target_finder_window_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_pathbar_visible_of_finder_window',
  description: 'Get Is the window\'s path bar visible? of Finder window',
  inputSchema: {
    type: 'object',
    properties: {
      target_finder_window_required_string: {
        type: 'string',
        description: 'The Finder window object'
      }
    },
    required: ['target_finder_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_pathbar_visible_of_finder_window',
  description: 'Set Is the window\'s path bar visible? of Finder window',
  inputSchema: {
    type: 'object',
    properties: {
      target_finder_window_required_string: {
        type: 'string',
        description: 'The Finder window object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Is the window\'s path bar visible?'
      }
    },
    required: ['target_finder_window_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_sidebar_width_of_finder_window',
  description: 'Get the width of the sidebar for the container window of Finder window',
  inputSchema: {
    type: 'object',
    properties: {
      target_finder_window_required_string: {
        type: 'string',
        description: 'The Finder window object'
      }
    },
    required: ['target_finder_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_sidebar_width_of_finder_window',
  description: 'Set the width of the sidebar for the container window of Finder window',
  inputSchema: {
    type: 'object',
    properties: {
      target_finder_window_required_string: {
        type: 'string',
        description: 'The Finder window object'
      },
      value_required_integer: {
        type: 'number',
        description: 'New value for the width of the sidebar for the container window'
      }
    },
    required: ['target_finder_window_required_string', 'value_required_integer'],
    additionalProperties: false
  }
},
          {
  name: 'get_item_of_information_window',
  description: 'Get the item from which this window was opened of information window',
  inputSchema: {
    type: 'object',
    properties: {
      target_information_window_required_string: {
        type: 'string',
        description: 'The information window object'
      }
    },
    required: ['target_information_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_current_panel_of_information_window',
  description: 'Get the current panel in the information window',
  inputSchema: {
    type: 'object',
    properties: {
      target_information_window_required_string: {
        type: 'string',
        description: 'The information window object'
      }
    },
    required: ['target_information_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_current_panel_of_information_window',
  description: 'Set the current panel in the information window',
  inputSchema: {
    type: 'object',
    properties: {
      target_information_window_required_string: {
        type: 'string',
        description: 'The information window object'
      },
      value_required_ipnl: {
        type: 'string',
        description: 'New value for the current panel in the information window'
      }
    },
    required: ['target_information_window_required_string', 'value_required_ipnl'],
    additionalProperties: false
  }
},
          {
  name: 'get_current_panel_of_preferences_window',
  description: 'Get The current panel in the Finder preferences window',
  inputSchema: {
    type: 'object',
    properties: {
      target_preferences_window_required_string: {
        type: 'string',
        description: 'The preferences window object'
      }
    },
    required: ['target_preferences_window_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_current_panel_of_preferences_window',
  description: 'Set The current panel in the Finder preferences window',
  inputSchema: {
    type: 'object',
    properties: {
      target_preferences_window_required_string: {
        type: 'string',
        description: 'The preferences window object'
      },
      value_required_pple: {
        type: 'string',
        description: 'New value for The current panel in the Finder preferences window'
      }
    },
    required: ['target_preferences_window_required_string', 'value_required_pple'],
    additionalProperties: false
  }
},
          {
  name: 'restart',
  description: 'Restart the computer',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'shut_down',
  description: 'Shut Down the computer',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'sleep',
  description: 'Put the computer to sleep',
  inputSchema: {
    type: 'object',
    properties: {},
    additionalProperties: false
  }
},
          {
  name: 'get_desktop_picture_of_application',
  description: 'Get the desktop picture of the main monitor of application',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_required_string: {
        type: 'string',
        description: 'The application object'
      }
    },
    required: ['target_application_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_desktop_picture_of_application',
  description: 'Set the desktop picture of the main monitor of application',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_required_string: {
        type: 'string',
        description: 'The application object'
      },
      value_required_file: {
        type: 'string',
        description: 'New value for the desktop picture of the main monitor'
      }
    },
    required: ['target_application_required_string', 'value_required_file'],
    additionalProperties: false
  }
},
          {
  name: 'get_name_of_process',
  description: 'Get the name of the process',
  inputSchema: {
    type: 'object',
    properties: {
      target_process_required_string: {
        type: 'string',
        description: 'The process object'
      }
    },
    required: ['target_process_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_visible_of_process',
  description: 'Get Is the process\' layer visible?',
  inputSchema: {
    type: 'object',
    properties: {
      target_process_required_string: {
        type: 'string',
        description: 'The process object'
      }
    },
    required: ['target_process_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_visible_of_process',
  description: 'Set Is the process\' layer visible?',
  inputSchema: {
    type: 'object',
    properties: {
      target_process_required_string: {
        type: 'string',
        description: 'The process object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Is the process\' layer visible?'
      }
    },
    required: ['target_process_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_frontmost_of_process',
  description: 'Get Is the process the frontmost process?',
  inputSchema: {
    type: 'object',
    properties: {
      target_process_required_string: {
        type: 'string',
        description: 'The process object'
      }
    },
    required: ['target_process_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_frontmost_of_process',
  description: 'Set Is the process the frontmost process?',
  inputSchema: {
    type: 'object',
    properties: {
      target_process_required_string: {
        type: 'string',
        description: 'The process object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Is the process the frontmost process?'
      }
    },
    required: ['target_process_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_file_of_process',
  description: 'Get the file from which the process was launched',
  inputSchema: {
    type: 'object',
    properties: {
      target_process_required_string: {
        type: 'string',
        description: 'The process object'
      }
    },
    required: ['target_process_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_file_type_of_process',
  description: 'Get the OSType of the file type of the process',
  inputSchema: {
    type: 'object',
    properties: {
      target_process_required_string: {
        type: 'string',
        description: 'The process object'
      }
    },
    required: ['target_process_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_creator_type_of_process',
  description: 'Get the OSType of the creator of the process (the signature)',
  inputSchema: {
    type: 'object',
    properties: {
      target_process_required_string: {
        type: 'string',
        description: 'The process object'
      }
    },
    required: ['target_process_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_accepts_high_level_events_of_process',
  description: 'Get Is the process high-level event aware (accepts open application, open document, print document, and quit)?',
  inputSchema: {
    type: 'object',
    properties: {
      target_process_required_string: {
        type: 'string',
        description: 'The process object'
      }
    },
    required: ['target_process_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_accepts_remote_events_of_process',
  description: 'Get Does the process accept remote events?',
  inputSchema: {
    type: 'object',
    properties: {
      target_process_required_string: {
        type: 'string',
        description: 'The process object'
      }
    },
    required: ['target_process_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_has_scripting_terminology_of_process',
  description: 'Get Does the process have a scripting terminology, i.e., can it be scripted?',
  inputSchema: {
    type: 'object',
    properties: {
      target_process_required_string: {
        type: 'string',
        description: 'The process object'
      }
    },
    required: ['target_process_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_total_partition_size_of_process',
  description: 'Get the size of the partition with which the process was launched',
  inputSchema: {
    type: 'object',
    properties: {
      target_process_required_string: {
        type: 'string',
        description: 'The process object'
      }
    },
    required: ['target_process_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_partition_space_used_of_process',
  description: 'Get the number of bytes currently used in the process\' partition',
  inputSchema: {
    type: 'object',
    properties: {
      target_process_required_string: {
        type: 'string',
        description: 'The process object'
      }
    },
    required: ['target_process_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_application_file_of_application_process',
  description: 'Get the application file from which this process was launched of application process',
  inputSchema: {
    type: 'object',
    properties: {
      target_application_process_required_string: {
        type: 'string',
        description: 'The application process object'
      }
    },
    required: ['target_application_process_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_desk_accessory_file_of_desk_accessory_process',
  description: 'Get the desk accessory file from which this process was launched of desk accessory process',
  inputSchema: {
    type: 'object',
    properties: {
      target_desk_accessory_process_required_string: {
        type: 'string',
        description: 'The desk accessory process object'
      }
    },
    required: ['target_desk_accessory_process_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_window_of_preferences',
  description: 'Get the window that would open if Finder preferences was opened',
  inputSchema: {
    type: 'object',
    properties: {
      target_preferences_required_string: {
        type: 'string',
        description: 'The preferences object'
      }
    },
    required: ['target_preferences_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_icon_view_options_of_preferences',
  description: 'Get the default icon view options of preferences',
  inputSchema: {
    type: 'object',
    properties: {
      target_preferences_required_string: {
        type: 'string',
        description: 'The preferences object'
      }
    },
    required: ['target_preferences_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_list_view_options_of_preferences',
  description: 'Get the default list view options of preferences',
  inputSchema: {
    type: 'object',
    properties: {
      target_preferences_required_string: {
        type: 'string',
        description: 'The preferences object'
      }
    },
    required: ['target_preferences_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_column_view_options_of_preferences',
  description: 'Get the column view options for all windows of preferences',
  inputSchema: {
    type: 'object',
    properties: {
      target_preferences_required_string: {
        type: 'string',
        description: 'The preferences object'
      }
    },
    required: ['target_preferences_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_folders_spring_open_of_preferences',
  description: 'Get Spring open folders after the specified delay? of preferences',
  inputSchema: {
    type: 'object',
    properties: {
      target_preferences_required_string: {
        type: 'string',
        description: 'The preferences object'
      }
    },
    required: ['target_preferences_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_folders_spring_open_of_preferences',
  description: 'Set Spring open folders after the specified delay? of preferences',
  inputSchema: {
    type: 'object',
    properties: {
      target_preferences_required_string: {
        type: 'string',
        description: 'The preferences object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Spring open folders after the specified delay?'
      }
    },
    required: ['target_preferences_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_delay_before_springing_of_preferences',
  description: 'Get the delay before springing open a container in seconds (from 0.167 to 1.169) of preferences',
  inputSchema: {
    type: 'object',
    properties: {
      target_preferences_required_string: {
        type: 'string',
        description: 'The preferences object'
      }
    },
    required: ['target_preferences_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_delay_before_springing_of_preferences',
  description: 'Set the delay before springing open a container in seconds (from 0.167 to 1.169) of preferences',
  inputSchema: {
    type: 'object',
    properties: {
      target_preferences_required_string: {
        type: 'string',
        description: 'The preferences object'
      },
      value_required_real: {
        type: 'number',
        description: 'New value for the delay before springing open a container in seconds (from 0.167 to 1.169)'
      }
    },
    required: ['target_preferences_required_string', 'value_required_real'],
    additionalProperties: false
  }
},
          {
  name: 'get_desktop_shows_hard_disks_of_preferences',
  description: 'Get Hard disks appear on the desktop? of preferences',
  inputSchema: {
    type: 'object',
    properties: {
      target_preferences_required_string: {
        type: 'string',
        description: 'The preferences object'
      }
    },
    required: ['target_preferences_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_desktop_shows_hard_disks_of_preferences',
  description: 'Set Hard disks appear on the desktop? of preferences',
  inputSchema: {
    type: 'object',
    properties: {
      target_preferences_required_string: {
        type: 'string',
        description: 'The preferences object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Hard disks appear on the desktop?'
      }
    },
    required: ['target_preferences_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_desktop_shows_external_hard_disks_of_preferences',
  description: 'Get External hard disks appear on the desktop? of preferences',
  inputSchema: {
    type: 'object',
    properties: {
      target_preferences_required_string: {
        type: 'string',
        description: 'The preferences object'
      }
    },
    required: ['target_preferences_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_desktop_shows_external_hard_disks_of_preferences',
  description: 'Set External hard disks appear on the desktop? of preferences',
  inputSchema: {
    type: 'object',
    properties: {
      target_preferences_required_string: {
        type: 'string',
        description: 'The preferences object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for External hard disks appear on the desktop?'
      }
    },
    required: ['target_preferences_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_desktop_shows_removable_media_of_preferences',
  description: 'Get CDs, DVDs, and iPods appear on the desktop? of preferences',
  inputSchema: {
    type: 'object',
    properties: {
      target_preferences_required_string: {
        type: 'string',
        description: 'The preferences object'
      }
    },
    required: ['target_preferences_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_desktop_shows_removable_media_of_preferences',
  description: 'Set CDs, DVDs, and iPods appear on the desktop? of preferences',
  inputSchema: {
    type: 'object',
    properties: {
      target_preferences_required_string: {
        type: 'string',
        description: 'The preferences object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for CDs, DVDs, and iPods appear on the desktop?'
      }
    },
    required: ['target_preferences_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_desktop_shows_connected_servers_of_preferences',
  description: 'Get Connected servers appear on the desktop? of preferences',
  inputSchema: {
    type: 'object',
    properties: {
      target_preferences_required_string: {
        type: 'string',
        description: 'The preferences object'
      }
    },
    required: ['target_preferences_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_desktop_shows_connected_servers_of_preferences',
  description: 'Set Connected servers appear on the desktop? of preferences',
  inputSchema: {
    type: 'object',
    properties: {
      target_preferences_required_string: {
        type: 'string',
        description: 'The preferences object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Connected servers appear on the desktop?'
      }
    },
    required: ['target_preferences_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_new_window_target_of_preferences',
  description: 'Get target location for a newly-opened Finder window of preferences',
  inputSchema: {
    type: 'object',
    properties: {
      target_preferences_required_string: {
        type: 'string',
        description: 'The preferences object'
      }
    },
    required: ['target_preferences_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_new_window_target_of_preferences',
  description: 'Set target location for a newly-opened Finder window of preferences',
  inputSchema: {
    type: 'object',
    properties: {
      target_preferences_required_string: {
        type: 'string',
        description: 'The preferences object'
      },
      value_required_specifier: {
        type: 'string',
        description: 'New value for target location for a newly-opened Finder window'
      }
    },
    required: ['target_preferences_required_string', 'value_required_specifier'],
    additionalProperties: false
  }
},
          {
  name: 'get_folders_open_in_new_windows_of_preferences',
  description: 'Get Folders open into new windows? of preferences',
  inputSchema: {
    type: 'object',
    properties: {
      target_preferences_required_string: {
        type: 'string',
        description: 'The preferences object'
      }
    },
    required: ['target_preferences_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_folders_open_in_new_windows_of_preferences',
  description: 'Set Folders open into new windows? of preferences',
  inputSchema: {
    type: 'object',
    properties: {
      target_preferences_required_string: {
        type: 'string',
        description: 'The preferences object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Folders open into new windows?'
      }
    },
    required: ['target_preferences_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_folders_open_in_new_tabs_of_preferences',
  description: 'Get Folders open into new tabs? of preferences',
  inputSchema: {
    type: 'object',
    properties: {
      target_preferences_required_string: {
        type: 'string',
        description: 'The preferences object'
      }
    },
    required: ['target_preferences_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_folders_open_in_new_tabs_of_preferences',
  description: 'Set Folders open into new tabs? of preferences',
  inputSchema: {
    type: 'object',
    properties: {
      target_preferences_required_string: {
        type: 'string',
        description: 'The preferences object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Folders open into new tabs?'
      }
    },
    required: ['target_preferences_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_new_windows_open_in_column_view_of_preferences',
  description: 'Get Open new windows in column view? of preferences',
  inputSchema: {
    type: 'object',
    properties: {
      target_preferences_required_string: {
        type: 'string',
        description: 'The preferences object'
      }
    },
    required: ['target_preferences_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_new_windows_open_in_column_view_of_preferences',
  description: 'Set Open new windows in column view? of preferences',
  inputSchema: {
    type: 'object',
    properties: {
      target_preferences_required_string: {
        type: 'string',
        description: 'The preferences object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Open new windows in column view?'
      }
    },
    required: ['target_preferences_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_all_name_extensions_showing_of_preferences',
  description: 'Get Show name extensions, even for items whose “extension hidden” is true? of preferences',
  inputSchema: {
    type: 'object',
    properties: {
      target_preferences_required_string: {
        type: 'string',
        description: 'The preferences object'
      }
    },
    required: ['target_preferences_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_all_name_extensions_showing_of_preferences',
  description: 'Set Show name extensions, even for items whose “extension hidden” is true? of preferences',
  inputSchema: {
    type: 'object',
    properties: {
      target_preferences_required_string: {
        type: 'string',
        description: 'The preferences object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Show name extensions, even for items whose “extension hidden” is true?'
      }
    },
    required: ['target_preferences_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_name_of_label',
  description: 'Get the name associated with the label',
  inputSchema: {
    type: 'object',
    properties: {
      target_label_required_string: {
        type: 'string',
        description: 'The label object'
      }
    },
    required: ['target_label_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_name_of_label',
  description: 'Set the name associated with the label',
  inputSchema: {
    type: 'object',
    properties: {
      target_label_required_string: {
        type: 'string',
        description: 'The label object'
      },
      value_required_text: {
        type: 'string',
        description: 'New value for the name associated with the label'
      }
    },
    required: ['target_label_required_string', 'value_required_text'],
    additionalProperties: false
  }
},
          {
  name: 'get_index_of_label',
  description: 'Get the index in the front-to-back ordering within its container of label',
  inputSchema: {
    type: 'object',
    properties: {
      target_label_required_string: {
        type: 'string',
        description: 'The label object'
      }
    },
    required: ['target_label_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_index_of_label',
  description: 'Set the index in the front-to-back ordering within its container of label',
  inputSchema: {
    type: 'object',
    properties: {
      target_label_required_string: {
        type: 'string',
        description: 'The label object'
      },
      value_required_integer: {
        type: 'number',
        description: 'New value for the index in the front-to-back ordering within its container'
      }
    },
    required: ['target_label_required_string', 'value_required_integer'],
    additionalProperties: false
  }
},
          {
  name: 'get_color_of_label',
  description: 'Get the color associated with the label',
  inputSchema: {
    type: 'object',
    properties: {
      target_label_required_string: {
        type: 'string',
        description: 'The label object'
      }
    },
    required: ['target_label_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_color_of_label',
  description: 'Set the color associated with the label',
  inputSchema: {
    type: 'object',
    properties: {
      target_label_required_string: {
        type: 'string',
        description: 'The label object'
      },
      value_required_rgb_color: {
        type: 'string',
        description: 'New value for the color associated with the label'
      }
    },
    required: ['target_label_required_string', 'value_required_rgb_color'],
    additionalProperties: false
  }
},
          {
  name: 'get_large_monochrome_icon_and_mask_of_icon_family',
  description: 'Get the large black-and-white icon and the mask for large icons of icon family',
  inputSchema: {
    type: 'object',
    properties: {
      target_icon_family_required_string: {
        type: 'string',
        description: 'The icon family object'
      }
    },
    required: ['target_icon_family_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_large_8_bit_mask_of_icon_family',
  description: 'Get the large 8-bit mask for large 32-bit icons of icon family',
  inputSchema: {
    type: 'object',
    properties: {
      target_icon_family_required_string: {
        type: 'string',
        description: 'The icon family object'
      }
    },
    required: ['target_icon_family_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_large_32_bit_icon_of_icon_family',
  description: 'Get the large 32-bit color icon of icon family',
  inputSchema: {
    type: 'object',
    properties: {
      target_icon_family_required_string: {
        type: 'string',
        description: 'The icon family object'
      }
    },
    required: ['target_icon_family_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_large_8_bit_icon_of_icon_family',
  description: 'Get the large 8-bit color icon of icon family',
  inputSchema: {
    type: 'object',
    properties: {
      target_icon_family_required_string: {
        type: 'string',
        description: 'The icon family object'
      }
    },
    required: ['target_icon_family_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_large_4_bit_icon_of_icon_family',
  description: 'Get the large 4-bit color icon of icon family',
  inputSchema: {
    type: 'object',
    properties: {
      target_icon_family_required_string: {
        type: 'string',
        description: 'The icon family object'
      }
    },
    required: ['target_icon_family_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_small_monochrome_icon_and_mask_of_icon_family',
  description: 'Get the small black-and-white icon and the mask for small icons of icon family',
  inputSchema: {
    type: 'object',
    properties: {
      target_icon_family_required_string: {
        type: 'string',
        description: 'The icon family object'
      }
    },
    required: ['target_icon_family_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_small_8_bit_mask_of_icon_family',
  description: 'Get the small 8-bit mask for small 32-bit icons of icon family',
  inputSchema: {
    type: 'object',
    properties: {
      target_icon_family_required_string: {
        type: 'string',
        description: 'The icon family object'
      }
    },
    required: ['target_icon_family_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_small_32_bit_icon_of_icon_family',
  description: 'Get the small 32-bit color icon of icon family',
  inputSchema: {
    type: 'object',
    properties: {
      target_icon_family_required_string: {
        type: 'string',
        description: 'The icon family object'
      }
    },
    required: ['target_icon_family_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_small_8_bit_icon_of_icon_family',
  description: 'Get the small 8-bit color icon of icon family',
  inputSchema: {
    type: 'object',
    properties: {
      target_icon_family_required_string: {
        type: 'string',
        description: 'The icon family object'
      }
    },
    required: ['target_icon_family_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_small_4_bit_icon_of_icon_family',
  description: 'Get the small 4-bit color icon of icon family',
  inputSchema: {
    type: 'object',
    properties: {
      target_icon_family_required_string: {
        type: 'string',
        description: 'The icon family object'
      }
    },
    required: ['target_icon_family_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_arrangement_of_icon_view_options',
  description: 'Get the property by which to keep icons arranged of icon view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_icon_view_options_required_string: {
        type: 'string',
        description: 'The icon view options object'
      }
    },
    required: ['target_icon_view_options_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_arrangement_of_icon_view_options',
  description: 'Set the property by which to keep icons arranged of icon view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_icon_view_options_required_string: {
        type: 'string',
        description: 'The icon view options object'
      },
      value_required_earr: {
        type: 'string',
        description: 'New value for the property by which to keep icons arranged'
      }
    },
    required: ['target_icon_view_options_required_string', 'value_required_earr'],
    additionalProperties: false
  }
},
          {
  name: 'get_icon_size_of_icon_view_options',
  description: 'Get the size of icons displayed in the icon view of icon view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_icon_view_options_required_string: {
        type: 'string',
        description: 'The icon view options object'
      }
    },
    required: ['target_icon_view_options_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_icon_size_of_icon_view_options',
  description: 'Set the size of icons displayed in the icon view of icon view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_icon_view_options_required_string: {
        type: 'string',
        description: 'The icon view options object'
      },
      value_required_integer: {
        type: 'number',
        description: 'New value for the size of icons displayed in the icon view'
      }
    },
    required: ['target_icon_view_options_required_string', 'value_required_integer'],
    additionalProperties: false
  }
},
          {
  name: 'get_shows_item_info_of_icon_view_options',
  description: 'Get additional info about an item displayed in icon view of icon view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_icon_view_options_required_string: {
        type: 'string',
        description: 'The icon view options object'
      }
    },
    required: ['target_icon_view_options_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_shows_item_info_of_icon_view_options',
  description: 'Set additional info about an item displayed in icon view of icon view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_icon_view_options_required_string: {
        type: 'string',
        description: 'The icon view options object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for additional info about an item displayed in icon view'
      }
    },
    required: ['target_icon_view_options_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_shows_icon_preview_of_icon_view_options',
  description: 'Get displays a preview of the item in icon view of icon view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_icon_view_options_required_string: {
        type: 'string',
        description: 'The icon view options object'
      }
    },
    required: ['target_icon_view_options_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_shows_icon_preview_of_icon_view_options',
  description: 'Set displays a preview of the item in icon view of icon view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_icon_view_options_required_string: {
        type: 'string',
        description: 'The icon view options object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for displays a preview of the item in icon view'
      }
    },
    required: ['target_icon_view_options_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_text_size_of_icon_view_options',
  description: 'Get the size of the text displayed in the icon view of icon view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_icon_view_options_required_string: {
        type: 'string',
        description: 'The icon view options object'
      }
    },
    required: ['target_icon_view_options_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_text_size_of_icon_view_options',
  description: 'Set the size of the text displayed in the icon view of icon view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_icon_view_options_required_string: {
        type: 'string',
        description: 'The icon view options object'
      },
      value_required_integer: {
        type: 'number',
        description: 'New value for the size of the text displayed in the icon view'
      }
    },
    required: ['target_icon_view_options_required_string', 'value_required_integer'],
    additionalProperties: false
  }
},
          {
  name: 'get_label_position_of_icon_view_options',
  description: 'Get the location of the label in reference to the icon of icon view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_icon_view_options_required_string: {
        type: 'string',
        description: 'The icon view options object'
      }
    },
    required: ['target_icon_view_options_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_label_position_of_icon_view_options',
  description: 'Set the location of the label in reference to the icon of icon view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_icon_view_options_required_string: {
        type: 'string',
        description: 'The icon view options object'
      },
      value_required_epos: {
        type: 'string',
        description: 'New value for the location of the label in reference to the icon'
      }
    },
    required: ['target_icon_view_options_required_string', 'value_required_epos'],
    additionalProperties: false
  }
},
          {
  name: 'get_background_picture_of_icon_view_options',
  description: 'Get the background picture of the icon view of icon view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_icon_view_options_required_string: {
        type: 'string',
        description: 'The icon view options object'
      }
    },
    required: ['target_icon_view_options_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_background_picture_of_icon_view_options',
  description: 'Set the background picture of the icon view of icon view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_icon_view_options_required_string: {
        type: 'string',
        description: 'The icon view options object'
      },
      value_required_file: {
        type: 'string',
        description: 'New value for the background picture of the icon view'
      }
    },
    required: ['target_icon_view_options_required_string', 'value_required_file'],
    additionalProperties: false
  }
},
          {
  name: 'get_background_color_of_icon_view_options',
  description: 'Get the background color of the icon view of icon view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_icon_view_options_required_string: {
        type: 'string',
        description: 'The icon view options object'
      }
    },
    required: ['target_icon_view_options_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_background_color_of_icon_view_options',
  description: 'Set the background color of the icon view of icon view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_icon_view_options_required_string: {
        type: 'string',
        description: 'The icon view options object'
      },
      value_required_rgb_color: {
        type: 'string',
        description: 'New value for the background color of the icon view'
      }
    },
    required: ['target_icon_view_options_required_string', 'value_required_rgb_color'],
    additionalProperties: false
  }
},
          {
  name: 'get_text_size_of_column_view_options',
  description: 'Get the size of the text displayed in the column view of column view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_column_view_options_required_string: {
        type: 'string',
        description: 'The column view options object'
      }
    },
    required: ['target_column_view_options_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_text_size_of_column_view_options',
  description: 'Set the size of the text displayed in the column view of column view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_column_view_options_required_string: {
        type: 'string',
        description: 'The column view options object'
      },
      value_required_integer: {
        type: 'number',
        description: 'New value for the size of the text displayed in the column view'
      }
    },
    required: ['target_column_view_options_required_string', 'value_required_integer'],
    additionalProperties: false
  }
},
          {
  name: 'get_shows_icon_of_column_view_options',
  description: 'Get displays an icon next to the label in column view of column view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_column_view_options_required_string: {
        type: 'string',
        description: 'The column view options object'
      }
    },
    required: ['target_column_view_options_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_shows_icon_of_column_view_options',
  description: 'Set displays an icon next to the label in column view of column view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_column_view_options_required_string: {
        type: 'string',
        description: 'The column view options object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for displays an icon next to the label in column view'
      }
    },
    required: ['target_column_view_options_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_shows_icon_preview_of_column_view_options',
  description: 'Get displays a preview of the item in column view of column view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_column_view_options_required_string: {
        type: 'string',
        description: 'The column view options object'
      }
    },
    required: ['target_column_view_options_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_shows_icon_preview_of_column_view_options',
  description: 'Set displays a preview of the item in column view of column view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_column_view_options_required_string: {
        type: 'string',
        description: 'The column view options object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for displays a preview of the item in column view'
      }
    },
    required: ['target_column_view_options_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_shows_preview_column_of_column_view_options',
  description: 'Get displays the preview column in column view of column view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_column_view_options_required_string: {
        type: 'string',
        description: 'The column view options object'
      }
    },
    required: ['target_column_view_options_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_shows_preview_column_of_column_view_options',
  description: 'Set displays the preview column in column view of column view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_column_view_options_required_string: {
        type: 'string',
        description: 'The column view options object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for displays the preview column in column view'
      }
    },
    required: ['target_column_view_options_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_discloses_preview_pane_of_column_view_options',
  description: 'Get discloses the preview pane of the preview column in column view of column view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_column_view_options_required_string: {
        type: 'string',
        description: 'The column view options object'
      }
    },
    required: ['target_column_view_options_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_discloses_preview_pane_of_column_view_options',
  description: 'Set discloses the preview pane of the preview column in column view of column view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_column_view_options_required_string: {
        type: 'string',
        description: 'The column view options object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for discloses the preview pane of the preview column in column view'
      }
    },
    required: ['target_column_view_options_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_calculates_folder_sizes_of_list_view_options',
  description: 'Get Are folder sizes calculated and displayed in the window? of list view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_list_view_options_required_string: {
        type: 'string',
        description: 'The list view options object'
      }
    },
    required: ['target_list_view_options_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_calculates_folder_sizes_of_list_view_options',
  description: 'Set Are folder sizes calculated and displayed in the window? of list view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_list_view_options_required_string: {
        type: 'string',
        description: 'The list view options object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Are folder sizes calculated and displayed in the window?'
      }
    },
    required: ['target_list_view_options_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_shows_icon_preview_of_list_view_options',
  description: 'Get displays a preview of the item in list view of list view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_list_view_options_required_string: {
        type: 'string',
        description: 'The list view options object'
      }
    },
    required: ['target_list_view_options_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_shows_icon_preview_of_list_view_options',
  description: 'Set displays a preview of the item in list view of list view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_list_view_options_required_string: {
        type: 'string',
        description: 'The list view options object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for displays a preview of the item in list view'
      }
    },
    required: ['target_list_view_options_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_icon_size_of_list_view_options',
  description: 'Get the size of icons displayed in the list view of list view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_list_view_options_required_string: {
        type: 'string',
        description: 'The list view options object'
      }
    },
    required: ['target_list_view_options_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_icon_size_of_list_view_options',
  description: 'Set the size of icons displayed in the list view of list view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_list_view_options_required_string: {
        type: 'string',
        description: 'The list view options object'
      },
      value_required_lvic: {
        type: 'string',
        description: 'New value for the size of icons displayed in the list view'
      }
    },
    required: ['target_list_view_options_required_string', 'value_required_lvic'],
    additionalProperties: false
  }
},
          {
  name: 'get_text_size_of_list_view_options',
  description: 'Get the size of the text displayed in the list view of list view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_list_view_options_required_string: {
        type: 'string',
        description: 'The list view options object'
      }
    },
    required: ['target_list_view_options_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_text_size_of_list_view_options',
  description: 'Set the size of the text displayed in the list view of list view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_list_view_options_required_string: {
        type: 'string',
        description: 'The list view options object'
      },
      value_required_integer: {
        type: 'number',
        description: 'New value for the size of the text displayed in the list view'
      }
    },
    required: ['target_list_view_options_required_string', 'value_required_integer'],
    additionalProperties: false
  }
},
          {
  name: 'get_sort_column_of_list_view_options',
  description: 'Get the column that the list view is sorted on of list view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_list_view_options_required_string: {
        type: 'string',
        description: 'The list view options object'
      }
    },
    required: ['target_list_view_options_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_sort_column_of_list_view_options',
  description: 'Set the column that the list view is sorted on of list view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_list_view_options_required_string: {
        type: 'string',
        description: 'The list view options object'
      },
      value_required_column: {
        type: 'string',
        description: 'New value for the column that the list view is sorted on'
      }
    },
    required: ['target_list_view_options_required_string', 'value_required_column'],
    additionalProperties: false
  }
},
          {
  name: 'get_uses_relative_dates_of_list_view_options',
  description: 'Get Are relative dates (e.g., today, yesterday) shown in the list view? of list view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_list_view_options_required_string: {
        type: 'string',
        description: 'The list view options object'
      }
    },
    required: ['target_list_view_options_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_uses_relative_dates_of_list_view_options',
  description: 'Set Are relative dates (e.g., today, yesterday) shown in the list view? of list view options',
  inputSchema: {
    type: 'object',
    properties: {
      target_list_view_options_required_string: {
        type: 'string',
        description: 'The list view options object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for Are relative dates (e.g., today, yesterday) shown in the list view?'
      }
    },
    required: ['target_list_view_options_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
          {
  name: 'get_index_of_column',
  description: 'Get the index in the front-to-back ordering within its container of column',
  inputSchema: {
    type: 'object',
    properties: {
      target_column_required_string: {
        type: 'string',
        description: 'The column object'
      }
    },
    required: ['target_column_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_index_of_column',
  description: 'Set the index in the front-to-back ordering within its container of column',
  inputSchema: {
    type: 'object',
    properties: {
      target_column_required_string: {
        type: 'string',
        description: 'The column object'
      },
      value_required_integer: {
        type: 'number',
        description: 'New value for the index in the front-to-back ordering within its container'
      }
    },
    required: ['target_column_required_string', 'value_required_integer'],
    additionalProperties: false
  }
},
          {
  name: 'get_name_of_column',
  description: 'Get the column name',
  inputSchema: {
    type: 'object',
    properties: {
      target_column_required_string: {
        type: 'string',
        description: 'The column object'
      }
    },
    required: ['target_column_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_sort_direction_of_column',
  description: 'Get The direction in which the window is sorted of column',
  inputSchema: {
    type: 'object',
    properties: {
      target_column_required_string: {
        type: 'string',
        description: 'The column object'
      }
    },
    required: ['target_column_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_sort_direction_of_column',
  description: 'Set The direction in which the window is sorted of column',
  inputSchema: {
    type: 'object',
    properties: {
      target_column_required_string: {
        type: 'string',
        description: 'The column object'
      },
      value_required_sodr: {
        type: 'string',
        description: 'New value for The direction in which the window is sorted'
      }
    },
    required: ['target_column_required_string', 'value_required_sodr'],
    additionalProperties: false
  }
},
          {
  name: 'get_width_of_column',
  description: 'Get the width of this column',
  inputSchema: {
    type: 'object',
    properties: {
      target_column_required_string: {
        type: 'string',
        description: 'The column object'
      }
    },
    required: ['target_column_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_width_of_column',
  description: 'Set the width of this column',
  inputSchema: {
    type: 'object',
    properties: {
      target_column_required_string: {
        type: 'string',
        description: 'The column object'
      },
      value_required_integer: {
        type: 'number',
        description: 'New value for the width of this column'
      }
    },
    required: ['target_column_required_string', 'value_required_integer'],
    additionalProperties: false
  }
},
          {
  name: 'get_minimum_width_of_column',
  description: 'Get the minimum allowed width of this column',
  inputSchema: {
    type: 'object',
    properties: {
      target_column_required_string: {
        type: 'string',
        description: 'The column object'
      }
    },
    required: ['target_column_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_maximum_width_of_column',
  description: 'Get the maximum allowed width of this column',
  inputSchema: {
    type: 'object',
    properties: {
      target_column_required_string: {
        type: 'string',
        description: 'The column object'
      }
    },
    required: ['target_column_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'get_visible_of_column',
  description: 'Get is this column visible',
  inputSchema: {
    type: 'object',
    properties: {
      target_column_required_string: {
        type: 'string',
        description: 'The column object'
      }
    },
    required: ['target_column_required_string'],
    additionalProperties: false
  }
},
          {
  name: 'set_visible_of_column',
  description: 'Set is this column visible',
  inputSchema: {
    type: 'object',
    properties: {
      target_column_required_string: {
        type: 'string',
        description: 'The column object'
      },
      value_required_boolean: {
        type: 'boolean',
        description: 'New value for is this column visible'
      }
    },
    required: ['target_column_required_string', 'value_required_boolean'],
    additionalProperties: false
  }
},
        ]
      }
    };
    this.sendResponse(response);
  }

  async handleToolsCall(request) {
    console.error("Handling tools/call request for:", request.params.name);
    
    try {
      // Check app availability for all functions
      {
        const isFinderAvailable = await checkFinderAvailable();
        if (!isFinderAvailable) {
          const errorResponse = {
            jsonrpc: '2.0',
            id: request.id,
            result: {
              content: [{
                type: 'text',
                text: JSON.stringify({
                  success: false,
                  error: 'Application is not available or not running'
                }, null, 2)
              }]
            }
          };
          this.sendResponse(errorResponse);
          return;
        }
      }

      const { name, arguments: args } = request.params;
      let result;

      switch (name) {
        case 'save_for_window':
  result = await this.saveForWindow(args.target_window_required_string, args.inParam_optional_file, args.as_optional_saveable_file_format);
  break;
        case 'save_for_document':
  result = await this.saveForDocument(args.target_document_required_string, args.inParam_optional_file, args.as_optional_saveable_file_format);
  break;
        case 'get_name_of_application':
  result = await this.getNameOfApplication(args.target_application_required_string);
  break;
        case 'get_frontmost_of_application':
  result = await this.getFrontmostOfApplication(args.target_application_required_string);
  break;
        case 'get_version_of_application':
  result = await this.getVersionOfApplication(args.target_application_required_string);
  break;
        case 'get_name_of_document':
  result = await this.getNameOfDocument(args.target_document_required_string);
  break;
        case 'get_modified_of_document':
  result = await this.getModifiedOfDocument(args.target_document_required_string);
  break;
        case 'get_file_of_document':
  result = await this.getFileOfDocument(args.target_document_required_string);
  break;
        case 'get_name_of_window':
  result = await this.getNameOfWindow(args.target_window_required_string);
  break;
        case 'get_id_of_window':
  result = await this.getIdOfWindow(args.target_window_required_string);
  break;
        case 'get_index_of_window':
  result = await this.getIndexOfWindow(args.target_window_required_string);
  break;
        case 'set_index_of_window':
  result = await this.setIndexOfWindow(args.target_window_required_string, args.value_required_integer);
  break;
        case 'get_bounds_of_window':
  result = await this.getBoundsOfWindow(args.target_window_required_string);
  break;
        case 'set_bounds_of_window':
  result = await this.setBoundsOfWindow(args.target_window_required_string, args.value_required_rectangle);
  break;
        case 'get_closeable_of_window':
  result = await this.getCloseableOfWindow(args.target_window_required_string);
  break;
        case 'get_miniaturizable_of_window':
  result = await this.getMiniaturizableOfWindow(args.target_window_required_string);
  break;
        case 'get_miniaturized_of_window':
  result = await this.getMiniaturizedOfWindow(args.target_window_required_string);
  break;
        case 'set_miniaturized_of_window':
  result = await this.setMiniaturizedOfWindow(args.target_window_required_string, args.value_required_boolean);
  break;
        case 'get_resizable_of_window':
  result = await this.getResizableOfWindow(args.target_window_required_string);
  break;
        case 'get_visible_of_window':
  result = await this.getVisibleOfWindow(args.target_window_required_string);
  break;
        case 'set_visible_of_window':
  result = await this.setVisibleOfWindow(args.target_window_required_string, args.value_required_boolean);
  break;
        case 'get_zoomable_of_window':
  result = await this.getZoomableOfWindow(args.target_window_required_string);
  break;
        case 'get_zoomed_of_window':
  result = await this.getZoomedOfWindow(args.target_window_required_string);
  break;
        case 'set_zoomed_of_window':
  result = await this.setZoomedOfWindow(args.target_window_required_string, args.value_required_boolean);
  break;
        case 'get_document_of_window':
  result = await this.getDocumentOfWindow(args.target_window_required_string);
  break;
        case 'open':
  result = await this.open(args.direct_parameter_required_specifier, args.using_optional_specifier, args.with_properties_optional_record);
  break;
        case 'print_for_window':
  result = await this.printForWindow(args.target_window_required_string, args.with_properties_optional_record);
  break;
        case 'print_for_document':
  result = await this.printForDocument(args.target_document_required_string, args.with_properties_optional_record);
  break;
        case 'quit':
  result = await this.quit();
  break;
        case 'activate':
  result = await this.activate(args.direct_parameter_optional_specifier);
  break;
        case 'close_for_window':
  result = await this.closeForWindow(args.target_window_required_string);
  break;
        case 'close_for_document':
  result = await this.closeForDocument(args.target_document_required_string);
  break;
        case 'count_file_of_container':
  result = await this.countFileOfContainer(args.target_container_required_string);
  break;
        case 'count_desk_accessory_process':
  result = await this.countDeskAccessoryProcess();
  break;
        case 'count_list_view_options':
  result = await this.countListViewOptions();
  break;
        case 'count_internet_location_file_of_container':
  result = await this.countInternetLocationFileOfContainer(args.target_container_required_string);
  break;
        case 'count_window':
  result = await this.countWindow();
  break;
        case 'count_desktop_object':
  result = await this.countDesktopObject();
  break;
        case 'count_preferences':
  result = await this.countPreferences();
  break;
        case 'count_label':
  result = await this.countLabel();
  break;
        case 'count_folder_of_container':
  result = await this.countFolderOfContainer(args.target_container_required_string);
  break;
        case 'count_process':
  result = await this.countProcess();
  break;
        case 'count_icon_view_options':
  result = await this.countIconViewOptions();
  break;
        case 'count_container_of_container':
  result = await this.countContainerOfContainer(args.target_container_required_string);
  break;
        case 'count_finder_window':
  result = await this.countFinderWindow();
  break;
        case 'count_column_view_options':
  result = await this.countColumnViewOptions();
  break;
        case 'count_column_of_list_view_options':
  result = await this.countColumnOfListViewOptions(args.target_list_view_options_required_string);
  break;
        case 'count_preferences_window':
  result = await this.countPreferencesWindow();
  break;
        case 'count_computer_object':
  result = await this.countComputerObject();
  break;
        case 'count_alias_file_of_container':
  result = await this.countAliasFileOfContainer(args.target_container_required_string);
  break;
        case 'count_application_file_of_container':
  result = await this.countApplicationFileOfContainer(args.target_container_required_string);
  break;
        case 'count_information_window':
  result = await this.countInformationWindow();
  break;
        case 'count_item_of_container':
  result = await this.countItemOfContainer(args.target_container_required_string);
  break;
        case 'count_application_process':
  result = await this.countApplicationProcess();
  break;
        case 'count_clipping_of_container':
  result = await this.countClippingOfContainer(args.target_container_required_string);
  break;
        case 'count_document_file_of_container':
  result = await this.countDocumentFileOfContainer(args.target_container_required_string);
  break;
        case 'count_alias_list':
  result = await this.countAliasList();
  break;
        case 'count_desktop_window':
  result = await this.countDesktopWindow();
  break;
        case 'count_icon_family':
  result = await this.countIconFamily();
  break;
        case 'count_package_of_container':
  result = await this.countPackageOfContainer(args.target_container_required_string);
  break;
        case 'count_clipping_window':
  result = await this.countClippingWindow();
  break;
        case 'count_document':
  result = await this.countDocument();
  break;
        case 'count_trash_object':
  result = await this.countTrashObject();
  break;
        case 'count_disk_of_desktop_object':
  result = await this.countDiskOfDesktopObject(args.target_desktop_object_required_string);
  break;
        case 'data_size_file_of_container':
  result = await this.dataSizeFileOfContainer(args.target_container_required_string);
  break;
        case 'data_size_desk_accessory_process':
  result = await this.dataSizeDeskAccessoryProcess();
  break;
        case 'data_size_list_view_options':
  result = await this.dataSizeListViewOptions();
  break;
        case 'data_size_internet_location_file_of_container':
  result = await this.dataSizeInternetLocationFileOfContainer(args.target_container_required_string);
  break;
        case 'data_size_window':
  result = await this.dataSizeWindow();
  break;
        case 'data_size_desktop_object':
  result = await this.dataSizeDesktopObject();
  break;
        case 'data_size_preferences':
  result = await this.dataSizePreferences();
  break;
        case 'data_size_label':
  result = await this.dataSizeLabel();
  break;
        case 'data_size_folder_of_container':
  result = await this.dataSizeFolderOfContainer(args.target_container_required_string);
  break;
        case 'data_size_process':
  result = await this.dataSizeProcess();
  break;
        case 'data_size_icon_view_options':
  result = await this.dataSizeIconViewOptions();
  break;
        case 'data_size_container_of_container':
  result = await this.dataSizeContainerOfContainer(args.target_container_required_string);
  break;
        case 'data_size_finder_window':
  result = await this.dataSizeFinderWindow();
  break;
        case 'data_size_column_view_options':
  result = await this.dataSizeColumnViewOptions();
  break;
        case 'data_size_column_of_list_view_options':
  result = await this.dataSizeColumnOfListViewOptions(args.target_list_view_options_required_string);
  break;
        case 'data_size_preferences_window':
  result = await this.dataSizePreferencesWindow();
  break;
        case 'data_size_computer_object':
  result = await this.dataSizeComputerObject();
  break;
        case 'data_size_alias_file_of_container':
  result = await this.dataSizeAliasFileOfContainer(args.target_container_required_string);
  break;
        case 'data_size_application_file_of_container':
  result = await this.dataSizeApplicationFileOfContainer(args.target_container_required_string);
  break;
        case 'data_size_information_window':
  result = await this.dataSizeInformationWindow();
  break;
        case 'data_size_item_of_container':
  result = await this.dataSizeItemOfContainer(args.target_container_required_string);
  break;
        case 'data_size_application_process':
  result = await this.dataSizeApplicationProcess();
  break;
        case 'data_size_clipping_of_container':
  result = await this.dataSizeClippingOfContainer(args.target_container_required_string);
  break;
        case 'data_size_document_file_of_container':
  result = await this.dataSizeDocumentFileOfContainer(args.target_container_required_string);
  break;
        case 'data_size_alias_list':
  result = await this.dataSizeAliasList();
  break;
        case 'data_size_desktop_window':
  result = await this.dataSizeDesktopWindow();
  break;
        case 'data_size_icon_family':
  result = await this.dataSizeIconFamily();
  break;
        case 'data_size_package_of_container':
  result = await this.dataSizePackageOfContainer(args.target_container_required_string);
  break;
        case 'data_size_clipping_window':
  result = await this.dataSizeClippingWindow();
  break;
        case 'data_size_document':
  result = await this.dataSizeDocument();
  break;
        case 'data_size_trash_object':
  result = await this.dataSizeTrashObject();
  break;
        case 'data_size_disk_of_desktop_object':
  result = await this.dataSizeDiskOfDesktopObject(args.target_desktop_object_required_string);
  break;
        case 'delete':
  result = await this.delete(args.direct_parameter_required_specifier);
  break;
        case 'duplicate':
  result = await this.duplicate(args.direct_parameter_required_specifier, args.to_optional_location_specifier, args.replacing_optional_boolean, args.routing_suppressed_optional_boolean, args.exact_copy_optional_boolean);
  break;
        case 'exists':
  result = await this.exists(args.direct_parameter_required_specifier);
  break;
        case 'make_file_of_container':
  result = await this.makeFileOfContainer(args.at_required_location_specifier_container, args.to_optional_specifier, args.with_properties_optional_boolean_stationery);
  break;
        case 'make_desk_accessory_process':
  result = await this.makeDeskAccessoryProcess(args.at_required_location_specifier, args.to_optional_specifier);
  break;
        case 'make_list_view_options':
  result = await this.makeListViewOptions(args.at_required_location_specifier, args.to_optional_specifier, args.with_properties_optional_boolean_uses_relative_dates, args.with_properties_optional_lvic_icon_size, args.with_properties_optional_integer_text_size, args.with_properties_optional_boolean_calculates_folder_sizes, args.with_properties_optional_boolean_shows_icon_preview, args.with_properties_optional_column_sort_column);
  break;
        case 'make_internet_location_file_of_container':
  result = await this.makeInternetLocationFileOfContainer(args.at_required_location_specifier_container, args.to_optional_specifier);
  break;
        case 'make_window':
  result = await this.makeWindow(args.at_required_location_specifier, args.to_optional_specifier, args.with_properties_optional_integer_index, args.with_properties_optional_point_position, args.with_properties_optional_boolean_zoomed, args.with_properties_optional_boolean_collapsed, args.with_properties_optional_boolean_miniaturized, args.with_properties_optional_record_properties, args.with_properties_optional_rectangle_bounds);
  break;
        case 'make_desktop_object':
  result = await this.makeDesktopObject(args.at_required_location_specifier, args.to_optional_specifier);
  break;
        case 'make_preferences':
  result = await this.makePreferences(args.at_required_location_specifier, args.to_optional_specifier, args.with_properties_optional_real_delay_before_springing, args.with_properties_optional_boolean_new_windows_open_in_column_view, args.with_properties_optional_boolean_desktop_shows_removable_media, args.with_properties_optional_boolean_folders_spring_open, args.with_properties_optional_boolean_all_name_extensions_showing, args.with_properties_optional_boolean_desktop_shows_external_hard_disks, args.with_properties_optional_boolean_folders_open_in_new_tabs, args.with_properties_optional_boolean_desktop_shows_hard_disks, args.with_properties_optional_specifier_new_window_target, args.with_properties_optional_boolean_folders_open_in_new_windows, args.with_properties_optional_boolean_desktop_shows_connected_servers);
  break;
        case 'make_label':
  result = await this.makeLabel(args.at_required_location_specifier, args.to_optional_specifier, args.with_properties_optional_text_name, args.with_properties_optional_integer_index, args.with_properties_optional_rgb_color_color);
  break;
        case 'make_folder_of_container':
  result = await this.makeFolderOfContainer(args.at_required_location_specifier_container, args.to_optional_specifier);
  break;
        case 'make_process':
  result = await this.makeProcess(args.at_required_location_specifier, args.to_optional_specifier, args.with_properties_optional_boolean_visible, args.with_properties_optional_boolean_frontmost);
  break;
        case 'make_icon_view_options':
  result = await this.makeIconViewOptions(args.at_required_location_specifier, args.to_optional_specifier, args.with_properties_optional_boolean_shows_icon_preview, args.with_properties_optional_boolean_shows_item_info, args.with_properties_optional_file_background_picture, args.with_properties_optional_epos_label_position, args.with_properties_optional_earr_arrangement, args.with_properties_optional_rgb_color_background_color, args.with_properties_optional_integer_text_size, args.with_properties_optional_integer_icon_size);
  break;
        case 'make_container_of_container':
  result = await this.makeContainerOfContainer(args.at_required_location_specifier_container, args.to_optional_specifier, args.with_properties_optional_boolean_expanded, args.with_properties_optional_boolean_completely_expanded);
  break;
        case 'make_finder_window':
  result = await this.makeFinderWindow(args.at_required_location_specifier, args.to_optional_specifier, args.with_properties_optional_specifier_target, args.with_properties_optional_boolean_toolbar_visible, args.with_properties_optional_boolean_pathbar_visible, args.with_properties_optional_integer_sidebar_width, args.with_properties_optional_ecvw_current_view, args.with_properties_optional_boolean_statusbar_visible);
  break;
        case 'make_column_view_options':
  result = await this.makeColumnViewOptions(args.at_required_location_specifier, args.to_optional_specifier, args.with_properties_optional_boolean_shows_icon, args.with_properties_optional_integer_text_size, args.with_properties_optional_boolean_shows_preview_column, args.with_properties_optional_boolean_shows_icon_preview, args.with_properties_optional_boolean_discloses_preview_pane);
  break;
        case 'make_column_of_list_view_options':
  result = await this.makeColumnOfListViewOptions(args.at_required_location_specifier_list_view_options, args.to_optional_specifier, args.with_properties_optional_sodr_sort_direction, args.with_properties_optional_boolean_visible, args.with_properties_optional_integer_width, args.with_properties_optional_integer_index);
  break;
        case 'make_preferences_window':
  result = await this.makePreferencesWindow(args.at_required_location_specifier, args.to_optional_specifier, args.with_properties_optional_pple_current_panel);
  break;
        case 'make_computer_object':
  result = await this.makeComputerObject(args.at_required_location_specifier, args.to_optional_specifier);
  break;
        case 'make_alias_file_of_container':
  result = await this.makeAliasFileOfContainer(args.at_required_location_specifier_container, args.to_optional_specifier, args.with_properties_optional_specifier_original_item);
  break;
        case 'make_application_file_of_container':
  result = await this.makeApplicationFileOfContainer(args.at_required_location_specifier_container, args.to_optional_specifier, args.with_properties_optional_integer_preferred_size, args.with_properties_optional_boolean_opens_in_classic, args.with_properties_optional_integer_minimum_size);
  break;
        case 'make_information_window':
  result = await this.makeInformationWindow(args.at_required_location_specifier, args.to_optional_specifier, args.with_properties_optional_ipnl_current_panel);
  break;
        case 'make_item_of_container':
  result = await this.makeItemOfContainer(args.at_required_location_specifier_container, args.to_optional_specifier, args.with_properties_optional_boolean_locked, args.with_properties_optional_point_position, args.with_properties_optional_priv_everyones_privileges, args.with_properties_optional_icon_family_icon, args.with_properties_optional_point_desktop_position, args.with_properties_optional_text_owner, args.with_properties_optional_priv_owner_privileges, args.with_properties_optional_text_name_extension, args.with_properties_optional_text_name, args.with_properties_optional_text_group, args.with_properties_optional_integer_label_index, args.with_properties_optional_rectangle_bounds, args.with_properties_optional_priv_group_privileges, args.with_properties_optional_boolean_extension_hidden, args.with_properties_optional_date_modification_date, args.with_properties_optional_record_properties, args.with_properties_optional_text_comment);
  break;
        case 'make_application_process':
  result = await this.makeApplicationProcess(args.at_required_location_specifier, args.to_optional_specifier);
  break;
        case 'make_clipping_of_container':
  result = await this.makeClippingOfContainer(args.at_required_location_specifier_container, args.to_optional_specifier);
  break;
        case 'make_document_file_of_container':
  result = await this.makeDocumentFileOfContainer(args.at_required_location_specifier_container, args.to_optional_specifier);
  break;
        case 'make_alias_list':
  result = await this.makeAliasList(args.at_required_location_specifier, args.to_optional_specifier);
  break;
        case 'make_desktop_window':
  result = await this.makeDesktopWindow(args.at_required_location_specifier, args.to_optional_specifier);
  break;
        case 'make_icon_family':
  result = await this.makeIconFamily(args.at_required_location_specifier, args.to_optional_specifier);
  break;
        case 'make_package_of_container':
  result = await this.makePackageOfContainer(args.at_required_location_specifier_container, args.to_optional_specifier);
  break;
        case 'make_clipping_window':
  result = await this.makeClippingWindow(args.at_required_location_specifier, args.to_optional_specifier);
  break;
        case 'make_document':
  result = await this.makeDocument(args.at_required_location_specifier, args.to_optional_specifier);
  break;
        case 'make_trash_object':
  result = await this.makeTrashObject(args.at_required_location_specifier, args.to_optional_specifier, args.with_properties_optional_boolean_warns_before_emptying);
  break;
        case 'make_disk_of_desktop_object':
  result = await this.makeDiskOfDesktopObject(args.at_required_location_specifier_desktop_object, args.to_optional_specifier, args.with_properties_optional_boolean_ignore_privileges);
  break;
        case 'move':
  result = await this.move(args.direct_parameter_required_specifier, args.to_required_location_specifier, args.replacing_optional_boolean, args.positioned_at_optional_list, args.routing_suppressed_optional_boolean);
  break;
        case 'select':
  result = await this.select(args.direct_parameter_required_specifier);
  break;
        case 'openvirtuallocation':
  result = await this.openvirtuallocation(args.direct_parameter_required_text);
  break;
        case 'copy':
  result = await this.copy();
  break;
        case 'sort':
  result = await this.sort(args.direct_parameter_required_specifier, args.by_required_property);
  break;
        case 'get_clipboard_of_application':
  result = await this.getClipboardOfApplication(args.target_application_required_string);
  break;
        case 'get_visible_of_application':
  result = await this.getVisibleOfApplication(args.target_application_required_string);
  break;
        case 'set_visible_of_application':
  result = await this.setVisibleOfApplication(args.target_application_required_string, args.value_required_boolean);
  break;
        case 'get_selection_of_application':
  result = await this.getSelectionOfApplication(args.target_application_required_string);
  break;
        case 'set_selection_of_application':
  result = await this.setSelectionOfApplication(args.target_application_required_string, args.value_required_specifier);
  break;
        case 'get_insertion_location_of_application':
  result = await this.getInsertionLocationOfApplication(args.target_application_required_string);
  break;
        case 'get_product_version_of_application':
  result = await this.getProductVersionOfApplication(args.target_application_required_string);
  break;
        case 'get_startup_disk_of_application':
  result = await this.getStartupDiskOfApplication(args.target_application_required_string);
  break;
        case 'get_desktop_of_application':
  result = await this.getDesktopOfApplication(args.target_application_required_string);
  break;
        case 'get_trash_of_application':
  result = await this.getTrashOfApplication(args.target_application_required_string);
  break;
        case 'get_home_of_application':
  result = await this.getHomeOfApplication(args.target_application_required_string);
  break;
        case 'get_computer_container_of_application':
  result = await this.getComputerContainerOfApplication(args.target_application_required_string);
  break;
        case 'get_finder_preferences_of_application':
  result = await this.getFinderPreferencesOfApplication(args.target_application_required_string);
  break;
        case 'clean_up':
  result = await this.cleanUp(args.direct_parameter_required_specifier, args.by_optional_property);
  break;
        case 'eject':
  result = await this.eject(args.direct_parameter_optional_specifier);
  break;
        case 'empty':
  result = await this.empty(args.direct_parameter_optional_specifier, args.security_optional_boolean);
  break;
        case 'erase':
  result = await this.erase(args.direct_parameter_required_specifier);
  break;
        case 'reveal':
  result = await this.reveal(args.direct_parameter_required_specifier);
  break;
        case 'update':
  result = await this.update(args.direct_parameter_required_specifier, args.necessity_optional_boolean, args.registering_applications_optional_boolean);
  break;
        case 'get_name_of_item':
  result = await this.getNameOfItem(args.target_item_required_string);
  break;
        case 'set_name_of_item':
  result = await this.setNameOfItem(args.target_item_required_string, args.value_required_text);
  break;
        case 'get_name_of_item_of_container':
  result = await this.getNameOfItemOfContainer(args.target_item_required_string, args.target_container_required_string);
  break;
        case 'set_name_of_item_of_container':
  result = await this.setNameOfItemOfContainer(args.target_item_required_string, args.target_container_required_string, args.value_required_text);
  break;
        case 'get_name_of_item_of_disk':
  result = await this.getNameOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string);
  break;
        case 'set_name_of_item_of_disk':
  result = await this.setNameOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string, args.value_required_text);
  break;
        case 'get_name_of_item_of_folder':
  result = await this.getNameOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string);
  break;
        case 'set_name_of_item_of_folder':
  result = await this.setNameOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string, args.value_required_text);
  break;
        case 'get_name_of_item_of_desktop_object':
  result = await this.getNameOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string);
  break;
        case 'set_name_of_item_of_desktop_object':
  result = await this.setNameOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string, args.value_required_text);
  break;
        case 'get_name_of_item_of_trash_object':
  result = await this.getNameOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string);
  break;
        case 'set_name_of_item_of_trash_object':
  result = await this.setNameOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string, args.value_required_text);
  break;
        case 'get_displayed_name_of_item':
  result = await this.getDisplayedNameOfItem(args.target_item_required_string);
  break;
        case 'get_displayed_name_of_item_of_container':
  result = await this.getDisplayedNameOfItemOfContainer(args.target_item_required_string, args.target_container_required_string);
  break;
        case 'get_displayed_name_of_item_of_disk':
  result = await this.getDisplayedNameOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string);
  break;
        case 'get_displayed_name_of_item_of_folder':
  result = await this.getDisplayedNameOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string);
  break;
        case 'get_displayed_name_of_item_of_desktop_object':
  result = await this.getDisplayedNameOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string);
  break;
        case 'get_displayed_name_of_item_of_trash_object':
  result = await this.getDisplayedNameOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string);
  break;
        case 'get_name_extension_of_item':
  result = await this.getNameExtensionOfItem(args.target_item_required_string);
  break;
        case 'set_name_extension_of_item':
  result = await this.setNameExtensionOfItem(args.target_item_required_string, args.value_required_text);
  break;
        case 'get_name_extension_of_item_of_container':
  result = await this.getNameExtensionOfItemOfContainer(args.target_item_required_string, args.target_container_required_string);
  break;
        case 'set_name_extension_of_item_of_container':
  result = await this.setNameExtensionOfItemOfContainer(args.target_item_required_string, args.target_container_required_string, args.value_required_text);
  break;
        case 'get_name_extension_of_item_of_disk':
  result = await this.getNameExtensionOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string);
  break;
        case 'set_name_extension_of_item_of_disk':
  result = await this.setNameExtensionOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string, args.value_required_text);
  break;
        case 'get_name_extension_of_item_of_folder':
  result = await this.getNameExtensionOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string);
  break;
        case 'set_name_extension_of_item_of_folder':
  result = await this.setNameExtensionOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string, args.value_required_text);
  break;
        case 'get_name_extension_of_item_of_desktop_object':
  result = await this.getNameExtensionOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string);
  break;
        case 'set_name_extension_of_item_of_desktop_object':
  result = await this.setNameExtensionOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string, args.value_required_text);
  break;
        case 'get_name_extension_of_item_of_trash_object':
  result = await this.getNameExtensionOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string);
  break;
        case 'set_name_extension_of_item_of_trash_object':
  result = await this.setNameExtensionOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string, args.value_required_text);
  break;
        case 'get_extension_hidden_of_item':
  result = await this.getExtensionHiddenOfItem(args.target_item_required_string);
  break;
        case 'set_extension_hidden_of_item':
  result = await this.setExtensionHiddenOfItem(args.target_item_required_string, args.value_required_boolean);
  break;
        case 'get_extension_hidden_of_item_of_container':
  result = await this.getExtensionHiddenOfItemOfContainer(args.target_item_required_string, args.target_container_required_string);
  break;
        case 'set_extension_hidden_of_item_of_container':
  result = await this.setExtensionHiddenOfItemOfContainer(args.target_item_required_string, args.target_container_required_string, args.value_required_boolean);
  break;
        case 'get_extension_hidden_of_item_of_disk':
  result = await this.getExtensionHiddenOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string);
  break;
        case 'set_extension_hidden_of_item_of_disk':
  result = await this.setExtensionHiddenOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string, args.value_required_boolean);
  break;
        case 'get_extension_hidden_of_item_of_folder':
  result = await this.getExtensionHiddenOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string);
  break;
        case 'set_extension_hidden_of_item_of_folder':
  result = await this.setExtensionHiddenOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string, args.value_required_boolean);
  break;
        case 'get_extension_hidden_of_item_of_desktop_object':
  result = await this.getExtensionHiddenOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string);
  break;
        case 'set_extension_hidden_of_item_of_desktop_object':
  result = await this.setExtensionHiddenOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string, args.value_required_boolean);
  break;
        case 'get_extension_hidden_of_item_of_trash_object':
  result = await this.getExtensionHiddenOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string);
  break;
        case 'set_extension_hidden_of_item_of_trash_object':
  result = await this.setExtensionHiddenOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string, args.value_required_boolean);
  break;
        case 'get_index_of_item':
  result = await this.getIndexOfItem(args.target_item_required_string);
  break;
        case 'get_index_of_item_of_container':
  result = await this.getIndexOfItemOfContainer(args.target_item_required_string, args.target_container_required_string);
  break;
        case 'get_index_of_item_of_disk':
  result = await this.getIndexOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string);
  break;
        case 'get_index_of_item_of_folder':
  result = await this.getIndexOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string);
  break;
        case 'get_index_of_item_of_desktop_object':
  result = await this.getIndexOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string);
  break;
        case 'get_index_of_item_of_trash_object':
  result = await this.getIndexOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string);
  break;
        case 'get_container_of_item':
  result = await this.getContainerOfItem(args.target_item_required_string);
  break;
        case 'get_container_of_item_of_container':
  result = await this.getContainerOfItemOfContainer(args.target_item_required_string, args.target_container_required_string);
  break;
        case 'get_container_of_item_of_disk':
  result = await this.getContainerOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string);
  break;
        case 'get_container_of_item_of_folder':
  result = await this.getContainerOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string);
  break;
        case 'get_container_of_item_of_desktop_object':
  result = await this.getContainerOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string);
  break;
        case 'get_container_of_item_of_trash_object':
  result = await this.getContainerOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string);
  break;
        case 'get_disk_of_item':
  result = await this.getDiskOfItem(args.target_item_required_string);
  break;
        case 'get_disk_of_item_of_container':
  result = await this.getDiskOfItemOfContainer(args.target_item_required_string, args.target_container_required_string);
  break;
        case 'get_disk_of_item_of_disk':
  result = await this.getDiskOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string);
  break;
        case 'get_disk_of_item_of_folder':
  result = await this.getDiskOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string);
  break;
        case 'get_disk_of_item_of_desktop_object':
  result = await this.getDiskOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string);
  break;
        case 'get_disk_of_item_of_trash_object':
  result = await this.getDiskOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string);
  break;
        case 'get_position_of_item':
  result = await this.getPositionOfItem(args.target_item_required_string);
  break;
        case 'set_position_of_item':
  result = await this.setPositionOfItem(args.target_item_required_string, args.value_required_point);
  break;
        case 'get_position_of_item_of_container':
  result = await this.getPositionOfItemOfContainer(args.target_item_required_string, args.target_container_required_string);
  break;
        case 'set_position_of_item_of_container':
  result = await this.setPositionOfItemOfContainer(args.target_item_required_string, args.target_container_required_string, args.value_required_point);
  break;
        case 'get_position_of_item_of_disk':
  result = await this.getPositionOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string);
  break;
        case 'set_position_of_item_of_disk':
  result = await this.setPositionOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string, args.value_required_point);
  break;
        case 'get_position_of_item_of_folder':
  result = await this.getPositionOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string);
  break;
        case 'set_position_of_item_of_folder':
  result = await this.setPositionOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string, args.value_required_point);
  break;
        case 'get_position_of_item_of_desktop_object':
  result = await this.getPositionOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string);
  break;
        case 'set_position_of_item_of_desktop_object':
  result = await this.setPositionOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string, args.value_required_point);
  break;
        case 'get_position_of_item_of_trash_object':
  result = await this.getPositionOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string);
  break;
        case 'set_position_of_item_of_trash_object':
  result = await this.setPositionOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string, args.value_required_point);
  break;
        case 'get_desktop_position_of_item':
  result = await this.getDesktopPositionOfItem(args.target_item_required_string);
  break;
        case 'set_desktop_position_of_item':
  result = await this.setDesktopPositionOfItem(args.target_item_required_string, args.value_required_point);
  break;
        case 'get_desktop_position_of_item_of_container':
  result = await this.getDesktopPositionOfItemOfContainer(args.target_item_required_string, args.target_container_required_string);
  break;
        case 'set_desktop_position_of_item_of_container':
  result = await this.setDesktopPositionOfItemOfContainer(args.target_item_required_string, args.target_container_required_string, args.value_required_point);
  break;
        case 'get_desktop_position_of_item_of_disk':
  result = await this.getDesktopPositionOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string);
  break;
        case 'set_desktop_position_of_item_of_disk':
  result = await this.setDesktopPositionOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string, args.value_required_point);
  break;
        case 'get_desktop_position_of_item_of_folder':
  result = await this.getDesktopPositionOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string);
  break;
        case 'set_desktop_position_of_item_of_folder':
  result = await this.setDesktopPositionOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string, args.value_required_point);
  break;
        case 'get_desktop_position_of_item_of_desktop_object':
  result = await this.getDesktopPositionOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string);
  break;
        case 'set_desktop_position_of_item_of_desktop_object':
  result = await this.setDesktopPositionOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string, args.value_required_point);
  break;
        case 'get_desktop_position_of_item_of_trash_object':
  result = await this.getDesktopPositionOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string);
  break;
        case 'set_desktop_position_of_item_of_trash_object':
  result = await this.setDesktopPositionOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string, args.value_required_point);
  break;
        case 'get_bounds_of_item':
  result = await this.getBoundsOfItem(args.target_item_required_string);
  break;
        case 'set_bounds_of_item':
  result = await this.setBoundsOfItem(args.target_item_required_string, args.value_required_rectangle);
  break;
        case 'get_bounds_of_item_of_container':
  result = await this.getBoundsOfItemOfContainer(args.target_item_required_string, args.target_container_required_string);
  break;
        case 'set_bounds_of_item_of_container':
  result = await this.setBoundsOfItemOfContainer(args.target_item_required_string, args.target_container_required_string, args.value_required_rectangle);
  break;
        case 'get_bounds_of_item_of_disk':
  result = await this.getBoundsOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string);
  break;
        case 'set_bounds_of_item_of_disk':
  result = await this.setBoundsOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string, args.value_required_rectangle);
  break;
        case 'get_bounds_of_item_of_folder':
  result = await this.getBoundsOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string);
  break;
        case 'set_bounds_of_item_of_folder':
  result = await this.setBoundsOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string, args.value_required_rectangle);
  break;
        case 'get_bounds_of_item_of_desktop_object':
  result = await this.getBoundsOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string);
  break;
        case 'set_bounds_of_item_of_desktop_object':
  result = await this.setBoundsOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string, args.value_required_rectangle);
  break;
        case 'get_bounds_of_item_of_trash_object':
  result = await this.getBoundsOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string);
  break;
        case 'set_bounds_of_item_of_trash_object':
  result = await this.setBoundsOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string, args.value_required_rectangle);
  break;
        case 'get_label_index_of_item':
  result = await this.getLabelIndexOfItem(args.target_item_required_string);
  break;
        case 'set_label_index_of_item':
  result = await this.setLabelIndexOfItem(args.target_item_required_string, args.value_required_integer);
  break;
        case 'get_label_index_of_item_of_container':
  result = await this.getLabelIndexOfItemOfContainer(args.target_item_required_string, args.target_container_required_string);
  break;
        case 'set_label_index_of_item_of_container':
  result = await this.setLabelIndexOfItemOfContainer(args.target_item_required_string, args.target_container_required_string, args.value_required_integer);
  break;
        case 'get_label_index_of_item_of_disk':
  result = await this.getLabelIndexOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string);
  break;
        case 'set_label_index_of_item_of_disk':
  result = await this.setLabelIndexOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string, args.value_required_integer);
  break;
        case 'get_label_index_of_item_of_folder':
  result = await this.getLabelIndexOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string);
  break;
        case 'set_label_index_of_item_of_folder':
  result = await this.setLabelIndexOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string, args.value_required_integer);
  break;
        case 'get_label_index_of_item_of_desktop_object':
  result = await this.getLabelIndexOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string);
  break;
        case 'set_label_index_of_item_of_desktop_object':
  result = await this.setLabelIndexOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string, args.value_required_integer);
  break;
        case 'get_label_index_of_item_of_trash_object':
  result = await this.getLabelIndexOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string);
  break;
        case 'set_label_index_of_item_of_trash_object':
  result = await this.setLabelIndexOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string, args.value_required_integer);
  break;
        case 'get_locked_of_item':
  result = await this.getLockedOfItem(args.target_item_required_string);
  break;
        case 'set_locked_of_item':
  result = await this.setLockedOfItem(args.target_item_required_string, args.value_required_boolean);
  break;
        case 'get_locked_of_item_of_container':
  result = await this.getLockedOfItemOfContainer(args.target_item_required_string, args.target_container_required_string);
  break;
        case 'set_locked_of_item_of_container':
  result = await this.setLockedOfItemOfContainer(args.target_item_required_string, args.target_container_required_string, args.value_required_boolean);
  break;
        case 'get_locked_of_item_of_disk':
  result = await this.getLockedOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string);
  break;
        case 'set_locked_of_item_of_disk':
  result = await this.setLockedOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string, args.value_required_boolean);
  break;
        case 'get_locked_of_item_of_folder':
  result = await this.getLockedOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string);
  break;
        case 'set_locked_of_item_of_folder':
  result = await this.setLockedOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string, args.value_required_boolean);
  break;
        case 'get_locked_of_item_of_desktop_object':
  result = await this.getLockedOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string);
  break;
        case 'set_locked_of_item_of_desktop_object':
  result = await this.setLockedOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string, args.value_required_boolean);
  break;
        case 'get_locked_of_item_of_trash_object':
  result = await this.getLockedOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string);
  break;
        case 'set_locked_of_item_of_trash_object':
  result = await this.setLockedOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string, args.value_required_boolean);
  break;
        case 'get_kind_of_item':
  result = await this.getKindOfItem(args.target_item_required_string);
  break;
        case 'get_kind_of_item_of_container':
  result = await this.getKindOfItemOfContainer(args.target_item_required_string, args.target_container_required_string);
  break;
        case 'get_kind_of_item_of_disk':
  result = await this.getKindOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string);
  break;
        case 'get_kind_of_item_of_folder':
  result = await this.getKindOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string);
  break;
        case 'get_kind_of_item_of_desktop_object':
  result = await this.getKindOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string);
  break;
        case 'get_kind_of_item_of_trash_object':
  result = await this.getKindOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string);
  break;
        case 'get_description_of_item':
  result = await this.getDescriptionOfItem(args.target_item_required_string);
  break;
        case 'get_description_of_item_of_container':
  result = await this.getDescriptionOfItemOfContainer(args.target_item_required_string, args.target_container_required_string);
  break;
        case 'get_description_of_item_of_disk':
  result = await this.getDescriptionOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string);
  break;
        case 'get_description_of_item_of_folder':
  result = await this.getDescriptionOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string);
  break;
        case 'get_description_of_item_of_desktop_object':
  result = await this.getDescriptionOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string);
  break;
        case 'get_description_of_item_of_trash_object':
  result = await this.getDescriptionOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string);
  break;
        case 'get_comment_of_item':
  result = await this.getCommentOfItem(args.target_item_required_string);
  break;
        case 'set_comment_of_item':
  result = await this.setCommentOfItem(args.target_item_required_string, args.value_required_text);
  break;
        case 'get_comment_of_item_of_container':
  result = await this.getCommentOfItemOfContainer(args.target_item_required_string, args.target_container_required_string);
  break;
        case 'set_comment_of_item_of_container':
  result = await this.setCommentOfItemOfContainer(args.target_item_required_string, args.target_container_required_string, args.value_required_text);
  break;
        case 'get_comment_of_item_of_disk':
  result = await this.getCommentOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string);
  break;
        case 'set_comment_of_item_of_disk':
  result = await this.setCommentOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string, args.value_required_text);
  break;
        case 'get_comment_of_item_of_folder':
  result = await this.getCommentOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string);
  break;
        case 'set_comment_of_item_of_folder':
  result = await this.setCommentOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string, args.value_required_text);
  break;
        case 'get_comment_of_item_of_desktop_object':
  result = await this.getCommentOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string);
  break;
        case 'set_comment_of_item_of_desktop_object':
  result = await this.setCommentOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string, args.value_required_text);
  break;
        case 'get_comment_of_item_of_trash_object':
  result = await this.getCommentOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string);
  break;
        case 'set_comment_of_item_of_trash_object':
  result = await this.setCommentOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string, args.value_required_text);
  break;
        case 'get_size_of_item':
  result = await this.getSizeOfItem(args.target_item_required_string);
  break;
        case 'get_size_of_item_of_container':
  result = await this.getSizeOfItemOfContainer(args.target_item_required_string, args.target_container_required_string);
  break;
        case 'get_size_of_item_of_disk':
  result = await this.getSizeOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string);
  break;
        case 'get_size_of_item_of_folder':
  result = await this.getSizeOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string);
  break;
        case 'get_size_of_item_of_desktop_object':
  result = await this.getSizeOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string);
  break;
        case 'get_size_of_item_of_trash_object':
  result = await this.getSizeOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string);
  break;
        case 'get_physical_size_of_item':
  result = await this.getPhysicalSizeOfItem(args.target_item_required_string);
  break;
        case 'get_physical_size_of_item_of_container':
  result = await this.getPhysicalSizeOfItemOfContainer(args.target_item_required_string, args.target_container_required_string);
  break;
        case 'get_physical_size_of_item_of_disk':
  result = await this.getPhysicalSizeOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string);
  break;
        case 'get_physical_size_of_item_of_folder':
  result = await this.getPhysicalSizeOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string);
  break;
        case 'get_physical_size_of_item_of_desktop_object':
  result = await this.getPhysicalSizeOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string);
  break;
        case 'get_physical_size_of_item_of_trash_object':
  result = await this.getPhysicalSizeOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string);
  break;
        case 'get_creation_date_of_item':
  result = await this.getCreationDateOfItem(args.target_item_required_string);
  break;
        case 'get_creation_date_of_item_of_container':
  result = await this.getCreationDateOfItemOfContainer(args.target_item_required_string, args.target_container_required_string);
  break;
        case 'get_creation_date_of_item_of_disk':
  result = await this.getCreationDateOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string);
  break;
        case 'get_creation_date_of_item_of_folder':
  result = await this.getCreationDateOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string);
  break;
        case 'get_creation_date_of_item_of_desktop_object':
  result = await this.getCreationDateOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string);
  break;
        case 'get_creation_date_of_item_of_trash_object':
  result = await this.getCreationDateOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string);
  break;
        case 'get_modification_date_of_item':
  result = await this.getModificationDateOfItem(args.target_item_required_string);
  break;
        case 'set_modification_date_of_item':
  result = await this.setModificationDateOfItem(args.target_item_required_string, args.value_required_date);
  break;
        case 'get_modification_date_of_item_of_container':
  result = await this.getModificationDateOfItemOfContainer(args.target_item_required_string, args.target_container_required_string);
  break;
        case 'set_modification_date_of_item_of_container':
  result = await this.setModificationDateOfItemOfContainer(args.target_item_required_string, args.target_container_required_string, args.value_required_date);
  break;
        case 'get_modification_date_of_item_of_disk':
  result = await this.getModificationDateOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string);
  break;
        case 'set_modification_date_of_item_of_disk':
  result = await this.setModificationDateOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string, args.value_required_date);
  break;
        case 'get_modification_date_of_item_of_folder':
  result = await this.getModificationDateOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string);
  break;
        case 'set_modification_date_of_item_of_folder':
  result = await this.setModificationDateOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string, args.value_required_date);
  break;
        case 'get_modification_date_of_item_of_desktop_object':
  result = await this.getModificationDateOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string);
  break;
        case 'set_modification_date_of_item_of_desktop_object':
  result = await this.setModificationDateOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string, args.value_required_date);
  break;
        case 'get_modification_date_of_item_of_trash_object':
  result = await this.getModificationDateOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string);
  break;
        case 'set_modification_date_of_item_of_trash_object':
  result = await this.setModificationDateOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string, args.value_required_date);
  break;
        case 'get_icon_of_item':
  result = await this.getIconOfItem(args.target_item_required_string);
  break;
        case 'set_icon_of_item':
  result = await this.setIconOfItem(args.target_item_required_string, args.value_required_icon_family);
  break;
        case 'get_icon_of_item_of_container':
  result = await this.getIconOfItemOfContainer(args.target_item_required_string, args.target_container_required_string);
  break;
        case 'set_icon_of_item_of_container':
  result = await this.setIconOfItemOfContainer(args.target_item_required_string, args.target_container_required_string, args.value_required_icon_family);
  break;
        case 'get_icon_of_item_of_disk':
  result = await this.getIconOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string);
  break;
        case 'set_icon_of_item_of_disk':
  result = await this.setIconOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string, args.value_required_icon_family);
  break;
        case 'get_icon_of_item_of_folder':
  result = await this.getIconOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string);
  break;
        case 'set_icon_of_item_of_folder':
  result = await this.setIconOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string, args.value_required_icon_family);
  break;
        case 'get_icon_of_item_of_desktop_object':
  result = await this.getIconOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string);
  break;
        case 'set_icon_of_item_of_desktop_object':
  result = await this.setIconOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string, args.value_required_icon_family);
  break;
        case 'get_icon_of_item_of_trash_object':
  result = await this.getIconOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string);
  break;
        case 'set_icon_of_item_of_trash_object':
  result = await this.setIconOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string, args.value_required_icon_family);
  break;
        case 'get_url_of_item':
  result = await this.getUrlOfItem(args.target_item_required_string);
  break;
        case 'get_url_of_item_of_container':
  result = await this.getUrlOfItemOfContainer(args.target_item_required_string, args.target_container_required_string);
  break;
        case 'get_url_of_item_of_disk':
  result = await this.getUrlOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string);
  break;
        case 'get_url_of_item_of_folder':
  result = await this.getUrlOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string);
  break;
        case 'get_url_of_item_of_desktop_object':
  result = await this.getUrlOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string);
  break;
        case 'get_url_of_item_of_trash_object':
  result = await this.getUrlOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string);
  break;
        case 'get_owner_of_item':
  result = await this.getOwnerOfItem(args.target_item_required_string);
  break;
        case 'set_owner_of_item':
  result = await this.setOwnerOfItem(args.target_item_required_string, args.value_required_text);
  break;
        case 'get_owner_of_item_of_container':
  result = await this.getOwnerOfItemOfContainer(args.target_item_required_string, args.target_container_required_string);
  break;
        case 'set_owner_of_item_of_container':
  result = await this.setOwnerOfItemOfContainer(args.target_item_required_string, args.target_container_required_string, args.value_required_text);
  break;
        case 'get_owner_of_item_of_disk':
  result = await this.getOwnerOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string);
  break;
        case 'set_owner_of_item_of_disk':
  result = await this.setOwnerOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string, args.value_required_text);
  break;
        case 'get_owner_of_item_of_folder':
  result = await this.getOwnerOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string);
  break;
        case 'set_owner_of_item_of_folder':
  result = await this.setOwnerOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string, args.value_required_text);
  break;
        case 'get_owner_of_item_of_desktop_object':
  result = await this.getOwnerOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string);
  break;
        case 'set_owner_of_item_of_desktop_object':
  result = await this.setOwnerOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string, args.value_required_text);
  break;
        case 'get_owner_of_item_of_trash_object':
  result = await this.getOwnerOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string);
  break;
        case 'set_owner_of_item_of_trash_object':
  result = await this.setOwnerOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string, args.value_required_text);
  break;
        case 'get_group_of_item':
  result = await this.getGroupOfItem(args.target_item_required_string);
  break;
        case 'set_group_of_item':
  result = await this.setGroupOfItem(args.target_item_required_string, args.value_required_text);
  break;
        case 'get_group_of_item_of_container':
  result = await this.getGroupOfItemOfContainer(args.target_item_required_string, args.target_container_required_string);
  break;
        case 'set_group_of_item_of_container':
  result = await this.setGroupOfItemOfContainer(args.target_item_required_string, args.target_container_required_string, args.value_required_text);
  break;
        case 'get_group_of_item_of_disk':
  result = await this.getGroupOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string);
  break;
        case 'set_group_of_item_of_disk':
  result = await this.setGroupOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string, args.value_required_text);
  break;
        case 'get_group_of_item_of_folder':
  result = await this.getGroupOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string);
  break;
        case 'set_group_of_item_of_folder':
  result = await this.setGroupOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string, args.value_required_text);
  break;
        case 'get_group_of_item_of_desktop_object':
  result = await this.getGroupOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string);
  break;
        case 'set_group_of_item_of_desktop_object':
  result = await this.setGroupOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string, args.value_required_text);
  break;
        case 'get_group_of_item_of_trash_object':
  result = await this.getGroupOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string);
  break;
        case 'set_group_of_item_of_trash_object':
  result = await this.setGroupOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string, args.value_required_text);
  break;
        case 'get_owner_privileges_of_item':
  result = await this.getOwnerPrivilegesOfItem(args.target_item_required_string);
  break;
        case 'set_owner_privileges_of_item':
  result = await this.setOwnerPrivilegesOfItem(args.target_item_required_string, args.value_required_priv);
  break;
        case 'get_owner_privileges_of_item_of_container':
  result = await this.getOwnerPrivilegesOfItemOfContainer(args.target_item_required_string, args.target_container_required_string);
  break;
        case 'set_owner_privileges_of_item_of_container':
  result = await this.setOwnerPrivilegesOfItemOfContainer(args.target_item_required_string, args.target_container_required_string, args.value_required_priv);
  break;
        case 'get_owner_privileges_of_item_of_disk':
  result = await this.getOwnerPrivilegesOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string);
  break;
        case 'set_owner_privileges_of_item_of_disk':
  result = await this.setOwnerPrivilegesOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string, args.value_required_priv);
  break;
        case 'get_owner_privileges_of_item_of_folder':
  result = await this.getOwnerPrivilegesOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string);
  break;
        case 'set_owner_privileges_of_item_of_folder':
  result = await this.setOwnerPrivilegesOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string, args.value_required_priv);
  break;
        case 'get_owner_privileges_of_item_of_desktop_object':
  result = await this.getOwnerPrivilegesOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string);
  break;
        case 'set_owner_privileges_of_item_of_desktop_object':
  result = await this.setOwnerPrivilegesOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string, args.value_required_priv);
  break;
        case 'get_owner_privileges_of_item_of_trash_object':
  result = await this.getOwnerPrivilegesOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string);
  break;
        case 'set_owner_privileges_of_item_of_trash_object':
  result = await this.setOwnerPrivilegesOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string, args.value_required_priv);
  break;
        case 'get_group_privileges_of_item':
  result = await this.getGroupPrivilegesOfItem(args.target_item_required_string);
  break;
        case 'set_group_privileges_of_item':
  result = await this.setGroupPrivilegesOfItem(args.target_item_required_string, args.value_required_priv);
  break;
        case 'get_group_privileges_of_item_of_container':
  result = await this.getGroupPrivilegesOfItemOfContainer(args.target_item_required_string, args.target_container_required_string);
  break;
        case 'set_group_privileges_of_item_of_container':
  result = await this.setGroupPrivilegesOfItemOfContainer(args.target_item_required_string, args.target_container_required_string, args.value_required_priv);
  break;
        case 'get_group_privileges_of_item_of_disk':
  result = await this.getGroupPrivilegesOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string);
  break;
        case 'set_group_privileges_of_item_of_disk':
  result = await this.setGroupPrivilegesOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string, args.value_required_priv);
  break;
        case 'get_group_privileges_of_item_of_folder':
  result = await this.getGroupPrivilegesOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string);
  break;
        case 'set_group_privileges_of_item_of_folder':
  result = await this.setGroupPrivilegesOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string, args.value_required_priv);
  break;
        case 'get_group_privileges_of_item_of_desktop_object':
  result = await this.getGroupPrivilegesOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string);
  break;
        case 'set_group_privileges_of_item_of_desktop_object':
  result = await this.setGroupPrivilegesOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string, args.value_required_priv);
  break;
        case 'get_group_privileges_of_item_of_trash_object':
  result = await this.getGroupPrivilegesOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string);
  break;
        case 'set_group_privileges_of_item_of_trash_object':
  result = await this.setGroupPrivilegesOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string, args.value_required_priv);
  break;
        case 'get_everyones_privileges_of_item':
  result = await this.getEveryonesPrivilegesOfItem(args.target_item_required_string);
  break;
        case 'set_everyones_privileges_of_item':
  result = await this.setEveryonesPrivilegesOfItem(args.target_item_required_string, args.value_required_priv);
  break;
        case 'get_everyones_privileges_of_item_of_container':
  result = await this.getEveryonesPrivilegesOfItemOfContainer(args.target_item_required_string, args.target_container_required_string);
  break;
        case 'set_everyones_privileges_of_item_of_container':
  result = await this.setEveryonesPrivilegesOfItemOfContainer(args.target_item_required_string, args.target_container_required_string, args.value_required_priv);
  break;
        case 'get_everyones_privileges_of_item_of_disk':
  result = await this.getEveryonesPrivilegesOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string);
  break;
        case 'set_everyones_privileges_of_item_of_disk':
  result = await this.setEveryonesPrivilegesOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string, args.value_required_priv);
  break;
        case 'get_everyones_privileges_of_item_of_folder':
  result = await this.getEveryonesPrivilegesOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string);
  break;
        case 'set_everyones_privileges_of_item_of_folder':
  result = await this.setEveryonesPrivilegesOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string, args.value_required_priv);
  break;
        case 'get_everyones_privileges_of_item_of_desktop_object':
  result = await this.getEveryonesPrivilegesOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string);
  break;
        case 'set_everyones_privileges_of_item_of_desktop_object':
  result = await this.setEveryonesPrivilegesOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string, args.value_required_priv);
  break;
        case 'get_everyones_privileges_of_item_of_trash_object':
  result = await this.getEveryonesPrivilegesOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string);
  break;
        case 'set_everyones_privileges_of_item_of_trash_object':
  result = await this.setEveryonesPrivilegesOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string, args.value_required_priv);
  break;
        case 'get_information_window_of_item':
  result = await this.getInformationWindowOfItem(args.target_item_required_string);
  break;
        case 'get_information_window_of_item_of_container':
  result = await this.getInformationWindowOfItemOfContainer(args.target_item_required_string, args.target_container_required_string);
  break;
        case 'get_information_window_of_item_of_disk':
  result = await this.getInformationWindowOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string);
  break;
        case 'get_information_window_of_item_of_folder':
  result = await this.getInformationWindowOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string);
  break;
        case 'get_information_window_of_item_of_desktop_object':
  result = await this.getInformationWindowOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string);
  break;
        case 'get_information_window_of_item_of_trash_object':
  result = await this.getInformationWindowOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string);
  break;
        case 'get_properties_of_item':
  result = await this.getPropertiesOfItem(args.target_item_required_string);
  break;
        case 'set_properties_of_item':
  result = await this.setPropertiesOfItem(args.target_item_required_string, args.value_required_record);
  break;
        case 'get_properties_of_item_of_container':
  result = await this.getPropertiesOfItemOfContainer(args.target_item_required_string, args.target_container_required_string);
  break;
        case 'set_properties_of_item_of_container':
  result = await this.setPropertiesOfItemOfContainer(args.target_item_required_string, args.target_container_required_string, args.value_required_record);
  break;
        case 'get_properties_of_item_of_disk':
  result = await this.getPropertiesOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string);
  break;
        case 'set_properties_of_item_of_disk':
  result = await this.setPropertiesOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string, args.value_required_record);
  break;
        case 'get_properties_of_item_of_folder':
  result = await this.getPropertiesOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string);
  break;
        case 'set_properties_of_item_of_folder':
  result = await this.setPropertiesOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string, args.value_required_record);
  break;
        case 'get_properties_of_item_of_desktop_object':
  result = await this.getPropertiesOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string);
  break;
        case 'set_properties_of_item_of_desktop_object':
  result = await this.setPropertiesOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string, args.value_required_record);
  break;
        case 'get_properties_of_item_of_trash_object':
  result = await this.getPropertiesOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string);
  break;
        case 'set_properties_of_item_of_trash_object':
  result = await this.setPropertiesOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string, args.value_required_record);
  break;
        case 'get_class_of_item':
  result = await this.getClassOfItem(args.target_item_required_string);
  break;
        case 'get_class_of_item_of_container':
  result = await this.getClassOfItemOfContainer(args.target_item_required_string, args.target_container_required_string);
  break;
        case 'get_class_of_item_of_disk':
  result = await this.getClassOfItemOfDisk(args.target_item_required_string, args.target_disk_required_string);
  break;
        case 'get_class_of_item_of_folder':
  result = await this.getClassOfItemOfFolder(args.target_item_required_string, args.target_folder_required_string);
  break;
        case 'get_class_of_item_of_desktop_object':
  result = await this.getClassOfItemOfDesktopObject(args.target_item_required_string, args.target_desktop_object_required_string);
  break;
        case 'get_class_of_item_of_trash_object':
  result = await this.getClassOfItemOfTrashObject(args.target_item_required_string, args.target_trash_object_required_string);
  break;
        case 'get_entire_contents_of_container':
  result = await this.getEntireContentsOfContainer(args.target_container_required_string);
  break;
        case 'get_entire_contents_of_container_of_disk':
  result = await this.getEntireContentsOfContainerOfDisk(args.target_container_required_string, args.target_disk_required_string);
  break;
        case 'get_entire_contents_of_container_of_folder':
  result = await this.getEntireContentsOfContainerOfFolder(args.target_container_required_string, args.target_folder_required_string);
  break;
        case 'get_entire_contents_of_container_of_desktop_object':
  result = await this.getEntireContentsOfContainerOfDesktopObject(args.target_container_required_string, args.target_desktop_object_required_string);
  break;
        case 'get_entire_contents_of_container_of_trash_object':
  result = await this.getEntireContentsOfContainerOfTrashObject(args.target_container_required_string, args.target_trash_object_required_string);
  break;
        case 'get_expandable_of_container':
  result = await this.getExpandableOfContainer(args.target_container_required_string);
  break;
        case 'get_expandable_of_container_of_disk':
  result = await this.getExpandableOfContainerOfDisk(args.target_container_required_string, args.target_disk_required_string);
  break;
        case 'get_expandable_of_container_of_folder':
  result = await this.getExpandableOfContainerOfFolder(args.target_container_required_string, args.target_folder_required_string);
  break;
        case 'get_expandable_of_container_of_desktop_object':
  result = await this.getExpandableOfContainerOfDesktopObject(args.target_container_required_string, args.target_desktop_object_required_string);
  break;
        case 'get_expandable_of_container_of_trash_object':
  result = await this.getExpandableOfContainerOfTrashObject(args.target_container_required_string, args.target_trash_object_required_string);
  break;
        case 'get_expanded_of_container':
  result = await this.getExpandedOfContainer(args.target_container_required_string);
  break;
        case 'set_expanded_of_container':
  result = await this.setExpandedOfContainer(args.target_container_required_string, args.value_required_boolean);
  break;
        case 'get_expanded_of_container_of_disk':
  result = await this.getExpandedOfContainerOfDisk(args.target_container_required_string, args.target_disk_required_string);
  break;
        case 'set_expanded_of_container_of_disk':
  result = await this.setExpandedOfContainerOfDisk(args.target_container_required_string, args.target_disk_required_string, args.value_required_boolean);
  break;
        case 'get_expanded_of_container_of_folder':
  result = await this.getExpandedOfContainerOfFolder(args.target_container_required_string, args.target_folder_required_string);
  break;
        case 'set_expanded_of_container_of_folder':
  result = await this.setExpandedOfContainerOfFolder(args.target_container_required_string, args.target_folder_required_string, args.value_required_boolean);
  break;
        case 'get_expanded_of_container_of_desktop_object':
  result = await this.getExpandedOfContainerOfDesktopObject(args.target_container_required_string, args.target_desktop_object_required_string);
  break;
        case 'set_expanded_of_container_of_desktop_object':
  result = await this.setExpandedOfContainerOfDesktopObject(args.target_container_required_string, args.target_desktop_object_required_string, args.value_required_boolean);
  break;
        case 'get_expanded_of_container_of_trash_object':
  result = await this.getExpandedOfContainerOfTrashObject(args.target_container_required_string, args.target_trash_object_required_string);
  break;
        case 'set_expanded_of_container_of_trash_object':
  result = await this.setExpandedOfContainerOfTrashObject(args.target_container_required_string, args.target_trash_object_required_string, args.value_required_boolean);
  break;
        case 'get_completely_expanded_of_container':
  result = await this.getCompletelyExpandedOfContainer(args.target_container_required_string);
  break;
        case 'set_completely_expanded_of_container':
  result = await this.setCompletelyExpandedOfContainer(args.target_container_required_string, args.value_required_boolean);
  break;
        case 'get_completely_expanded_of_container_of_disk':
  result = await this.getCompletelyExpandedOfContainerOfDisk(args.target_container_required_string, args.target_disk_required_string);
  break;
        case 'set_completely_expanded_of_container_of_disk':
  result = await this.setCompletelyExpandedOfContainerOfDisk(args.target_container_required_string, args.target_disk_required_string, args.value_required_boolean);
  break;
        case 'get_completely_expanded_of_container_of_folder':
  result = await this.getCompletelyExpandedOfContainerOfFolder(args.target_container_required_string, args.target_folder_required_string);
  break;
        case 'set_completely_expanded_of_container_of_folder':
  result = await this.setCompletelyExpandedOfContainerOfFolder(args.target_container_required_string, args.target_folder_required_string, args.value_required_boolean);
  break;
        case 'get_completely_expanded_of_container_of_desktop_object':
  result = await this.getCompletelyExpandedOfContainerOfDesktopObject(args.target_container_required_string, args.target_desktop_object_required_string);
  break;
        case 'set_completely_expanded_of_container_of_desktop_object':
  result = await this.setCompletelyExpandedOfContainerOfDesktopObject(args.target_container_required_string, args.target_desktop_object_required_string, args.value_required_boolean);
  break;
        case 'get_completely_expanded_of_container_of_trash_object':
  result = await this.getCompletelyExpandedOfContainerOfTrashObject(args.target_container_required_string, args.target_trash_object_required_string);
  break;
        case 'set_completely_expanded_of_container_of_trash_object':
  result = await this.setCompletelyExpandedOfContainerOfTrashObject(args.target_container_required_string, args.target_trash_object_required_string, args.value_required_boolean);
  break;
        case 'get_container_window_of_container':
  result = await this.getContainerWindowOfContainer(args.target_container_required_string);
  break;
        case 'get_container_window_of_container_of_disk':
  result = await this.getContainerWindowOfContainerOfDisk(args.target_container_required_string, args.target_disk_required_string);
  break;
        case 'get_container_window_of_container_of_folder':
  result = await this.getContainerWindowOfContainerOfFolder(args.target_container_required_string, args.target_folder_required_string);
  break;
        case 'get_container_window_of_container_of_desktop_object':
  result = await this.getContainerWindowOfContainerOfDesktopObject(args.target_container_required_string, args.target_desktop_object_required_string);
  break;
        case 'get_container_window_of_container_of_trash_object':
  result = await this.getContainerWindowOfContainerOfTrashObject(args.target_container_required_string, args.target_trash_object_required_string);
  break;
        case 'get_id_of_disk':
  result = await this.getIdOfDisk(args.target_disk_required_string);
  break;
        case 'get_id_of_disk_of_desktop_object':
  result = await this.getIdOfDiskOfDesktopObject(args.target_disk_required_string, args.target_desktop_object_required_string);
  break;
        case 'get_capacity_of_disk':
  result = await this.getCapacityOfDisk(args.target_disk_required_string);
  break;
        case 'get_capacity_of_disk_of_desktop_object':
  result = await this.getCapacityOfDiskOfDesktopObject(args.target_disk_required_string, args.target_desktop_object_required_string);
  break;
        case 'get_free_space_of_disk':
  result = await this.getFreeSpaceOfDisk(args.target_disk_required_string);
  break;
        case 'get_free_space_of_disk_of_desktop_object':
  result = await this.getFreeSpaceOfDiskOfDesktopObject(args.target_disk_required_string, args.target_desktop_object_required_string);
  break;
        case 'get_ejectable_of_disk':
  result = await this.getEjectableOfDisk(args.target_disk_required_string);
  break;
        case 'get_ejectable_of_disk_of_desktop_object':
  result = await this.getEjectableOfDiskOfDesktopObject(args.target_disk_required_string, args.target_desktop_object_required_string);
  break;
        case 'get_local_volume_of_disk':
  result = await this.getLocalVolumeOfDisk(args.target_disk_required_string);
  break;
        case 'get_local_volume_of_disk_of_desktop_object':
  result = await this.getLocalVolumeOfDiskOfDesktopObject(args.target_disk_required_string, args.target_desktop_object_required_string);
  break;
        case 'get_startup_of_disk':
  result = await this.getStartupOfDisk(args.target_disk_required_string);
  break;
        case 'get_startup_of_disk_of_desktop_object':
  result = await this.getStartupOfDiskOfDesktopObject(args.target_disk_required_string, args.target_desktop_object_required_string);
  break;
        case 'get_format_of_disk':
  result = await this.getFormatOfDisk(args.target_disk_required_string);
  break;
        case 'get_format_of_disk_of_desktop_object':
  result = await this.getFormatOfDiskOfDesktopObject(args.target_disk_required_string, args.target_desktop_object_required_string);
  break;
        case 'get_journaling_enabled_of_disk':
  result = await this.getJournalingEnabledOfDisk(args.target_disk_required_string);
  break;
        case 'get_journaling_enabled_of_disk_of_desktop_object':
  result = await this.getJournalingEnabledOfDiskOfDesktopObject(args.target_disk_required_string, args.target_desktop_object_required_string);
  break;
        case 'get_ignore_privileges_of_disk':
  result = await this.getIgnorePrivilegesOfDisk(args.target_disk_required_string);
  break;
        case 'set_ignore_privileges_of_disk':
  result = await this.setIgnorePrivilegesOfDisk(args.target_disk_required_string, args.value_required_boolean);
  break;
        case 'get_ignore_privileges_of_disk_of_desktop_object':
  result = await this.getIgnorePrivilegesOfDiskOfDesktopObject(args.target_disk_required_string, args.target_desktop_object_required_string);
  break;
        case 'set_ignore_privileges_of_disk_of_desktop_object':
  result = await this.setIgnorePrivilegesOfDiskOfDesktopObject(args.target_disk_required_string, args.target_desktop_object_required_string, args.value_required_boolean);
  break;
        case 'get_warns_before_emptying_of_trash_object':
  result = await this.getWarnsBeforeEmptyingOfTrashObject(args.target_trash_object_required_string);
  break;
        case 'set_warns_before_emptying_of_trash_object':
  result = await this.setWarnsBeforeEmptyingOfTrashObject(args.target_trash_object_required_string, args.value_required_boolean);
  break;
        case 'get_file_type_of_file':
  result = await this.getFileTypeOfFile(args.target_file_required_string);
  break;
        case 'set_file_type_of_file':
  result = await this.setFileTypeOfFile(args.target_file_required_string, args.value_required_type);
  break;
        case 'get_file_type_of_file_of_container':
  result = await this.getFileTypeOfFileOfContainer(args.target_file_required_string, args.target_container_required_string);
  break;
        case 'set_file_type_of_file_of_container':
  result = await this.setFileTypeOfFileOfContainer(args.target_file_required_string, args.target_container_required_string, args.value_required_type);
  break;
        case 'get_file_type_of_file_of_disk':
  result = await this.getFileTypeOfFileOfDisk(args.target_file_required_string, args.target_disk_required_string);
  break;
        case 'set_file_type_of_file_of_disk':
  result = await this.setFileTypeOfFileOfDisk(args.target_file_required_string, args.target_disk_required_string, args.value_required_type);
  break;
        case 'get_file_type_of_file_of_folder':
  result = await this.getFileTypeOfFileOfFolder(args.target_file_required_string, args.target_folder_required_string);
  break;
        case 'set_file_type_of_file_of_folder':
  result = await this.setFileTypeOfFileOfFolder(args.target_file_required_string, args.target_folder_required_string, args.value_required_type);
  break;
        case 'get_file_type_of_file_of_desktop_object':
  result = await this.getFileTypeOfFileOfDesktopObject(args.target_file_required_string, args.target_desktop_object_required_string);
  break;
        case 'set_file_type_of_file_of_desktop_object':
  result = await this.setFileTypeOfFileOfDesktopObject(args.target_file_required_string, args.target_desktop_object_required_string, args.value_required_type);
  break;
        case 'get_file_type_of_file_of_trash_object':
  result = await this.getFileTypeOfFileOfTrashObject(args.target_file_required_string, args.target_trash_object_required_string);
  break;
        case 'set_file_type_of_file_of_trash_object':
  result = await this.setFileTypeOfFileOfTrashObject(args.target_file_required_string, args.target_trash_object_required_string, args.value_required_type);
  break;
        case 'get_creator_type_of_file':
  result = await this.getCreatorTypeOfFile(args.target_file_required_string);
  break;
        case 'set_creator_type_of_file':
  result = await this.setCreatorTypeOfFile(args.target_file_required_string, args.value_required_type);
  break;
        case 'get_creator_type_of_file_of_container':
  result = await this.getCreatorTypeOfFileOfContainer(args.target_file_required_string, args.target_container_required_string);
  break;
        case 'set_creator_type_of_file_of_container':
  result = await this.setCreatorTypeOfFileOfContainer(args.target_file_required_string, args.target_container_required_string, args.value_required_type);
  break;
        case 'get_creator_type_of_file_of_disk':
  result = await this.getCreatorTypeOfFileOfDisk(args.target_file_required_string, args.target_disk_required_string);
  break;
        case 'set_creator_type_of_file_of_disk':
  result = await this.setCreatorTypeOfFileOfDisk(args.target_file_required_string, args.target_disk_required_string, args.value_required_type);
  break;
        case 'get_creator_type_of_file_of_folder':
  result = await this.getCreatorTypeOfFileOfFolder(args.target_file_required_string, args.target_folder_required_string);
  break;
        case 'set_creator_type_of_file_of_folder':
  result = await this.setCreatorTypeOfFileOfFolder(args.target_file_required_string, args.target_folder_required_string, args.value_required_type);
  break;
        case 'get_creator_type_of_file_of_desktop_object':
  result = await this.getCreatorTypeOfFileOfDesktopObject(args.target_file_required_string, args.target_desktop_object_required_string);
  break;
        case 'set_creator_type_of_file_of_desktop_object':
  result = await this.setCreatorTypeOfFileOfDesktopObject(args.target_file_required_string, args.target_desktop_object_required_string, args.value_required_type);
  break;
        case 'get_creator_type_of_file_of_trash_object':
  result = await this.getCreatorTypeOfFileOfTrashObject(args.target_file_required_string, args.target_trash_object_required_string);
  break;
        case 'set_creator_type_of_file_of_trash_object':
  result = await this.setCreatorTypeOfFileOfTrashObject(args.target_file_required_string, args.target_trash_object_required_string, args.value_required_type);
  break;
        case 'get_stationery_of_file':
  result = await this.getStationeryOfFile(args.target_file_required_string);
  break;
        case 'set_stationery_of_file':
  result = await this.setStationeryOfFile(args.target_file_required_string, args.value_required_boolean);
  break;
        case 'get_stationery_of_file_of_container':
  result = await this.getStationeryOfFileOfContainer(args.target_file_required_string, args.target_container_required_string);
  break;
        case 'set_stationery_of_file_of_container':
  result = await this.setStationeryOfFileOfContainer(args.target_file_required_string, args.target_container_required_string, args.value_required_boolean);
  break;
        case 'get_stationery_of_file_of_disk':
  result = await this.getStationeryOfFileOfDisk(args.target_file_required_string, args.target_disk_required_string);
  break;
        case 'set_stationery_of_file_of_disk':
  result = await this.setStationeryOfFileOfDisk(args.target_file_required_string, args.target_disk_required_string, args.value_required_boolean);
  break;
        case 'get_stationery_of_file_of_folder':
  result = await this.getStationeryOfFileOfFolder(args.target_file_required_string, args.target_folder_required_string);
  break;
        case 'set_stationery_of_file_of_folder':
  result = await this.setStationeryOfFileOfFolder(args.target_file_required_string, args.target_folder_required_string, args.value_required_boolean);
  break;
        case 'get_stationery_of_file_of_desktop_object':
  result = await this.getStationeryOfFileOfDesktopObject(args.target_file_required_string, args.target_desktop_object_required_string);
  break;
        case 'set_stationery_of_file_of_desktop_object':
  result = await this.setStationeryOfFileOfDesktopObject(args.target_file_required_string, args.target_desktop_object_required_string, args.value_required_boolean);
  break;
        case 'get_stationery_of_file_of_trash_object':
  result = await this.getStationeryOfFileOfTrashObject(args.target_file_required_string, args.target_trash_object_required_string);
  break;
        case 'set_stationery_of_file_of_trash_object':
  result = await this.setStationeryOfFileOfTrashObject(args.target_file_required_string, args.target_trash_object_required_string, args.value_required_boolean);
  break;
        case 'get_product_version_of_file':
  result = await this.getProductVersionOfFile(args.target_file_required_string);
  break;
        case 'get_product_version_of_file_of_container':
  result = await this.getProductVersionOfFileOfContainer(args.target_file_required_string, args.target_container_required_string);
  break;
        case 'get_product_version_of_file_of_disk':
  result = await this.getProductVersionOfFileOfDisk(args.target_file_required_string, args.target_disk_required_string);
  break;
        case 'get_product_version_of_file_of_folder':
  result = await this.getProductVersionOfFileOfFolder(args.target_file_required_string, args.target_folder_required_string);
  break;
        case 'get_product_version_of_file_of_desktop_object':
  result = await this.getProductVersionOfFileOfDesktopObject(args.target_file_required_string, args.target_desktop_object_required_string);
  break;
        case 'get_product_version_of_file_of_trash_object':
  result = await this.getProductVersionOfFileOfTrashObject(args.target_file_required_string, args.target_trash_object_required_string);
  break;
        case 'get_version_of_file':
  result = await this.getVersionOfFile(args.target_file_required_string);
  break;
        case 'get_version_of_file_of_container':
  result = await this.getVersionOfFileOfContainer(args.target_file_required_string, args.target_container_required_string);
  break;
        case 'get_version_of_file_of_disk':
  result = await this.getVersionOfFileOfDisk(args.target_file_required_string, args.target_disk_required_string);
  break;
        case 'get_version_of_file_of_folder':
  result = await this.getVersionOfFileOfFolder(args.target_file_required_string, args.target_folder_required_string);
  break;
        case 'get_version_of_file_of_desktop_object':
  result = await this.getVersionOfFileOfDesktopObject(args.target_file_required_string, args.target_desktop_object_required_string);
  break;
        case 'get_version_of_file_of_trash_object':
  result = await this.getVersionOfFileOfTrashObject(args.target_file_required_string, args.target_trash_object_required_string);
  break;
        case 'get_original_item_of_alias_file':
  result = await this.getOriginalItemOfAliasFile(args.target_alias_file_required_string);
  break;
        case 'set_original_item_of_alias_file':
  result = await this.setOriginalItemOfAliasFile(args.target_alias_file_required_string, args.value_required_specifier);
  break;
        case 'get_original_item_of_alias_file_of_container':
  result = await this.getOriginalItemOfAliasFileOfContainer(args.target_alias_file_required_string, args.target_container_required_string);
  break;
        case 'set_original_item_of_alias_file_of_container':
  result = await this.setOriginalItemOfAliasFileOfContainer(args.target_alias_file_required_string, args.target_container_required_string, args.value_required_specifier);
  break;
        case 'get_original_item_of_alias_file_of_disk':
  result = await this.getOriginalItemOfAliasFileOfDisk(args.target_alias_file_required_string, args.target_disk_required_string);
  break;
        case 'set_original_item_of_alias_file_of_disk':
  result = await this.setOriginalItemOfAliasFileOfDisk(args.target_alias_file_required_string, args.target_disk_required_string, args.value_required_specifier);
  break;
        case 'get_original_item_of_alias_file_of_folder':
  result = await this.getOriginalItemOfAliasFileOfFolder(args.target_alias_file_required_string, args.target_folder_required_string);
  break;
        case 'set_original_item_of_alias_file_of_folder':
  result = await this.setOriginalItemOfAliasFileOfFolder(args.target_alias_file_required_string, args.target_folder_required_string, args.value_required_specifier);
  break;
        case 'get_original_item_of_alias_file_of_desktop_object':
  result = await this.getOriginalItemOfAliasFileOfDesktopObject(args.target_alias_file_required_string, args.target_desktop_object_required_string);
  break;
        case 'set_original_item_of_alias_file_of_desktop_object':
  result = await this.setOriginalItemOfAliasFileOfDesktopObject(args.target_alias_file_required_string, args.target_desktop_object_required_string, args.value_required_specifier);
  break;
        case 'get_original_item_of_alias_file_of_trash_object':
  result = await this.getOriginalItemOfAliasFileOfTrashObject(args.target_alias_file_required_string, args.target_trash_object_required_string);
  break;
        case 'set_original_item_of_alias_file_of_trash_object':
  result = await this.setOriginalItemOfAliasFileOfTrashObject(args.target_alias_file_required_string, args.target_trash_object_required_string, args.value_required_specifier);
  break;
        case 'get_id_of_application_file':
  result = await this.getIdOfApplicationFile(args.target_application_file_required_string);
  break;
        case 'get_id_of_application_file_of_container':
  result = await this.getIdOfApplicationFileOfContainer(args.target_application_file_required_string, args.target_container_required_string);
  break;
        case 'get_id_of_application_file_of_disk':
  result = await this.getIdOfApplicationFileOfDisk(args.target_application_file_required_string, args.target_disk_required_string);
  break;
        case 'get_id_of_application_file_of_folder':
  result = await this.getIdOfApplicationFileOfFolder(args.target_application_file_required_string, args.target_folder_required_string);
  break;
        case 'get_id_of_application_file_of_desktop_object':
  result = await this.getIdOfApplicationFileOfDesktopObject(args.target_application_file_required_string, args.target_desktop_object_required_string);
  break;
        case 'get_id_of_application_file_of_trash_object':
  result = await this.getIdOfApplicationFileOfTrashObject(args.target_application_file_required_string, args.target_trash_object_required_string);
  break;
        case 'get_suggested_size_of_application_file':
  result = await this.getSuggestedSizeOfApplicationFile(args.target_application_file_required_string);
  break;
        case 'get_suggested_size_of_application_file_of_container':
  result = await this.getSuggestedSizeOfApplicationFileOfContainer(args.target_application_file_required_string, args.target_container_required_string);
  break;
        case 'get_suggested_size_of_application_file_of_disk':
  result = await this.getSuggestedSizeOfApplicationFileOfDisk(args.target_application_file_required_string, args.target_disk_required_string);
  break;
        case 'get_suggested_size_of_application_file_of_folder':
  result = await this.getSuggestedSizeOfApplicationFileOfFolder(args.target_application_file_required_string, args.target_folder_required_string);
  break;
        case 'get_suggested_size_of_application_file_of_desktop_object':
  result = await this.getSuggestedSizeOfApplicationFileOfDesktopObject(args.target_application_file_required_string, args.target_desktop_object_required_string);
  break;
        case 'get_suggested_size_of_application_file_of_trash_object':
  result = await this.getSuggestedSizeOfApplicationFileOfTrashObject(args.target_application_file_required_string, args.target_trash_object_required_string);
  break;
        case 'get_minimum_size_of_application_file':
  result = await this.getMinimumSizeOfApplicationFile(args.target_application_file_required_string);
  break;
        case 'set_minimum_size_of_application_file':
  result = await this.setMinimumSizeOfApplicationFile(args.target_application_file_required_string, args.value_required_integer);
  break;
        case 'get_minimum_size_of_application_file_of_container':
  result = await this.getMinimumSizeOfApplicationFileOfContainer(args.target_application_file_required_string, args.target_container_required_string);
  break;
        case 'set_minimum_size_of_application_file_of_container':
  result = await this.setMinimumSizeOfApplicationFileOfContainer(args.target_application_file_required_string, args.target_container_required_string, args.value_required_integer);
  break;
        case 'get_minimum_size_of_application_file_of_disk':
  result = await this.getMinimumSizeOfApplicationFileOfDisk(args.target_application_file_required_string, args.target_disk_required_string);
  break;
        case 'set_minimum_size_of_application_file_of_disk':
  result = await this.setMinimumSizeOfApplicationFileOfDisk(args.target_application_file_required_string, args.target_disk_required_string, args.value_required_integer);
  break;
        case 'get_minimum_size_of_application_file_of_folder':
  result = await this.getMinimumSizeOfApplicationFileOfFolder(args.target_application_file_required_string, args.target_folder_required_string);
  break;
        case 'set_minimum_size_of_application_file_of_folder':
  result = await this.setMinimumSizeOfApplicationFileOfFolder(args.target_application_file_required_string, args.target_folder_required_string, args.value_required_integer);
  break;
        case 'get_minimum_size_of_application_file_of_desktop_object':
  result = await this.getMinimumSizeOfApplicationFileOfDesktopObject(args.target_application_file_required_string, args.target_desktop_object_required_string);
  break;
        case 'set_minimum_size_of_application_file_of_desktop_object':
  result = await this.setMinimumSizeOfApplicationFileOfDesktopObject(args.target_application_file_required_string, args.target_desktop_object_required_string, args.value_required_integer);
  break;
        case 'get_minimum_size_of_application_file_of_trash_object':
  result = await this.getMinimumSizeOfApplicationFileOfTrashObject(args.target_application_file_required_string, args.target_trash_object_required_string);
  break;
        case 'set_minimum_size_of_application_file_of_trash_object':
  result = await this.setMinimumSizeOfApplicationFileOfTrashObject(args.target_application_file_required_string, args.target_trash_object_required_string, args.value_required_integer);
  break;
        case 'get_preferred_size_of_application_file':
  result = await this.getPreferredSizeOfApplicationFile(args.target_application_file_required_string);
  break;
        case 'set_preferred_size_of_application_file':
  result = await this.setPreferredSizeOfApplicationFile(args.target_application_file_required_string, args.value_required_integer);
  break;
        case 'get_preferred_size_of_application_file_of_container':
  result = await this.getPreferredSizeOfApplicationFileOfContainer(args.target_application_file_required_string, args.target_container_required_string);
  break;
        case 'set_preferred_size_of_application_file_of_container':
  result = await this.setPreferredSizeOfApplicationFileOfContainer(args.target_application_file_required_string, args.target_container_required_string, args.value_required_integer);
  break;
        case 'get_preferred_size_of_application_file_of_disk':
  result = await this.getPreferredSizeOfApplicationFileOfDisk(args.target_application_file_required_string, args.target_disk_required_string);
  break;
        case 'set_preferred_size_of_application_file_of_disk':
  result = await this.setPreferredSizeOfApplicationFileOfDisk(args.target_application_file_required_string, args.target_disk_required_string, args.value_required_integer);
  break;
        case 'get_preferred_size_of_application_file_of_folder':
  result = await this.getPreferredSizeOfApplicationFileOfFolder(args.target_application_file_required_string, args.target_folder_required_string);
  break;
        case 'set_preferred_size_of_application_file_of_folder':
  result = await this.setPreferredSizeOfApplicationFileOfFolder(args.target_application_file_required_string, args.target_folder_required_string, args.value_required_integer);
  break;
        case 'get_preferred_size_of_application_file_of_desktop_object':
  result = await this.getPreferredSizeOfApplicationFileOfDesktopObject(args.target_application_file_required_string, args.target_desktop_object_required_string);
  break;
        case 'set_preferred_size_of_application_file_of_desktop_object':
  result = await this.setPreferredSizeOfApplicationFileOfDesktopObject(args.target_application_file_required_string, args.target_desktop_object_required_string, args.value_required_integer);
  break;
        case 'get_preferred_size_of_application_file_of_trash_object':
  result = await this.getPreferredSizeOfApplicationFileOfTrashObject(args.target_application_file_required_string, args.target_trash_object_required_string);
  break;
        case 'set_preferred_size_of_application_file_of_trash_object':
  result = await this.setPreferredSizeOfApplicationFileOfTrashObject(args.target_application_file_required_string, args.target_trash_object_required_string, args.value_required_integer);
  break;
        case 'get_accepts_high_level_events_of_application_file':
  result = await this.getAcceptsHighLevelEventsOfApplicationFile(args.target_application_file_required_string);
  break;
        case 'get_accepts_high_level_events_of_application_file_of_container':
  result = await this.getAcceptsHighLevelEventsOfApplicationFileOfContainer(args.target_application_file_required_string, args.target_container_required_string);
  break;
        case 'get_accepts_high_level_events_of_application_file_of_disk':
  result = await this.getAcceptsHighLevelEventsOfApplicationFileOfDisk(args.target_application_file_required_string, args.target_disk_required_string);
  break;
        case 'get_accepts_high_level_events_of_application_file_of_folder':
  result = await this.getAcceptsHighLevelEventsOfApplicationFileOfFolder(args.target_application_file_required_string, args.target_folder_required_string);
  break;
        case 'get_accepts_high_level_events_of_application_file_of_desktop':
  result = await this.getAcceptsHighLevelEventsOfApplicationFileOfDesktop(args.target_application_file_required_string, args.target_desktop_object_required_string);
  break;
        case 'get_accepts_high_level_events_of_application_file_of_trash':
  result = await this.getAcceptsHighLevelEventsOfApplicationFileOfTrash(args.target_application_file_required_string, args.target_trash_object_required_string);
  break;
        case 'get_has_scripting_terminology_of_application_file':
  result = await this.getHasScriptingTerminologyOfApplicationFile(args.target_application_file_required_string);
  break;
        case 'get_has_scripting_terminology_of_application_file_of_container':
  result = await this.getHasScriptingTerminologyOfApplicationFileOfContainer(args.target_application_file_required_string, args.target_container_required_string);
  break;
        case 'get_has_scripting_terminology_of_application_file_of_disk':
  result = await this.getHasScriptingTerminologyOfApplicationFileOfDisk(args.target_application_file_required_string, args.target_disk_required_string);
  break;
        case 'get_has_scripting_terminology_of_application_file_of_folder':
  result = await this.getHasScriptingTerminologyOfApplicationFileOfFolder(args.target_application_file_required_string, args.target_folder_required_string);
  break;
        case 'get_has_scripting_terminology_of_application_file_of_desktop':
  result = await this.getHasScriptingTerminologyOfApplicationFileOfDesktop(args.target_application_file_required_string, args.target_desktop_object_required_string);
  break;
        case 'get_has_scripting_terminology_of_application_file_of_trash':
  result = await this.getHasScriptingTerminologyOfApplicationFileOfTrash(args.target_application_file_required_string, args.target_trash_object_required_string);
  break;
        case 'get_opens_in_classic_of_application_file':
  result = await this.getOpensInClassicOfApplicationFile(args.target_application_file_required_string);
  break;
        case 'set_opens_in_classic_of_application_file':
  result = await this.setOpensInClassicOfApplicationFile(args.target_application_file_required_string, args.value_required_boolean);
  break;
        case 'get_opens_in_classic_of_application_file_of_container':
  result = await this.getOpensInClassicOfApplicationFileOfContainer(args.target_application_file_required_string, args.target_container_required_string);
  break;
        case 'set_opens_in_classic_of_application_file_of_container':
  result = await this.setOpensInClassicOfApplicationFileOfContainer(args.target_application_file_required_string, args.target_container_required_string, args.value_required_boolean);
  break;
        case 'get_opens_in_classic_of_application_file_of_disk':
  result = await this.getOpensInClassicOfApplicationFileOfDisk(args.target_application_file_required_string, args.target_disk_required_string);
  break;
        case 'set_opens_in_classic_of_application_file_of_disk':
  result = await this.setOpensInClassicOfApplicationFileOfDisk(args.target_application_file_required_string, args.target_disk_required_string, args.value_required_boolean);
  break;
        case 'get_opens_in_classic_of_application_file_of_folder':
  result = await this.getOpensInClassicOfApplicationFileOfFolder(args.target_application_file_required_string, args.target_folder_required_string);
  break;
        case 'set_opens_in_classic_of_application_file_of_folder':
  result = await this.setOpensInClassicOfApplicationFileOfFolder(args.target_application_file_required_string, args.target_folder_required_string, args.value_required_boolean);
  break;
        case 'get_opens_in_classic_of_application_file_of_desktop_object':
  result = await this.getOpensInClassicOfApplicationFileOfDesktopObject(args.target_application_file_required_string, args.target_desktop_object_required_string);
  break;
        case 'set_opens_in_classic_of_application_file_of_desktop_object':
  result = await this.setOpensInClassicOfApplicationFileOfDesktopObject(args.target_application_file_required_string, args.target_desktop_object_required_string, args.value_required_boolean);
  break;
        case 'get_opens_in_classic_of_application_file_of_trash_object':
  result = await this.getOpensInClassicOfApplicationFileOfTrashObject(args.target_application_file_required_string, args.target_trash_object_required_string);
  break;
        case 'set_opens_in_classic_of_application_file_of_trash_object':
  result = await this.setOpensInClassicOfApplicationFileOfTrashObject(args.target_application_file_required_string, args.target_trash_object_required_string, args.value_required_boolean);
  break;
        case 'get_location_of_internet_location_file':
  result = await this.getLocationOfInternetLocationFile(args.target_internet_location_file_required_string);
  break;
        case 'get_location_of_internet_location_file_of_container':
  result = await this.getLocationOfInternetLocationFileOfContainer(args.target_internet_location_file_required_string, args.target_container_required_string);
  break;
        case 'get_location_of_internet_location_file_of_disk':
  result = await this.getLocationOfInternetLocationFileOfDisk(args.target_internet_location_file_required_string, args.target_disk_required_string);
  break;
        case 'get_location_of_internet_location_file_of_folder':
  result = await this.getLocationOfInternetLocationFileOfFolder(args.target_internet_location_file_required_string, args.target_folder_required_string);
  break;
        case 'get_location_of_internet_location_file_of_desktop_object':
  result = await this.getLocationOfInternetLocationFileOfDesktopObject(args.target_internet_location_file_required_string, args.target_desktop_object_required_string);
  break;
        case 'get_location_of_internet_location_file_of_trash_object':
  result = await this.getLocationOfInternetLocationFileOfTrashObject(args.target_internet_location_file_required_string, args.target_trash_object_required_string);
  break;
        case 'get_clipping_window_of_clipping':
  result = await this.getClippingWindowOfClipping(args.target_clipping_required_string);
  break;
        case 'get_clipping_window_of_clipping_of_container':
  result = await this.getClippingWindowOfClippingOfContainer(args.target_clipping_required_string, args.target_container_required_string);
  break;
        case 'get_clipping_window_of_clipping_of_disk':
  result = await this.getClippingWindowOfClippingOfDisk(args.target_clipping_required_string, args.target_disk_required_string);
  break;
        case 'get_clipping_window_of_clipping_of_folder':
  result = await this.getClippingWindowOfClippingOfFolder(args.target_clipping_required_string, args.target_folder_required_string);
  break;
        case 'get_clipping_window_of_clipping_of_desktop_object':
  result = await this.getClippingWindowOfClippingOfDesktopObject(args.target_clipping_required_string, args.target_desktop_object_required_string);
  break;
        case 'get_clipping_window_of_clipping_of_trash_object':
  result = await this.getClippingWindowOfClippingOfTrashObject(args.target_clipping_required_string, args.target_trash_object_required_string);
  break;
        case 'get_position_of_window':
  result = await this.getPositionOfWindow(args.target_window_required_string);
  break;
        case 'set_position_of_window':
  result = await this.setPositionOfWindow(args.target_window_required_string, args.value_required_point);
  break;
        case 'get_titled_of_window':
  result = await this.getTitledOfWindow(args.target_window_required_string);
  break;
        case 'get_floating_of_window':
  result = await this.getFloatingOfWindow(args.target_window_required_string);
  break;
        case 'get_modal_of_window':
  result = await this.getModalOfWindow(args.target_window_required_string);
  break;
        case 'get_collapsed_of_window':
  result = await this.getCollapsedOfWindow(args.target_window_required_string);
  break;
        case 'set_collapsed_of_window':
  result = await this.setCollapsedOfWindow(args.target_window_required_string, args.value_required_boolean);
  break;
        case 'get_properties_of_window':
  result = await this.getPropertiesOfWindow(args.target_window_required_string);
  break;
        case 'set_properties_of_window':
  result = await this.setPropertiesOfWindow(args.target_window_required_string, args.value_required_record);
  break;
        case 'get_target_of_finder_window':
  result = await this.getTargetOfFinderWindow(args.target_finder_window_required_string);
  break;
        case 'set_target_of_finder_window':
  result = await this.setTargetOfFinderWindow(args.target_finder_window_required_string, args.value_required_specifier);
  break;
        case 'get_current_view_of_finder_window':
  result = await this.getCurrentViewOfFinderWindow(args.target_finder_window_required_string);
  break;
        case 'set_current_view_of_finder_window':
  result = await this.setCurrentViewOfFinderWindow(args.target_finder_window_required_string, args.value_required_ecvw);
  break;
        case 'get_icon_view_options_of_finder_window':
  result = await this.getIconViewOptionsOfFinderWindow(args.target_finder_window_required_string);
  break;
        case 'get_list_view_options_of_finder_window':
  result = await this.getListViewOptionsOfFinderWindow(args.target_finder_window_required_string);
  break;
        case 'get_column_view_options_of_finder_window':
  result = await this.getColumnViewOptionsOfFinderWindow(args.target_finder_window_required_string);
  break;
        case 'get_toolbar_visible_of_finder_window':
  result = await this.getToolbarVisibleOfFinderWindow(args.target_finder_window_required_string);
  break;
        case 'set_toolbar_visible_of_finder_window':
  result = await this.setToolbarVisibleOfFinderWindow(args.target_finder_window_required_string, args.value_required_boolean);
  break;
        case 'get_statusbar_visible_of_finder_window':
  result = await this.getStatusbarVisibleOfFinderWindow(args.target_finder_window_required_string);
  break;
        case 'set_statusbar_visible_of_finder_window':
  result = await this.setStatusbarVisibleOfFinderWindow(args.target_finder_window_required_string, args.value_required_boolean);
  break;
        case 'get_pathbar_visible_of_finder_window':
  result = await this.getPathbarVisibleOfFinderWindow(args.target_finder_window_required_string);
  break;
        case 'set_pathbar_visible_of_finder_window':
  result = await this.setPathbarVisibleOfFinderWindow(args.target_finder_window_required_string, args.value_required_boolean);
  break;
        case 'get_sidebar_width_of_finder_window':
  result = await this.getSidebarWidthOfFinderWindow(args.target_finder_window_required_string);
  break;
        case 'set_sidebar_width_of_finder_window':
  result = await this.setSidebarWidthOfFinderWindow(args.target_finder_window_required_string, args.value_required_integer);
  break;
        case 'get_item_of_information_window':
  result = await this.getItemOfInformationWindow(args.target_information_window_required_string);
  break;
        case 'get_current_panel_of_information_window':
  result = await this.getCurrentPanelOfInformationWindow(args.target_information_window_required_string);
  break;
        case 'set_current_panel_of_information_window':
  result = await this.setCurrentPanelOfInformationWindow(args.target_information_window_required_string, args.value_required_ipnl);
  break;
        case 'get_current_panel_of_preferences_window':
  result = await this.getCurrentPanelOfPreferencesWindow(args.target_preferences_window_required_string);
  break;
        case 'set_current_panel_of_preferences_window':
  result = await this.setCurrentPanelOfPreferencesWindow(args.target_preferences_window_required_string, args.value_required_pple);
  break;
        case 'restart':
  result = await this.restart();
  break;
        case 'shut_down':
  result = await this.shutDown();
  break;
        case 'sleep':
  result = await this.sleep();
  break;
        case 'get_desktop_picture_of_application':
  result = await this.getDesktopPictureOfApplication(args.target_application_required_string);
  break;
        case 'set_desktop_picture_of_application':
  result = await this.setDesktopPictureOfApplication(args.target_application_required_string, args.value_required_file);
  break;
        case 'get_name_of_process':
  result = await this.getNameOfProcess(args.target_process_required_string);
  break;
        case 'get_visible_of_process':
  result = await this.getVisibleOfProcess(args.target_process_required_string);
  break;
        case 'set_visible_of_process':
  result = await this.setVisibleOfProcess(args.target_process_required_string, args.value_required_boolean);
  break;
        case 'get_frontmost_of_process':
  result = await this.getFrontmostOfProcess(args.target_process_required_string);
  break;
        case 'set_frontmost_of_process':
  result = await this.setFrontmostOfProcess(args.target_process_required_string, args.value_required_boolean);
  break;
        case 'get_file_of_process':
  result = await this.getFileOfProcess(args.target_process_required_string);
  break;
        case 'get_file_type_of_process':
  result = await this.getFileTypeOfProcess(args.target_process_required_string);
  break;
        case 'get_creator_type_of_process':
  result = await this.getCreatorTypeOfProcess(args.target_process_required_string);
  break;
        case 'get_accepts_high_level_events_of_process':
  result = await this.getAcceptsHighLevelEventsOfProcess(args.target_process_required_string);
  break;
        case 'get_accepts_remote_events_of_process':
  result = await this.getAcceptsRemoteEventsOfProcess(args.target_process_required_string);
  break;
        case 'get_has_scripting_terminology_of_process':
  result = await this.getHasScriptingTerminologyOfProcess(args.target_process_required_string);
  break;
        case 'get_total_partition_size_of_process':
  result = await this.getTotalPartitionSizeOfProcess(args.target_process_required_string);
  break;
        case 'get_partition_space_used_of_process':
  result = await this.getPartitionSpaceUsedOfProcess(args.target_process_required_string);
  break;
        case 'get_application_file_of_application_process':
  result = await this.getApplicationFileOfApplicationProcess(args.target_application_process_required_string);
  break;
        case 'get_desk_accessory_file_of_desk_accessory_process':
  result = await this.getDeskAccessoryFileOfDeskAccessoryProcess(args.target_desk_accessory_process_required_string);
  break;
        case 'get_window_of_preferences':
  result = await this.getWindowOfPreferences(args.target_preferences_required_string);
  break;
        case 'get_icon_view_options_of_preferences':
  result = await this.getIconViewOptionsOfPreferences(args.target_preferences_required_string);
  break;
        case 'get_list_view_options_of_preferences':
  result = await this.getListViewOptionsOfPreferences(args.target_preferences_required_string);
  break;
        case 'get_column_view_options_of_preferences':
  result = await this.getColumnViewOptionsOfPreferences(args.target_preferences_required_string);
  break;
        case 'get_folders_spring_open_of_preferences':
  result = await this.getFoldersSpringOpenOfPreferences(args.target_preferences_required_string);
  break;
        case 'set_folders_spring_open_of_preferences':
  result = await this.setFoldersSpringOpenOfPreferences(args.target_preferences_required_string, args.value_required_boolean);
  break;
        case 'get_delay_before_springing_of_preferences':
  result = await this.getDelayBeforeSpringingOfPreferences(args.target_preferences_required_string);
  break;
        case 'set_delay_before_springing_of_preferences':
  result = await this.setDelayBeforeSpringingOfPreferences(args.target_preferences_required_string, args.value_required_real);
  break;
        case 'get_desktop_shows_hard_disks_of_preferences':
  result = await this.getDesktopShowsHardDisksOfPreferences(args.target_preferences_required_string);
  break;
        case 'set_desktop_shows_hard_disks_of_preferences':
  result = await this.setDesktopShowsHardDisksOfPreferences(args.target_preferences_required_string, args.value_required_boolean);
  break;
        case 'get_desktop_shows_external_hard_disks_of_preferences':
  result = await this.getDesktopShowsExternalHardDisksOfPreferences(args.target_preferences_required_string);
  break;
        case 'set_desktop_shows_external_hard_disks_of_preferences':
  result = await this.setDesktopShowsExternalHardDisksOfPreferences(args.target_preferences_required_string, args.value_required_boolean);
  break;
        case 'get_desktop_shows_removable_media_of_preferences':
  result = await this.getDesktopShowsRemovableMediaOfPreferences(args.target_preferences_required_string);
  break;
        case 'set_desktop_shows_removable_media_of_preferences':
  result = await this.setDesktopShowsRemovableMediaOfPreferences(args.target_preferences_required_string, args.value_required_boolean);
  break;
        case 'get_desktop_shows_connected_servers_of_preferences':
  result = await this.getDesktopShowsConnectedServersOfPreferences(args.target_preferences_required_string);
  break;
        case 'set_desktop_shows_connected_servers_of_preferences':
  result = await this.setDesktopShowsConnectedServersOfPreferences(args.target_preferences_required_string, args.value_required_boolean);
  break;
        case 'get_new_window_target_of_preferences':
  result = await this.getNewWindowTargetOfPreferences(args.target_preferences_required_string);
  break;
        case 'set_new_window_target_of_preferences':
  result = await this.setNewWindowTargetOfPreferences(args.target_preferences_required_string, args.value_required_specifier);
  break;
        case 'get_folders_open_in_new_windows_of_preferences':
  result = await this.getFoldersOpenInNewWindowsOfPreferences(args.target_preferences_required_string);
  break;
        case 'set_folders_open_in_new_windows_of_preferences':
  result = await this.setFoldersOpenInNewWindowsOfPreferences(args.target_preferences_required_string, args.value_required_boolean);
  break;
        case 'get_folders_open_in_new_tabs_of_preferences':
  result = await this.getFoldersOpenInNewTabsOfPreferences(args.target_preferences_required_string);
  break;
        case 'set_folders_open_in_new_tabs_of_preferences':
  result = await this.setFoldersOpenInNewTabsOfPreferences(args.target_preferences_required_string, args.value_required_boolean);
  break;
        case 'get_new_windows_open_in_column_view_of_preferences':
  result = await this.getNewWindowsOpenInColumnViewOfPreferences(args.target_preferences_required_string);
  break;
        case 'set_new_windows_open_in_column_view_of_preferences':
  result = await this.setNewWindowsOpenInColumnViewOfPreferences(args.target_preferences_required_string, args.value_required_boolean);
  break;
        case 'get_all_name_extensions_showing_of_preferences':
  result = await this.getAllNameExtensionsShowingOfPreferences(args.target_preferences_required_string);
  break;
        case 'set_all_name_extensions_showing_of_preferences':
  result = await this.setAllNameExtensionsShowingOfPreferences(args.target_preferences_required_string, args.value_required_boolean);
  break;
        case 'get_name_of_label':
  result = await this.getNameOfLabel(args.target_label_required_string);
  break;
        case 'set_name_of_label':
  result = await this.setNameOfLabel(args.target_label_required_string, args.value_required_text);
  break;
        case 'get_index_of_label':
  result = await this.getIndexOfLabel(args.target_label_required_string);
  break;
        case 'set_index_of_label':
  result = await this.setIndexOfLabel(args.target_label_required_string, args.value_required_integer);
  break;
        case 'get_color_of_label':
  result = await this.getColorOfLabel(args.target_label_required_string);
  break;
        case 'set_color_of_label':
  result = await this.setColorOfLabel(args.target_label_required_string, args.value_required_rgb_color);
  break;
        case 'get_large_monochrome_icon_and_mask_of_icon_family':
  result = await this.getLargeMonochromeIconAndMaskOfIconFamily(args.target_icon_family_required_string);
  break;
        case 'get_large_8_bit_mask_of_icon_family':
  result = await this.getLarge8BitMaskOfIconFamily(args.target_icon_family_required_string);
  break;
        case 'get_large_32_bit_icon_of_icon_family':
  result = await this.getLarge32BitIconOfIconFamily(args.target_icon_family_required_string);
  break;
        case 'get_large_8_bit_icon_of_icon_family':
  result = await this.getLarge8BitIconOfIconFamily(args.target_icon_family_required_string);
  break;
        case 'get_large_4_bit_icon_of_icon_family':
  result = await this.getLarge4BitIconOfIconFamily(args.target_icon_family_required_string);
  break;
        case 'get_small_monochrome_icon_and_mask_of_icon_family':
  result = await this.getSmallMonochromeIconAndMaskOfIconFamily(args.target_icon_family_required_string);
  break;
        case 'get_small_8_bit_mask_of_icon_family':
  result = await this.getSmall8BitMaskOfIconFamily(args.target_icon_family_required_string);
  break;
        case 'get_small_32_bit_icon_of_icon_family':
  result = await this.getSmall32BitIconOfIconFamily(args.target_icon_family_required_string);
  break;
        case 'get_small_8_bit_icon_of_icon_family':
  result = await this.getSmall8BitIconOfIconFamily(args.target_icon_family_required_string);
  break;
        case 'get_small_4_bit_icon_of_icon_family':
  result = await this.getSmall4BitIconOfIconFamily(args.target_icon_family_required_string);
  break;
        case 'get_arrangement_of_icon_view_options':
  result = await this.getArrangementOfIconViewOptions(args.target_icon_view_options_required_string);
  break;
        case 'set_arrangement_of_icon_view_options':
  result = await this.setArrangementOfIconViewOptions(args.target_icon_view_options_required_string, args.value_required_earr);
  break;
        case 'get_icon_size_of_icon_view_options':
  result = await this.getIconSizeOfIconViewOptions(args.target_icon_view_options_required_string);
  break;
        case 'set_icon_size_of_icon_view_options':
  result = await this.setIconSizeOfIconViewOptions(args.target_icon_view_options_required_string, args.value_required_integer);
  break;
        case 'get_shows_item_info_of_icon_view_options':
  result = await this.getShowsItemInfoOfIconViewOptions(args.target_icon_view_options_required_string);
  break;
        case 'set_shows_item_info_of_icon_view_options':
  result = await this.setShowsItemInfoOfIconViewOptions(args.target_icon_view_options_required_string, args.value_required_boolean);
  break;
        case 'get_shows_icon_preview_of_icon_view_options':
  result = await this.getShowsIconPreviewOfIconViewOptions(args.target_icon_view_options_required_string);
  break;
        case 'set_shows_icon_preview_of_icon_view_options':
  result = await this.setShowsIconPreviewOfIconViewOptions(args.target_icon_view_options_required_string, args.value_required_boolean);
  break;
        case 'get_text_size_of_icon_view_options':
  result = await this.getTextSizeOfIconViewOptions(args.target_icon_view_options_required_string);
  break;
        case 'set_text_size_of_icon_view_options':
  result = await this.setTextSizeOfIconViewOptions(args.target_icon_view_options_required_string, args.value_required_integer);
  break;
        case 'get_label_position_of_icon_view_options':
  result = await this.getLabelPositionOfIconViewOptions(args.target_icon_view_options_required_string);
  break;
        case 'set_label_position_of_icon_view_options':
  result = await this.setLabelPositionOfIconViewOptions(args.target_icon_view_options_required_string, args.value_required_epos);
  break;
        case 'get_background_picture_of_icon_view_options':
  result = await this.getBackgroundPictureOfIconViewOptions(args.target_icon_view_options_required_string);
  break;
        case 'set_background_picture_of_icon_view_options':
  result = await this.setBackgroundPictureOfIconViewOptions(args.target_icon_view_options_required_string, args.value_required_file);
  break;
        case 'get_background_color_of_icon_view_options':
  result = await this.getBackgroundColorOfIconViewOptions(args.target_icon_view_options_required_string);
  break;
        case 'set_background_color_of_icon_view_options':
  result = await this.setBackgroundColorOfIconViewOptions(args.target_icon_view_options_required_string, args.value_required_rgb_color);
  break;
        case 'get_text_size_of_column_view_options':
  result = await this.getTextSizeOfColumnViewOptions(args.target_column_view_options_required_string);
  break;
        case 'set_text_size_of_column_view_options':
  result = await this.setTextSizeOfColumnViewOptions(args.target_column_view_options_required_string, args.value_required_integer);
  break;
        case 'get_shows_icon_of_column_view_options':
  result = await this.getShowsIconOfColumnViewOptions(args.target_column_view_options_required_string);
  break;
        case 'set_shows_icon_of_column_view_options':
  result = await this.setShowsIconOfColumnViewOptions(args.target_column_view_options_required_string, args.value_required_boolean);
  break;
        case 'get_shows_icon_preview_of_column_view_options':
  result = await this.getShowsIconPreviewOfColumnViewOptions(args.target_column_view_options_required_string);
  break;
        case 'set_shows_icon_preview_of_column_view_options':
  result = await this.setShowsIconPreviewOfColumnViewOptions(args.target_column_view_options_required_string, args.value_required_boolean);
  break;
        case 'get_shows_preview_column_of_column_view_options':
  result = await this.getShowsPreviewColumnOfColumnViewOptions(args.target_column_view_options_required_string);
  break;
        case 'set_shows_preview_column_of_column_view_options':
  result = await this.setShowsPreviewColumnOfColumnViewOptions(args.target_column_view_options_required_string, args.value_required_boolean);
  break;
        case 'get_discloses_preview_pane_of_column_view_options':
  result = await this.getDisclosesPreviewPaneOfColumnViewOptions(args.target_column_view_options_required_string);
  break;
        case 'set_discloses_preview_pane_of_column_view_options':
  result = await this.setDisclosesPreviewPaneOfColumnViewOptions(args.target_column_view_options_required_string, args.value_required_boolean);
  break;
        case 'get_calculates_folder_sizes_of_list_view_options':
  result = await this.getCalculatesFolderSizesOfListViewOptions(args.target_list_view_options_required_string);
  break;
        case 'set_calculates_folder_sizes_of_list_view_options':
  result = await this.setCalculatesFolderSizesOfListViewOptions(args.target_list_view_options_required_string, args.value_required_boolean);
  break;
        case 'get_shows_icon_preview_of_list_view_options':
  result = await this.getShowsIconPreviewOfListViewOptions(args.target_list_view_options_required_string);
  break;
        case 'set_shows_icon_preview_of_list_view_options':
  result = await this.setShowsIconPreviewOfListViewOptions(args.target_list_view_options_required_string, args.value_required_boolean);
  break;
        case 'get_icon_size_of_list_view_options':
  result = await this.getIconSizeOfListViewOptions(args.target_list_view_options_required_string);
  break;
        case 'set_icon_size_of_list_view_options':
  result = await this.setIconSizeOfListViewOptions(args.target_list_view_options_required_string, args.value_required_lvic);
  break;
        case 'get_text_size_of_list_view_options':
  result = await this.getTextSizeOfListViewOptions(args.target_list_view_options_required_string);
  break;
        case 'set_text_size_of_list_view_options':
  result = await this.setTextSizeOfListViewOptions(args.target_list_view_options_required_string, args.value_required_integer);
  break;
        case 'get_sort_column_of_list_view_options':
  result = await this.getSortColumnOfListViewOptions(args.target_list_view_options_required_string);
  break;
        case 'set_sort_column_of_list_view_options':
  result = await this.setSortColumnOfListViewOptions(args.target_list_view_options_required_string, args.value_required_column);
  break;
        case 'get_uses_relative_dates_of_list_view_options':
  result = await this.getUsesRelativeDatesOfListViewOptions(args.target_list_view_options_required_string);
  break;
        case 'set_uses_relative_dates_of_list_view_options':
  result = await this.setUsesRelativeDatesOfListViewOptions(args.target_list_view_options_required_string, args.value_required_boolean);
  break;
        case 'get_index_of_column':
  result = await this.getIndexOfColumn(args.target_column_required_string);
  break;
        case 'set_index_of_column':
  result = await this.setIndexOfColumn(args.target_column_required_string, args.value_required_integer);
  break;
        case 'get_name_of_column':
  result = await this.getNameOfColumn(args.target_column_required_string);
  break;
        case 'get_sort_direction_of_column':
  result = await this.getSortDirectionOfColumn(args.target_column_required_string);
  break;
        case 'set_sort_direction_of_column':
  result = await this.setSortDirectionOfColumn(args.target_column_required_string, args.value_required_sodr);
  break;
        case 'get_width_of_column':
  result = await this.getWidthOfColumn(args.target_column_required_string);
  break;
        case 'set_width_of_column':
  result = await this.setWidthOfColumn(args.target_column_required_string, args.value_required_integer);
  break;
        case 'get_minimum_width_of_column':
  result = await this.getMinimumWidthOfColumn(args.target_column_required_string);
  break;
        case 'get_maximum_width_of_column':
  result = await this.getMaximumWidthOfColumn(args.target_column_required_string);
  break;
        case 'get_visible_of_column':
  result = await this.getVisibleOfColumn(args.target_column_required_string);
  break;
        case 'set_visible_of_column':
  result = await this.setVisibleOfColumn(args.target_column_required_string, args.value_required_boolean);
  break;
        default:
          throw new Error(`Unknown tool: ${name}`);
      }

      const response = {
        jsonrpc: '2.0',
        id: request.id,
        result: {
          content: [{
            type: 'text',
            text: JSON.stringify(result, null, 2)
          }]
        }
      };
      this.sendResponse(response);

    } catch (error) {
      console.error(`Error in tool '${request.params.name}':`, error);
      const errorResponse = {
        jsonrpc: '2.0',
        id: request.id,
        result: {
          content: [{
            type: 'text',
            text: JSON.stringify({
              success: false,
              error: error.message,
              tool: request.params.name,
              args: request.params.arguments
            }, null, 2)
          }]
        }
      };
      this.sendResponse(errorResponse);
    }
  }

  async saveForWindow(target_window_required_string, inParam_optional_file, as_optional_saveable_file_format) {
    if (!target_window_required_string || typeof target_window_required_string !== "string") {
      throw new Error("target_window_required_string is required and must be a string");
    }

    const castedWindow = castAndEscape(target_window_required_string);
    const castedIn = inParam_optional_file ? castAndEscape(inParam_optional_file) : null;
    const valueForScriptIn = castedIn && typeof castedIn === 'string' && !castedIn.startsWith('{') && !castedIn.startsWith('date') ? `"${castedIn.replace(/"/g, "'")}"` : castedIn;
    const castedAs = as_optional_saveable_file_format ? castAndEscape(as_optional_saveable_file_format) : null;
    const valueForScriptAs = castedAs && typeof castedAs === 'string' && !castedAs.startsWith('{') && !castedAs.startsWith('date') ? `"${castedAs.replace(/"/g, "'")}"` : castedAs;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedWindow}
          save it${inParam_optional_file ? ' in ' + valueForScriptIn : ''}${as_optional_saveable_file_format ? ' as ' + valueForScriptAs : ''}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      window: target_window_required_string,
      in: inParam_optional_file || null,
      as: as_optional_saveable_file_format || null
    };
  }

  async saveForDocument(target_document_required_string, inParam_optional_file, as_optional_saveable_file_format) {
    if (!target_document_required_string || typeof target_document_required_string !== "string") {
      throw new Error("target_document_required_string is required and must be a string");
    }

    const castedDocument = castAndEscape(target_document_required_string);
    const castedIn = inParam_optional_file ? castAndEscape(inParam_optional_file) : null;
    const valueForScriptIn = castedIn && typeof castedIn === 'string' && !castedIn.startsWith('{') && !castedIn.startsWith('date') ? `"${castedIn.replace(/"/g, "'")}"` : castedIn;
    const castedAs = as_optional_saveable_file_format ? castAndEscape(as_optional_saveable_file_format) : null;
    const valueForScriptAs = castedAs && typeof castedAs === 'string' && !castedAs.startsWith('{') && !castedAs.startsWith('date') ? `"${castedAs.replace(/"/g, "'")}"` : castedAs;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedDocument}
          save it${inParam_optional_file ? ' in ' + valueForScriptIn : ''}${as_optional_saveable_file_format ? ' as ' + valueForScriptAs : ''}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      document: target_document_required_string,
      in: inParam_optional_file || null,
      as: as_optional_saveable_file_format || null
    };
  }

  async getNameOfApplication(target_application_required_string) {
    if (!target_application_required_string || typeof target_application_required_string !== "string") {
      throw new Error("target_application_required_string is required and must be a string");
    }

    const escapedApplication = escapeForAppleScript(target_application_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedApplication}
          return name of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application: target_application_required_string
    };
  }

  async getFrontmostOfApplication(target_application_required_string) {
    if (!target_application_required_string || typeof target_application_required_string !== "string") {
      throw new Error("target_application_required_string is required and must be a string");
    }

    const escapedApplication = escapeForAppleScript(target_application_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedApplication}
          return frontmost of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application: target_application_required_string
    };
  }

  async getVersionOfApplication(target_application_required_string) {
    if (!target_application_required_string || typeof target_application_required_string !== "string") {
      throw new Error("target_application_required_string is required and must be a string");
    }

    const escapedApplication = escapeForAppleScript(target_application_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedApplication}
          return version of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application: target_application_required_string
    };
  }

  async getNameOfDocument(target_document_required_string) {
    if (!target_document_required_string || typeof target_document_required_string !== "string") {
      throw new Error("target_document_required_string is required and must be a string");
    }

    const escapedDocument = escapeForAppleScript(target_document_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedDocument}
          return name of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      document: target_document_required_string
    };
  }

  async getModifiedOfDocument(target_document_required_string) {
    if (!target_document_required_string || typeof target_document_required_string !== "string") {
      throw new Error("target_document_required_string is required and must be a string");
    }

    const escapedDocument = escapeForAppleScript(target_document_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedDocument}
          return modified of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      document: target_document_required_string
    };
  }

  async getFileOfDocument(target_document_required_string) {
    if (!target_document_required_string || typeof target_document_required_string !== "string") {
      throw new Error("target_document_required_string is required and must be a string");
    }

    const escapedDocument = escapeForAppleScript(target_document_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedDocument}
          return file of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      document: target_document_required_string
    };
  }

  async getNameOfWindow(target_window_required_string) {
    if (!target_window_required_string || typeof target_window_required_string !== "string") {
      throw new Error("target_window_required_string is required and must be a string");
    }

    const escapedWindow = escapeForAppleScript(target_window_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedWindow}
          return name of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      window: target_window_required_string
    };
  }

  async getIdOfWindow(target_window_required_string) {
    if (!target_window_required_string || typeof target_window_required_string !== "string") {
      throw new Error("target_window_required_string is required and must be a string");
    }

    const escapedWindow = escapeForAppleScript(target_window_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedWindow}
          return id of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      window: target_window_required_string
    };
  }

  async getIndexOfWindow(target_window_required_string) {
    if (!target_window_required_string || typeof target_window_required_string !== "string") {
      throw new Error("target_window_required_string is required and must be a string");
    }

    const escapedWindow = escapeForAppleScript(target_window_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedWindow}
          return index of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      window: target_window_required_string
    };
  }

  async setIndexOfWindow(target_window_required_string, value_required_integer) {
    if (!target_window_required_string || typeof target_window_required_string !== "string") {
      throw new Error("target_window_required_string is required and must be a string");
    }
    if (value_required_integer === undefined || value_required_integer === null) {
      throw new Error("value_required_integer is required");
    }

    const castedWindow = castAndEscape(target_window_required_string, 'string');
    const castedValue = castAndEscape(value_required_integer, 'integer');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedWindow}
          set index of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_integer,
      script: script,
      window: target_window_required_string
    };
  }

  async getBoundsOfWindow(target_window_required_string) {
    if (!target_window_required_string || typeof target_window_required_string !== "string") {
      throw new Error("target_window_required_string is required and must be a string");
    }

    const escapedWindow = escapeForAppleScript(target_window_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedWindow}
          return bounds of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      window: target_window_required_string
    };
  }

  async setBoundsOfWindow(target_window_required_string, value_required_rectangle) {
    if (!target_window_required_string || typeof target_window_required_string !== "string") {
      throw new Error("target_window_required_string is required and must be a string");
    }
    if (value_required_rectangle === undefined || value_required_rectangle === null) {
      throw new Error("value_required_rectangle is required");
    }

    const castedWindow = castAndEscape(target_window_required_string, 'string');
    const castedValue = castAndEscape(value_required_rectangle, 'rectangle');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedWindow}
          set bounds of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_rectangle,
      script: script,
      window: target_window_required_string
    };
  }

  async getCloseableOfWindow(target_window_required_string) {
    if (!target_window_required_string || typeof target_window_required_string !== "string") {
      throw new Error("target_window_required_string is required and must be a string");
    }

    const escapedWindow = escapeForAppleScript(target_window_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedWindow}
          return closeable of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      window: target_window_required_string
    };
  }

  async getMiniaturizableOfWindow(target_window_required_string) {
    if (!target_window_required_string || typeof target_window_required_string !== "string") {
      throw new Error("target_window_required_string is required and must be a string");
    }

    const escapedWindow = escapeForAppleScript(target_window_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedWindow}
          return miniaturizable of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      window: target_window_required_string
    };
  }

  async getMiniaturizedOfWindow(target_window_required_string) {
    if (!target_window_required_string || typeof target_window_required_string !== "string") {
      throw new Error("target_window_required_string is required and must be a string");
    }

    const escapedWindow = escapeForAppleScript(target_window_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedWindow}
          return miniaturized of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      window: target_window_required_string
    };
  }

  async setMiniaturizedOfWindow(target_window_required_string, value_required_boolean) {
    if (!target_window_required_string || typeof target_window_required_string !== "string") {
      throw new Error("target_window_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedWindow = castAndEscape(target_window_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedWindow}
          set miniaturized of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      window: target_window_required_string
    };
  }

  async getResizableOfWindow(target_window_required_string) {
    if (!target_window_required_string || typeof target_window_required_string !== "string") {
      throw new Error("target_window_required_string is required and must be a string");
    }

    const escapedWindow = escapeForAppleScript(target_window_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedWindow}
          return resizable of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      window: target_window_required_string
    };
  }

  async getVisibleOfWindow(target_window_required_string) {
    if (!target_window_required_string || typeof target_window_required_string !== "string") {
      throw new Error("target_window_required_string is required and must be a string");
    }

    const escapedWindow = escapeForAppleScript(target_window_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedWindow}
          return visible of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      window: target_window_required_string
    };
  }

  async setVisibleOfWindow(target_window_required_string, value_required_boolean) {
    if (!target_window_required_string || typeof target_window_required_string !== "string") {
      throw new Error("target_window_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedWindow = castAndEscape(target_window_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedWindow}
          set visible of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      window: target_window_required_string
    };
  }

  async getZoomableOfWindow(target_window_required_string) {
    if (!target_window_required_string || typeof target_window_required_string !== "string") {
      throw new Error("target_window_required_string is required and must be a string");
    }

    const escapedWindow = escapeForAppleScript(target_window_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedWindow}
          return zoomable of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      window: target_window_required_string
    };
  }

  async getZoomedOfWindow(target_window_required_string) {
    if (!target_window_required_string || typeof target_window_required_string !== "string") {
      throw new Error("target_window_required_string is required and must be a string");
    }

    const escapedWindow = escapeForAppleScript(target_window_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedWindow}
          return zoomed of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      window: target_window_required_string
    };
  }

  async setZoomedOfWindow(target_window_required_string, value_required_boolean) {
    if (!target_window_required_string || typeof target_window_required_string !== "string") {
      throw new Error("target_window_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedWindow = castAndEscape(target_window_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedWindow}
          set zoomed of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      window: target_window_required_string
    };
  }

  async getDocumentOfWindow(target_window_required_string) {
    if (!target_window_required_string || typeof target_window_required_string !== "string") {
      throw new Error("target_window_required_string is required and must be a string");
    }

    const escapedWindow = escapeForAppleScript(target_window_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedWindow}
          return document of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      window: target_window_required_string
    };
  }

  async open(direct_parameter_required_specifier, using_optional_specifier, with_properties_optional_record) {
    if (direct_parameter_required_specifier === undefined || direct_parameter_required_specifier === null) {
      throw new Error("direct_parameter_required_specifier is required");
    }

    const castedDirect_parameter = direct_parameter_required_specifier ? castAndEscape(direct_parameter_required_specifier) : null;
    const castedUsing = using_optional_specifier ? castAndEscape(using_optional_specifier) : null;
    const castedWith_properties = with_properties_optional_record ? castAndEscape(with_properties_optional_record) : null;

    const script = `
      tell application "Finder"
        open ${castedDirect_parameter}${using_optional_specifier ? ' using ' + castedUsing : ''}${with_properties_optional_record ? ' with properties ' + castedWith_properties : ''}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      direct_parameter: direct_parameter_required_specifier || null,
      using: using_optional_specifier || null,
      with_properties: with_properties_optional_record || null
    };
  }

  async printForWindow(target_window_required_string, with_properties_optional_integer_index, with_properties_optional_point_position, with_properties_optional_boolean_zoomed, with_properties_optional_boolean_collapsed, with_properties_optional_boolean_miniaturized, with_properties_optional_record_properties, with_properties_optional_rectangle_bounds) {
    if (!target_window_required_string || typeof target_window_required_string !== "string") {
      throw new Error("target_window_required_string is required and must be a string");
    }

    const castedWindow = castAndEscape(target_window_required_string);
    const castedWith_properties_optional_integer_index = with_properties_optional_integer_index ? castAndEscape(with_properties_optional_integer_index) : null;
    const castedWith_properties_optional_point_position = with_properties_optional_point_position ? castAndEscape(with_properties_optional_point_position) : null;
    const castedWith_properties_optional_boolean_zoomed = with_properties_optional_boolean_zoomed ? castAndEscape(with_properties_optional_boolean_zoomed) : null;
    const castedWith_properties_optional_boolean_collapsed = with_properties_optional_boolean_collapsed ? castAndEscape(with_properties_optional_boolean_collapsed) : null;
    const castedWith_properties_optional_boolean_miniaturized = with_properties_optional_boolean_miniaturized ? castAndEscape(with_properties_optional_boolean_miniaturized) : null;
    const castedWith_properties_optional_record_properties = with_properties_optional_record_properties ? castAndEscape(with_properties_optional_record_properties) : null;
    const castedWith_properties_optional_rectangle_bounds = with_properties_optional_rectangle_bounds ? castAndEscape(with_properties_optional_rectangle_bounds) : null;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedWindow}
          print it${with_properties_optional_record ? ' with properties ' + valueForScriptWith_properties : ''}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      window: target_window_required_string,
      index: with_properties_optional_integer_index || null,
      position: with_properties_optional_point_position || null,
      zoomed: with_properties_optional_boolean_zoomed || null,
      collapsed: with_properties_optional_boolean_collapsed || null,
      miniaturized: with_properties_optional_boolean_miniaturized || null,
      properties: with_properties_optional_record_properties || null,
      bounds: with_properties_optional_rectangle_bounds || null
    };
  }

  async printForDocument(target_document_required_string) {
    if (!target_document_required_string || typeof target_document_required_string !== "string") {
      throw new Error("target_document_required_string is required and must be a string");
    }

    const castedDocument = castAndEscape(target_document_required_string);

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedDocument}
          print it${with_properties_optional_record ? ' with properties ' + valueForScriptWith_properties : ''}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      document: target_document_required_string
    };
  }

  async quit() {
    const script = `
      tell application "Finder"
        quit
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async activate(direct_parameter_optional_specifier) {
    const castedDirect_parameter = direct_parameter_optional_specifier ? castAndEscape(direct_parameter_optional_specifier) : null;

    const script = `
      tell application "Finder"
        activate${direct_parameter_optional_specifier ? ' ' + castedDirect_parameter : ''}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      direct_parameter: direct_parameter_optional_specifier || null
    };
  }

  async closeForWindow(target_window_required_string) {
    if (!target_window_required_string || typeof target_window_required_string !== "string") {
      throw new Error("target_window_required_string is required and must be a string");
    }

    const castedWindow = castAndEscape(target_window_required_string);

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedWindow}
          close it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      window: target_window_required_string
    };
  }

  async closeForDocument(target_document_required_string) {
    if (!target_document_required_string || typeof target_document_required_string !== "string") {
      throw new Error("target_document_required_string is required and must be a string");
    }

    const castedDocument = castAndEscape(target_document_required_string);

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedDocument}
          close it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      document: target_document_required_string
    };
  }

  async countFileOfContainer(target_container_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const castedContainer = castAndEscape(target_container_required_string);

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          count each file of it 
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      container: target_container_required_string
    };
  }

  async countDeskAccessoryProcess() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        count each desk accessory process 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async countListViewOptions() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        count each list view options 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async countInternetLocationFileOfContainer(target_container_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const castedContainer = castAndEscape(target_container_required_string);

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          count each internet location file of it 
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      container: target_container_required_string
    };
  }

  async countWindow() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        count each window 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async countDesktopObject() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        count each desktop-object 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async countPreferences() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        count each preferences 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async countLabel() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        count each label 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async countFolderOfContainer(target_container_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const castedContainer = castAndEscape(target_container_required_string);

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          count each folder of it 
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      container: target_container_required_string
    };
  }

  async countProcess() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        count each process 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async countIconViewOptions() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        count each icon view options 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async countContainerOfContainer(target_container_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const castedContainer = castAndEscape(target_container_required_string);

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          count each container of it 
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      container: target_container_required_string
    };
  }

  async countFinderWindow() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        count each Finder window 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async countColumnViewOptions() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        count each column view options 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async countColumnOfListViewOptions(target_list_view_options_required_string) {
    if (!target_list_view_options_required_string || typeof target_list_view_options_required_string !== "string") {
      throw new Error("target_list_view_options_required_string is required and must be a string");
    }

    const castedListViewOptions = castAndEscape(target_list_view_options_required_string);

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedListViewOptions}
          count each column of it 
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      list_view_options: target_list_view_options_required_string
    };
  }

  async countPreferencesWindow() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        count each preferences window 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async countComputerObject() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        count each computer-object 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async countAliasFileOfContainer(target_container_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const castedContainer = castAndEscape(target_container_required_string);

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          count each alias file of it 
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      container: target_container_required_string
    };
  }

  async countApplicationFileOfContainer(target_container_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const castedContainer = castAndEscape(target_container_required_string);

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          count each application file of it 
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      container: target_container_required_string
    };
  }

  async countInformationWindow() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        count each information window 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async countItemOfContainer(target_container_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const castedContainer = castAndEscape(target_container_required_string);

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          count each item of it 
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      container: target_container_required_string
    };
  }

  async countApplicationProcess() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        count each application process 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async countClippingOfContainer(target_container_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const castedContainer = castAndEscape(target_container_required_string);

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          count each clipping of it 
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      container: target_container_required_string
    };
  }

  async countDocumentFileOfContainer(target_container_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const castedContainer = castAndEscape(target_container_required_string);

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          count each document file of it 
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      container: target_container_required_string
    };
  }

  async countAliasList() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        count each alias list 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async countDesktopWindow() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        count each desktop window 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async countIconFamily() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        count each icon family 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async countPackageOfContainer(target_container_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const castedContainer = castAndEscape(target_container_required_string);

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          count each package of it 
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      container: target_container_required_string
    };
  }

  async countClippingWindow() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        count each clipping window 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async countDocument() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        count each document 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async countTrashObject() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        count each trash-object 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async countDiskOfDesktopObject(target_desktop_object_required_string) {
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const castedDesktopObject = castAndEscape(target_desktop_object_required_string);

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedDesktopObject}
          count each disk of it 
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      desktop_object: target_desktop_object_required_string
    };
  }

  async dataSizeFileOfContainer(target_container_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const castedContainer = castAndEscape(target_container_required_string);

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          data size as file of it 
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      container: target_container_required_string
    };
  }

  async dataSizeDeskAccessoryProcess() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        data size as desk accessory process 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async dataSizeListViewOptions() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        data size as list view options 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async dataSizeInternetLocationFileOfContainer(target_container_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const castedContainer = castAndEscape(target_container_required_string);

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          data size as internet location file of it 
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      container: target_container_required_string
    };
  }

  async dataSizeWindow() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        data size as window 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async dataSizeDesktopObject() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        data size as desktop-object 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async dataSizePreferences() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        data size as preferences 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async dataSizeLabel() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        data size as label 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async dataSizeFolderOfContainer(target_container_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const castedContainer = castAndEscape(target_container_required_string);

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          data size as folder of it 
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      container: target_container_required_string
    };
  }

  async dataSizeProcess() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        data size as process 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async dataSizeIconViewOptions() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        data size as icon view options 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async dataSizeContainerOfContainer(target_container_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const castedContainer = castAndEscape(target_container_required_string);

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          data size as container of it 
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      container: target_container_required_string
    };
  }

  async dataSizeFinderWindow() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        data size as Finder window 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async dataSizeColumnViewOptions() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        data size as column view options 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async dataSizeColumnOfListViewOptions(target_list_view_options_required_string) {
    if (!target_list_view_options_required_string || typeof target_list_view_options_required_string !== "string") {
      throw new Error("target_list_view_options_required_string is required and must be a string");
    }

    const castedListViewOptions = castAndEscape(target_list_view_options_required_string);

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedListViewOptions}
          data size as column of it 
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      list_view_options: target_list_view_options_required_string
    };
  }

  async dataSizePreferencesWindow() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        data size as preferences window 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async dataSizeComputerObject() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        data size as computer-object 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async dataSizeAliasFileOfContainer(target_container_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const castedContainer = castAndEscape(target_container_required_string);

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          data size as alias file of it 
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      container: target_container_required_string
    };
  }

  async dataSizeApplicationFileOfContainer(target_container_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const castedContainer = castAndEscape(target_container_required_string);

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          data size as application file of it 
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      container: target_container_required_string
    };
  }

  async dataSizeInformationWindow() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        data size as information window 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async dataSizeItemOfContainer(target_container_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const castedContainer = castAndEscape(target_container_required_string);

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          data size as item of it 
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      container: target_container_required_string
    };
  }

  async dataSizeApplicationProcess() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        data size as application process 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async dataSizeClippingOfContainer(target_container_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const castedContainer = castAndEscape(target_container_required_string);

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          data size as clipping of it 
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      container: target_container_required_string
    };
  }

  async dataSizeDocumentFileOfContainer(target_container_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const castedContainer = castAndEscape(target_container_required_string);

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          data size as document file of it 
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      container: target_container_required_string
    };
  }

  async dataSizeAliasList() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        data size as alias list 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async dataSizeDesktopWindow() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        data size as desktop window 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async dataSizeIconFamily() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        data size as icon family 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async dataSizePackageOfContainer(target_container_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const castedContainer = castAndEscape(target_container_required_string);

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          data size as package of it 
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      container: target_container_required_string
    };
  }

  async dataSizeClippingWindow() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        data size as clipping window 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async dataSizeDocument() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        data size as document 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async dataSizeTrashObject() {


    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        data size as trash-object 
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async dataSizeDiskOfDesktopObject(target_desktop_object_required_string) {
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const castedDesktopObject = castAndEscape(target_desktop_object_required_string);

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedDesktopObject}
          data size as disk of it 
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      desktop_object: target_desktop_object_required_string
    };
  }

  async delete(direct_parameter_required_specifier) {
    if (direct_parameter_required_specifier === undefined || direct_parameter_required_specifier === null) {
      throw new Error("direct_parameter_required_specifier is required");
    }

    const castedDirect_parameter = direct_parameter_required_specifier ? castAndEscape(direct_parameter_required_specifier) : null;

    const script = `
      tell application "Finder"
        delete ${castedDirect_parameter}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      direct_parameter: direct_parameter_required_specifier || null
    };
  }

  async duplicate(direct_parameter_required_specifier, to_optional_location_specifier, replacing_optional_boolean, routing_suppressed_optional_boolean, exact_copy_optional_boolean) {
    if (direct_parameter_required_specifier === undefined || direct_parameter_required_specifier === null) {
      throw new Error("direct_parameter_required_specifier is required");
    }

    const castedDirect_parameter = direct_parameter_required_specifier ? castAndEscape(direct_parameter_required_specifier) : null;
    const castedTo = to_optional_location_specifier ? castAndEscape(to_optional_location_specifier) : null;
    const castedReplacing = replacing_optional_boolean ? castAndEscape(replacing_optional_boolean) : null;
    const castedRouting_suppressed = routing_suppressed_optional_boolean ? castAndEscape(routing_suppressed_optional_boolean) : null;
    const castedExact_copy = exact_copy_optional_boolean ? castAndEscape(exact_copy_optional_boolean) : null;

    const script = `
      tell application "Finder"
        duplicate ${castedDirect_parameter}${to_optional_location_specifier ? ' to ' + castedTo : ''}${replacing_optional_boolean ? ' replacing ' + castedReplacing : ''}${routing_suppressed_optional_boolean ? ' routing suppressed ' + castedRouting_suppressed : ''}${exact_copy_optional_boolean ? ' exact copy ' + castedExact_copy : ''}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      direct_parameter: direct_parameter_required_specifier || null,
      to: to_optional_location_specifier || null,
      replacing: replacing_optional_boolean || null,
      routing_suppressed: routing_suppressed_optional_boolean || null,
      exact_copy: exact_copy_optional_boolean || null
    };
  }

  async exists(direct_parameter_required_specifier) {
    if (direct_parameter_required_specifier === undefined || direct_parameter_required_specifier === null) {
      throw new Error("direct_parameter_required_specifier is required");
    }

    const castedDirect_parameter = direct_parameter_required_specifier ? castAndEscape(direct_parameter_required_specifier) : null;

    const script = `
      tell application "Finder"
        exists ${castedDirect_parameter}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      direct_parameter: direct_parameter_required_specifier || null
    };
  }

  async makeFileOfContainer(at_required_location_specifier_container, to_optional_specifier, with_properties_optional_boolean_stationery) {
    if (!at_required_location_specifier_container || typeof at_required_location_specifier_container !== "string") {
      throw new Error("at_required_location_specifier_container is required and must be a string");
    }

    const castedContainer = castAndEscape(at_required_location_specifier_container);
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;
    const castedWith_properties_optional_boolean_stationery = with_properties_optional_boolean_stationery ? castAndEscape(with_properties_optional_boolean_stationery) : null;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          make new file at it ${to_optional_specifier ? ' to ' + valueForScriptTo : ''}${buildPropertiesRecord([{param: 'with_properties_optional_boolean_stationery', prop: 'stationery', value: with_properties_optional_boolean_stationery, type: 'boolean'}])}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      container: at_required_location_specifier_container,
      to: to_optional_specifier || null,
      stationery: with_properties_optional_boolean_stationery || null
    };
  }

  async makeDeskAccessoryProcess(at_required_location_specifier, to_optional_specifier) {
    if (at_required_location_specifier === undefined || at_required_location_specifier === null) {
      throw new Error("at_required_location_specifier is required");
    }

    const castedAt = at_required_location_specifier ? castAndEscape(at_required_location_specifier) : null;
    const valueForScriptAt = castedAt && typeof castedAt === 'string' && !castedAt.startsWith('{') && !castedAt.startsWith('date') ? `"${castedAt.replace(/"/g, "'")}"` : castedAt;
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        make new desk accessory process  at ${valueForScriptAt}${to_optional_specifier ? ' to ' + valueForScriptTo : ''}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      at: at_required_location_specifier || null,
      to: to_optional_specifier || null
    };
  }

  async makeListViewOptions(at_required_location_specifier, to_optional_specifier, with_properties_optional_boolean_uses_relative_dates, with_properties_optional_lvic_icon_size, with_properties_optional_integer_text_size, with_properties_optional_boolean_calculates_folder_sizes, with_properties_optional_boolean_shows_icon_preview, with_properties_optional_column_sort_column) {
    if (at_required_location_specifier === undefined || at_required_location_specifier === null) {
      throw new Error("at_required_location_specifier is required");
    }

    const castedAt = at_required_location_specifier ? castAndEscape(at_required_location_specifier) : null;
    const valueForScriptAt = castedAt && typeof castedAt === 'string' && !castedAt.startsWith('{') && !castedAt.startsWith('date') ? `"${castedAt.replace(/"/g, "'")}"` : castedAt;
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;
    const castedWith_properties_optional_boolean_uses_relative_dates = with_properties_optional_boolean_uses_relative_dates ? castAndEscape(with_properties_optional_boolean_uses_relative_dates) : null;
    const castedWith_properties_optional_lvic_icon_size = with_properties_optional_lvic_icon_size ? castAndEscape(with_properties_optional_lvic_icon_size) : null;
    const castedWith_properties_optional_integer_text_size = with_properties_optional_integer_text_size ? castAndEscape(with_properties_optional_integer_text_size) : null;
    const castedWith_properties_optional_boolean_calculates_folder_sizes = with_properties_optional_boolean_calculates_folder_sizes ? castAndEscape(with_properties_optional_boolean_calculates_folder_sizes) : null;
    const castedWith_properties_optional_boolean_shows_icon_preview = with_properties_optional_boolean_shows_icon_preview ? castAndEscape(with_properties_optional_boolean_shows_icon_preview) : null;
    const castedWith_properties_optional_column_sort_column = with_properties_optional_column_sort_column ? castAndEscape(with_properties_optional_column_sort_column) : null;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        make new list view options  at ${valueForScriptAt}${to_optional_specifier ? ' to ' + valueForScriptTo : ''}${buildPropertiesRecord([{param: 'with_properties_optional_boolean_uses_relative_dates', prop: 'uses relative dates', value: with_properties_optional_boolean_uses_relative_dates, type: 'boolean'}, {param: 'with_properties_optional_lvic_icon_size', prop: 'icon size', value: with_properties_optional_lvic_icon_size, type: 'lvic'}, {param: 'with_properties_optional_integer_text_size', prop: 'text size', value: with_properties_optional_integer_text_size, type: 'integer'}, {param: 'with_properties_optional_boolean_calculates_folder_sizes', prop: 'calculates folder sizes', value: with_properties_optional_boolean_calculates_folder_sizes, type: 'boolean'}, {param: 'with_properties_optional_boolean_shows_icon_preview', prop: 'shows icon preview', value: with_properties_optional_boolean_shows_icon_preview, type: 'boolean'}, {param: 'with_properties_optional_column_sort_column', prop: 'sort column', value: with_properties_optional_column_sort_column, type: 'column'}])}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      at: at_required_location_specifier || null,
      to: to_optional_specifier || null,
      uses_relative_dates: with_properties_optional_boolean_uses_relative_dates || null,
      icon_size: with_properties_optional_lvic_icon_size || null,
      text_size: with_properties_optional_integer_text_size || null,
      calculates_folder_sizes: with_properties_optional_boolean_calculates_folder_sizes || null,
      shows_icon_preview: with_properties_optional_boolean_shows_icon_preview || null,
      sort_column: with_properties_optional_column_sort_column || null
    };
  }

  async makeInternetLocationFileOfContainer(at_required_location_specifier_container, to_optional_specifier) {
    if (!at_required_location_specifier_container || typeof at_required_location_specifier_container !== "string") {
      throw new Error("at_required_location_specifier_container is required and must be a string");
    }

    const castedContainer = castAndEscape(at_required_location_specifier_container);
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          make new internet location file at it ${to_optional_specifier ? ' to ' + valueForScriptTo : ''}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      container: at_required_location_specifier_container,
      to: to_optional_specifier || null
    };
  }

  async makeWindow(at_required_location_specifier, to_optional_specifier, with_properties_optional_integer_index, with_properties_optional_point_position, with_properties_optional_boolean_zoomed, with_properties_optional_boolean_collapsed, with_properties_optional_boolean_miniaturized, with_properties_optional_record_properties, with_properties_optional_rectangle_bounds) {
    if (at_required_location_specifier === undefined || at_required_location_specifier === null) {
      throw new Error("at_required_location_specifier is required");
    }

    const castedAt = at_required_location_specifier ? castAndEscape(at_required_location_specifier) : null;
    const valueForScriptAt = castedAt && typeof castedAt === 'string' && !castedAt.startsWith('{') && !castedAt.startsWith('date') ? `"${castedAt.replace(/"/g, "'")}"` : castedAt;
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;
    const castedWith_properties_optional_integer_index = with_properties_optional_integer_index ? castAndEscape(with_properties_optional_integer_index) : null;
    const castedWith_properties_optional_point_position = with_properties_optional_point_position ? castAndEscape(with_properties_optional_point_position) : null;
    const castedWith_properties_optional_boolean_zoomed = with_properties_optional_boolean_zoomed ? castAndEscape(with_properties_optional_boolean_zoomed) : null;
    const castedWith_properties_optional_boolean_collapsed = with_properties_optional_boolean_collapsed ? castAndEscape(with_properties_optional_boolean_collapsed) : null;
    const castedWith_properties_optional_boolean_miniaturized = with_properties_optional_boolean_miniaturized ? castAndEscape(with_properties_optional_boolean_miniaturized) : null;
    const castedWith_properties_optional_record_properties = with_properties_optional_record_properties ? castAndEscape(with_properties_optional_record_properties) : null;
    const castedWith_properties_optional_rectangle_bounds = with_properties_optional_rectangle_bounds ? castAndEscape(with_properties_optional_rectangle_bounds) : null;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        make new window  at ${valueForScriptAt}${to_optional_specifier ? ' to ' + valueForScriptTo : ''}${buildPropertiesRecord([{param: 'with_properties_optional_integer_index', prop: 'index', value: with_properties_optional_integer_index, type: 'integer'}, {param: 'with_properties_optional_point_position', prop: 'position', value: with_properties_optional_point_position, type: 'point'}, {param: 'with_properties_optional_boolean_zoomed', prop: 'zoomed', value: with_properties_optional_boolean_zoomed, type: 'boolean'}, {param: 'with_properties_optional_boolean_collapsed', prop: 'collapsed', value: with_properties_optional_boolean_collapsed, type: 'boolean'}, {param: 'with_properties_optional_boolean_miniaturized', prop: 'miniaturized', value: with_properties_optional_boolean_miniaturized, type: 'boolean'}, {param: 'with_properties_optional_record_properties', prop: 'properties', value: with_properties_optional_record_properties, type: 'record'}, {param: 'with_properties_optional_rectangle_bounds', prop: 'bounds', value: with_properties_optional_rectangle_bounds, type: 'rectangle'}])}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      at: at_required_location_specifier || null,
      to: to_optional_specifier || null,
      index: with_properties_optional_integer_index || null,
      position: with_properties_optional_point_position || null,
      zoomed: with_properties_optional_boolean_zoomed || null,
      collapsed: with_properties_optional_boolean_collapsed || null,
      miniaturized: with_properties_optional_boolean_miniaturized || null,
      properties: with_properties_optional_record_properties || null,
      bounds: with_properties_optional_rectangle_bounds || null
    };
  }

  async makeDesktopObject(at_required_location_specifier, to_optional_specifier) {
    if (at_required_location_specifier === undefined || at_required_location_specifier === null) {
      throw new Error("at_required_location_specifier is required");
    }

    const castedAt = at_required_location_specifier ? castAndEscape(at_required_location_specifier) : null;
    const valueForScriptAt = castedAt && typeof castedAt === 'string' && !castedAt.startsWith('{') && !castedAt.startsWith('date') ? `"${castedAt.replace(/"/g, "'")}"` : castedAt;
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        make new desktop-object  at ${valueForScriptAt}${to_optional_specifier ? ' to ' + valueForScriptTo : ''}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      at: at_required_location_specifier || null,
      to: to_optional_specifier || null
    };
  }

  async makePreferences(at_required_location_specifier, to_optional_specifier, with_properties_optional_real_delay_before_springing, with_properties_optional_boolean_new_windows_open_in_column_view, with_properties_optional_boolean_desktop_shows_removable_media, with_properties_optional_boolean_folders_spring_open, with_properties_optional_boolean_all_name_extensions_showing, with_properties_optional_boolean_desktop_shows_external_hard_disks, with_properties_optional_boolean_folders_open_in_new_tabs, with_properties_optional_boolean_desktop_shows_hard_disks, with_properties_optional_specifier_new_window_target, with_properties_optional_boolean_folders_open_in_new_windows, with_properties_optional_boolean_desktop_shows_connected_servers) {
    if (at_required_location_specifier === undefined || at_required_location_specifier === null) {
      throw new Error("at_required_location_specifier is required");
    }

    const castedAt = at_required_location_specifier ? castAndEscape(at_required_location_specifier) : null;
    const valueForScriptAt = castedAt && typeof castedAt === 'string' && !castedAt.startsWith('{') && !castedAt.startsWith('date') ? `"${castedAt.replace(/"/g, "'")}"` : castedAt;
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;
    const castedWith_properties_optional_real_delay_before_springing = with_properties_optional_real_delay_before_springing ? castAndEscape(with_properties_optional_real_delay_before_springing) : null;
    const castedWith_properties_optional_boolean_new_windows_open_in_column_view = with_properties_optional_boolean_new_windows_open_in_column_view ? castAndEscape(with_properties_optional_boolean_new_windows_open_in_column_view) : null;
    const castedWith_properties_optional_boolean_desktop_shows_removable_media = with_properties_optional_boolean_desktop_shows_removable_media ? castAndEscape(with_properties_optional_boolean_desktop_shows_removable_media) : null;
    const castedWith_properties_optional_boolean_folders_spring_open = with_properties_optional_boolean_folders_spring_open ? castAndEscape(with_properties_optional_boolean_folders_spring_open) : null;
    const castedWith_properties_optional_boolean_all_name_extensions_showing = with_properties_optional_boolean_all_name_extensions_showing ? castAndEscape(with_properties_optional_boolean_all_name_extensions_showing) : null;
    const castedWith_properties_optional_boolean_desktop_shows_external_hard_disks = with_properties_optional_boolean_desktop_shows_external_hard_disks ? castAndEscape(with_properties_optional_boolean_desktop_shows_external_hard_disks) : null;
    const castedWith_properties_optional_boolean_folders_open_in_new_tabs = with_properties_optional_boolean_folders_open_in_new_tabs ? castAndEscape(with_properties_optional_boolean_folders_open_in_new_tabs) : null;
    const castedWith_properties_optional_boolean_desktop_shows_hard_disks = with_properties_optional_boolean_desktop_shows_hard_disks ? castAndEscape(with_properties_optional_boolean_desktop_shows_hard_disks) : null;
    const castedWith_properties_optional_specifier_new_window_target = with_properties_optional_specifier_new_window_target ? castAndEscape(with_properties_optional_specifier_new_window_target) : null;
    const castedWith_properties_optional_boolean_folders_open_in_new_windows = with_properties_optional_boolean_folders_open_in_new_windows ? castAndEscape(with_properties_optional_boolean_folders_open_in_new_windows) : null;
    const castedWith_properties_optional_boolean_desktop_shows_connected_servers = with_properties_optional_boolean_desktop_shows_connected_servers ? castAndEscape(with_properties_optional_boolean_desktop_shows_connected_servers) : null;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        make new preferences  at ${valueForScriptAt}${to_optional_specifier ? ' to ' + valueForScriptTo : ''}${buildPropertiesRecord([{param: 'with_properties_optional_real_delay_before_springing', prop: 'delay before springing', value: with_properties_optional_real_delay_before_springing, type: 'real'}, {param: 'with_properties_optional_boolean_new_windows_open_in_column_view', prop: 'new windows open in column view', value: with_properties_optional_boolean_new_windows_open_in_column_view, type: 'boolean'}, {param: 'with_properties_optional_boolean_desktop_shows_removable_media', prop: 'desktop shows removable media', value: with_properties_optional_boolean_desktop_shows_removable_media, type: 'boolean'}, {param: 'with_properties_optional_boolean_folders_spring_open', prop: 'folders spring open', value: with_properties_optional_boolean_folders_spring_open, type: 'boolean'}, {param: 'with_properties_optional_boolean_all_name_extensions_showing', prop: 'all name extensions showing', value: with_properties_optional_boolean_all_name_extensions_showing, type: 'boolean'}, {param: 'with_properties_optional_boolean_desktop_shows_external_hard_disks', prop: 'desktop shows external hard disks', value: with_properties_optional_boolean_desktop_shows_external_hard_disks, type: 'boolean'}, {param: 'with_properties_optional_boolean_folders_open_in_new_tabs', prop: 'folders open in new tabs', value: with_properties_optional_boolean_folders_open_in_new_tabs, type: 'boolean'}, {param: 'with_properties_optional_boolean_desktop_shows_hard_disks', prop: 'desktop shows hard disks', value: with_properties_optional_boolean_desktop_shows_hard_disks, type: 'boolean'}, {param: 'with_properties_optional_specifier_new_window_target', prop: 'new window target', value: with_properties_optional_specifier_new_window_target, type: 'specifier'}, {param: 'with_properties_optional_boolean_folders_open_in_new_windows', prop: 'folders open in new windows', value: with_properties_optional_boolean_folders_open_in_new_windows, type: 'boolean'}, {param: 'with_properties_optional_boolean_desktop_shows_connected_servers', prop: 'desktop shows connected servers', value: with_properties_optional_boolean_desktop_shows_connected_servers, type: 'boolean'}])}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      at: at_required_location_specifier || null,
      to: to_optional_specifier || null,
      delay_before_springing: with_properties_optional_real_delay_before_springing || null,
      new_windows_open_in_column_view: with_properties_optional_boolean_new_windows_open_in_column_view || null,
      desktop_shows_removable_media: with_properties_optional_boolean_desktop_shows_removable_media || null,
      folders_spring_open: with_properties_optional_boolean_folders_spring_open || null,
      all_name_extensions_showing: with_properties_optional_boolean_all_name_extensions_showing || null,
      desktop_shows_external_hard_disks: with_properties_optional_boolean_desktop_shows_external_hard_disks || null,
      folders_open_in_new_tabs: with_properties_optional_boolean_folders_open_in_new_tabs || null,
      desktop_shows_hard_disks: with_properties_optional_boolean_desktop_shows_hard_disks || null,
      new_window_target: with_properties_optional_specifier_new_window_target || null,
      folders_open_in_new_windows: with_properties_optional_boolean_folders_open_in_new_windows || null,
      desktop_shows_connected_servers: with_properties_optional_boolean_desktop_shows_connected_servers || null
    };
  }

  async makeLabel(at_required_location_specifier, to_optional_specifier, with_properties_optional_text_name, with_properties_optional_integer_index, with_properties_optional_rgb_color_color) {
    if (at_required_location_specifier === undefined || at_required_location_specifier === null) {
      throw new Error("at_required_location_specifier is required");
    }

    const castedAt = at_required_location_specifier ? castAndEscape(at_required_location_specifier) : null;
    const valueForScriptAt = castedAt && typeof castedAt === 'string' && !castedAt.startsWith('{') && !castedAt.startsWith('date') ? `"${castedAt.replace(/"/g, "'")}"` : castedAt;
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;
    const castedWith_properties_optional_text_name = with_properties_optional_text_name ? castAndEscape(with_properties_optional_text_name) : null;
    const castedWith_properties_optional_integer_index = with_properties_optional_integer_index ? castAndEscape(with_properties_optional_integer_index) : null;
    const castedWith_properties_optional_rgb_color_color = with_properties_optional_rgb_color_color ? castAndEscape(with_properties_optional_rgb_color_color) : null;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        make new label  at ${valueForScriptAt}${to_optional_specifier ? ' to ' + valueForScriptTo : ''}${buildPropertiesRecord([{param: 'with_properties_optional_text_name', prop: 'name', value: with_properties_optional_text_name, type: 'text'}, {param: 'with_properties_optional_integer_index', prop: 'index', value: with_properties_optional_integer_index, type: 'integer'}, {param: 'with_properties_optional_rgb_color_color', prop: 'color', value: with_properties_optional_rgb_color_color, type: 'RGB color'}])}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      at: at_required_location_specifier || null,
      to: to_optional_specifier || null,
      name: with_properties_optional_text_name || null,
      index: with_properties_optional_integer_index || null,
      color: with_properties_optional_rgb_color_color || null
    };
  }

  async makeFolderOfContainer(at_required_location_specifier_container, to_optional_specifier) {
    if (!at_required_location_specifier_container || typeof at_required_location_specifier_container !== "string") {
      throw new Error("at_required_location_specifier_container is required and must be a string");
    }

    const castedContainer = castAndEscape(at_required_location_specifier_container);
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          make new folder at it ${to_optional_specifier ? ' to ' + valueForScriptTo : ''}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      container: at_required_location_specifier_container,
      to: to_optional_specifier || null
    };
  }

  async makeProcess(at_required_location_specifier, to_optional_specifier, with_properties_optional_boolean_visible, with_properties_optional_boolean_frontmost) {
    if (at_required_location_specifier === undefined || at_required_location_specifier === null) {
      throw new Error("at_required_location_specifier is required");
    }

    const castedAt = at_required_location_specifier ? castAndEscape(at_required_location_specifier) : null;
    const valueForScriptAt = castedAt && typeof castedAt === 'string' && !castedAt.startsWith('{') && !castedAt.startsWith('date') ? `"${castedAt.replace(/"/g, "'")}"` : castedAt;
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;
    const castedWith_properties_optional_boolean_visible = with_properties_optional_boolean_visible ? castAndEscape(with_properties_optional_boolean_visible) : null;
    const castedWith_properties_optional_boolean_frontmost = with_properties_optional_boolean_frontmost ? castAndEscape(with_properties_optional_boolean_frontmost) : null;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        make new process  at ${valueForScriptAt}${to_optional_specifier ? ' to ' + valueForScriptTo : ''}${buildPropertiesRecord([{param: 'with_properties_optional_boolean_visible', prop: 'visible', value: with_properties_optional_boolean_visible, type: 'boolean'}, {param: 'with_properties_optional_boolean_frontmost', prop: 'frontmost', value: with_properties_optional_boolean_frontmost, type: 'boolean'}])}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      at: at_required_location_specifier || null,
      to: to_optional_specifier || null,
      visible: with_properties_optional_boolean_visible || null,
      frontmost: with_properties_optional_boolean_frontmost || null
    };
  }

  async makeIconViewOptions(at_required_location_specifier, to_optional_specifier, with_properties_optional_boolean_shows_icon_preview, with_properties_optional_boolean_shows_item_info, with_properties_optional_file_background_picture, with_properties_optional_epos_label_position, with_properties_optional_earr_arrangement, with_properties_optional_rgb_color_background_color, with_properties_optional_integer_text_size, with_properties_optional_integer_icon_size) {
    if (at_required_location_specifier === undefined || at_required_location_specifier === null) {
      throw new Error("at_required_location_specifier is required");
    }

    const castedAt = at_required_location_specifier ? castAndEscape(at_required_location_specifier) : null;
    const valueForScriptAt = castedAt && typeof castedAt === 'string' && !castedAt.startsWith('{') && !castedAt.startsWith('date') ? `"${castedAt.replace(/"/g, "'")}"` : castedAt;
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;
    const castedWith_properties_optional_boolean_shows_icon_preview = with_properties_optional_boolean_shows_icon_preview ? castAndEscape(with_properties_optional_boolean_shows_icon_preview) : null;
    const castedWith_properties_optional_boolean_shows_item_info = with_properties_optional_boolean_shows_item_info ? castAndEscape(with_properties_optional_boolean_shows_item_info) : null;
    const castedWith_properties_optional_file_background_picture = with_properties_optional_file_background_picture ? castAndEscape(with_properties_optional_file_background_picture) : null;
    const castedWith_properties_optional_epos_label_position = with_properties_optional_epos_label_position ? castAndEscape(with_properties_optional_epos_label_position) : null;
    const castedWith_properties_optional_earr_arrangement = with_properties_optional_earr_arrangement ? castAndEscape(with_properties_optional_earr_arrangement) : null;
    const castedWith_properties_optional_rgb_color_background_color = with_properties_optional_rgb_color_background_color ? castAndEscape(with_properties_optional_rgb_color_background_color) : null;
    const castedWith_properties_optional_integer_text_size = with_properties_optional_integer_text_size ? castAndEscape(with_properties_optional_integer_text_size) : null;
    const castedWith_properties_optional_integer_icon_size = with_properties_optional_integer_icon_size ? castAndEscape(with_properties_optional_integer_icon_size) : null;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        make new icon view options  at ${valueForScriptAt}${to_optional_specifier ? ' to ' + valueForScriptTo : ''}${buildPropertiesRecord([{param: 'with_properties_optional_boolean_shows_icon_preview', prop: 'shows icon preview', value: with_properties_optional_boolean_shows_icon_preview, type: 'boolean'}, {param: 'with_properties_optional_boolean_shows_item_info', prop: 'shows item info', value: with_properties_optional_boolean_shows_item_info, type: 'boolean'}, {param: 'with_properties_optional_file_background_picture', prop: 'background picture', value: with_properties_optional_file_background_picture, type: 'file'}, {param: 'with_properties_optional_epos_label_position', prop: 'label position', value: with_properties_optional_epos_label_position, type: 'epos'}, {param: 'with_properties_optional_earr_arrangement', prop: 'arrangement', value: with_properties_optional_earr_arrangement, type: 'earr'}, {param: 'with_properties_optional_rgb_color_background_color', prop: 'background color', value: with_properties_optional_rgb_color_background_color, type: 'RGB color'}, {param: 'with_properties_optional_integer_text_size', prop: 'text size', value: with_properties_optional_integer_text_size, type: 'integer'}, {param: 'with_properties_optional_integer_icon_size', prop: 'icon size', value: with_properties_optional_integer_icon_size, type: 'integer'}])}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      at: at_required_location_specifier || null,
      to: to_optional_specifier || null,
      shows_icon_preview: with_properties_optional_boolean_shows_icon_preview || null,
      shows_item_info: with_properties_optional_boolean_shows_item_info || null,
      background_picture: with_properties_optional_file_background_picture || null,
      label_position: with_properties_optional_epos_label_position || null,
      arrangement: with_properties_optional_earr_arrangement || null,
      background_color: with_properties_optional_rgb_color_background_color || null,
      text_size: with_properties_optional_integer_text_size || null,
      icon_size: with_properties_optional_integer_icon_size || null
    };
  }

  async makeContainerOfContainer(at_required_location_specifier_container, to_optional_specifier, with_properties_optional_boolean_expanded, with_properties_optional_boolean_completely_expanded) {
    if (!at_required_location_specifier_container || typeof at_required_location_specifier_container !== "string") {
      throw new Error("at_required_location_specifier_container is required and must be a string");
    }

    const castedContainer = castAndEscape(at_required_location_specifier_container);
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;
    const castedWith_properties_optional_boolean_expanded = with_properties_optional_boolean_expanded ? castAndEscape(with_properties_optional_boolean_expanded) : null;
    const castedWith_properties_optional_boolean_completely_expanded = with_properties_optional_boolean_completely_expanded ? castAndEscape(with_properties_optional_boolean_completely_expanded) : null;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          make new container at it ${to_optional_specifier ? ' to ' + valueForScriptTo : ''}${buildPropertiesRecord([{param: 'with_properties_optional_boolean_expanded', prop: 'expanded', value: with_properties_optional_boolean_expanded, type: 'boolean'}, {param: 'with_properties_optional_boolean_completely_expanded', prop: 'completely expanded', value: with_properties_optional_boolean_completely_expanded, type: 'boolean'}])}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      container: at_required_location_specifier_container,
      to: to_optional_specifier || null,
      expanded: with_properties_optional_boolean_expanded || null,
      completely_expanded: with_properties_optional_boolean_completely_expanded || null
    };
  }

  async makeFinderWindow(at_required_location_specifier, to_optional_specifier, with_properties_optional_specifier_target, with_properties_optional_boolean_toolbar_visible, with_properties_optional_boolean_pathbar_visible, with_properties_optional_integer_sidebar_width, with_properties_optional_ecvw_current_view, with_properties_optional_boolean_statusbar_visible) {
    if (at_required_location_specifier === undefined || at_required_location_specifier === null) {
      throw new Error("at_required_location_specifier is required");
    }

    const castedAt = at_required_location_specifier ? castAndEscape(at_required_location_specifier) : null;
    const valueForScriptAt = castedAt && typeof castedAt === 'string' && !castedAt.startsWith('{') && !castedAt.startsWith('date') ? `"${castedAt.replace(/"/g, "'")}"` : castedAt;
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;
    const castedWith_properties_optional_specifier_target = with_properties_optional_specifier_target ? castAndEscape(with_properties_optional_specifier_target) : null;
    const castedWith_properties_optional_boolean_toolbar_visible = with_properties_optional_boolean_toolbar_visible ? castAndEscape(with_properties_optional_boolean_toolbar_visible) : null;
    const castedWith_properties_optional_boolean_pathbar_visible = with_properties_optional_boolean_pathbar_visible ? castAndEscape(with_properties_optional_boolean_pathbar_visible) : null;
    const castedWith_properties_optional_integer_sidebar_width = with_properties_optional_integer_sidebar_width ? castAndEscape(with_properties_optional_integer_sidebar_width) : null;
    const castedWith_properties_optional_ecvw_current_view = with_properties_optional_ecvw_current_view ? castAndEscape(with_properties_optional_ecvw_current_view) : null;
    const castedWith_properties_optional_boolean_statusbar_visible = with_properties_optional_boolean_statusbar_visible ? castAndEscape(with_properties_optional_boolean_statusbar_visible) : null;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        make new Finder window  at ${valueForScriptAt}${to_optional_specifier ? ' to ' + valueForScriptTo : ''}${buildPropertiesRecord([{param: 'with_properties_optional_specifier_target', prop: 'target', value: with_properties_optional_specifier_target, type: 'specifier'}, {param: 'with_properties_optional_boolean_toolbar_visible', prop: 'toolbar visible', value: with_properties_optional_boolean_toolbar_visible, type: 'boolean'}, {param: 'with_properties_optional_boolean_pathbar_visible', prop: 'pathbar visible', value: with_properties_optional_boolean_pathbar_visible, type: 'boolean'}, {param: 'with_properties_optional_integer_sidebar_width', prop: 'sidebar width', value: with_properties_optional_integer_sidebar_width, type: 'integer'}, {param: 'with_properties_optional_ecvw_current_view', prop: 'current view', value: with_properties_optional_ecvw_current_view, type: 'ecvw'}, {param: 'with_properties_optional_boolean_statusbar_visible', prop: 'statusbar visible', value: with_properties_optional_boolean_statusbar_visible, type: 'boolean'}])}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      at: at_required_location_specifier || null,
      to: to_optional_specifier || null,
      target: with_properties_optional_specifier_target || null,
      toolbar_visible: with_properties_optional_boolean_toolbar_visible || null,
      pathbar_visible: with_properties_optional_boolean_pathbar_visible || null,
      sidebar_width: with_properties_optional_integer_sidebar_width || null,
      current_view: with_properties_optional_ecvw_current_view || null,
      statusbar_visible: with_properties_optional_boolean_statusbar_visible || null
    };
  }

  async makeColumnViewOptions(at_required_location_specifier, to_optional_specifier, with_properties_optional_boolean_shows_icon, with_properties_optional_integer_text_size, with_properties_optional_boolean_shows_preview_column, with_properties_optional_boolean_shows_icon_preview, with_properties_optional_boolean_discloses_preview_pane) {
    if (at_required_location_specifier === undefined || at_required_location_specifier === null) {
      throw new Error("at_required_location_specifier is required");
    }

    const castedAt = at_required_location_specifier ? castAndEscape(at_required_location_specifier) : null;
    const valueForScriptAt = castedAt && typeof castedAt === 'string' && !castedAt.startsWith('{') && !castedAt.startsWith('date') ? `"${castedAt.replace(/"/g, "'")}"` : castedAt;
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;
    const castedWith_properties_optional_boolean_shows_icon = with_properties_optional_boolean_shows_icon ? castAndEscape(with_properties_optional_boolean_shows_icon) : null;
    const castedWith_properties_optional_integer_text_size = with_properties_optional_integer_text_size ? castAndEscape(with_properties_optional_integer_text_size) : null;
    const castedWith_properties_optional_boolean_shows_preview_column = with_properties_optional_boolean_shows_preview_column ? castAndEscape(with_properties_optional_boolean_shows_preview_column) : null;
    const castedWith_properties_optional_boolean_shows_icon_preview = with_properties_optional_boolean_shows_icon_preview ? castAndEscape(with_properties_optional_boolean_shows_icon_preview) : null;
    const castedWith_properties_optional_boolean_discloses_preview_pane = with_properties_optional_boolean_discloses_preview_pane ? castAndEscape(with_properties_optional_boolean_discloses_preview_pane) : null;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        make new column view options  at ${valueForScriptAt}${to_optional_specifier ? ' to ' + valueForScriptTo : ''}${buildPropertiesRecord([{param: 'with_properties_optional_boolean_shows_icon', prop: 'shows icon', value: with_properties_optional_boolean_shows_icon, type: 'boolean'}, {param: 'with_properties_optional_integer_text_size', prop: 'text size', value: with_properties_optional_integer_text_size, type: 'integer'}, {param: 'with_properties_optional_boolean_shows_preview_column', prop: 'shows preview column', value: with_properties_optional_boolean_shows_preview_column, type: 'boolean'}, {param: 'with_properties_optional_boolean_shows_icon_preview', prop: 'shows icon preview', value: with_properties_optional_boolean_shows_icon_preview, type: 'boolean'}, {param: 'with_properties_optional_boolean_discloses_preview_pane', prop: 'discloses preview pane', value: with_properties_optional_boolean_discloses_preview_pane, type: 'boolean'}])}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      at: at_required_location_specifier || null,
      to: to_optional_specifier || null,
      shows_icon: with_properties_optional_boolean_shows_icon || null,
      text_size: with_properties_optional_integer_text_size || null,
      shows_preview_column: with_properties_optional_boolean_shows_preview_column || null,
      shows_icon_preview: with_properties_optional_boolean_shows_icon_preview || null,
      discloses_preview_pane: with_properties_optional_boolean_discloses_preview_pane || null
    };
  }

  async makeColumnOfListViewOptions(at_required_location_specifier_list_view_options, to_optional_specifier, with_properties_optional_sodr_sort_direction, with_properties_optional_boolean_visible, with_properties_optional_integer_width, with_properties_optional_integer_index) {
    if (!at_required_location_specifier_list_view_options || typeof at_required_location_specifier_list_view_options !== "string") {
      throw new Error("at_required_location_specifier_list_view_options is required and must be a string");
    }

    const castedListViewOptions = castAndEscape(at_required_location_specifier_list_view_options);
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;
    const castedWith_properties_optional_sodr_sort_direction = with_properties_optional_sodr_sort_direction ? castAndEscape(with_properties_optional_sodr_sort_direction) : null;
    const castedWith_properties_optional_boolean_visible = with_properties_optional_boolean_visible ? castAndEscape(with_properties_optional_boolean_visible) : null;
    const castedWith_properties_optional_integer_width = with_properties_optional_integer_width ? castAndEscape(with_properties_optional_integer_width) : null;
    const castedWith_properties_optional_integer_index = with_properties_optional_integer_index ? castAndEscape(with_properties_optional_integer_index) : null;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedListViewOptions}
          make new column at it ${to_optional_specifier ? ' to ' + valueForScriptTo : ''}${buildPropertiesRecord([{param: 'with_properties_optional_sodr_sort_direction', prop: 'sort direction', value: with_properties_optional_sodr_sort_direction, type: 'sodr'}, {param: 'with_properties_optional_boolean_visible', prop: 'visible', value: with_properties_optional_boolean_visible, type: 'boolean'}, {param: 'with_properties_optional_integer_width', prop: 'width', value: with_properties_optional_integer_width, type: 'integer'}, {param: 'with_properties_optional_integer_index', prop: 'index', value: with_properties_optional_integer_index, type: 'integer'}])}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      list_view_options: at_required_location_specifier_list_view_options,
      to: to_optional_specifier || null,
      sort_direction: with_properties_optional_sodr_sort_direction || null,
      visible: with_properties_optional_boolean_visible || null,
      width: with_properties_optional_integer_width || null,
      index: with_properties_optional_integer_index || null
    };
  }

  async makePreferencesWindow(at_required_location_specifier, to_optional_specifier, with_properties_optional_pple_current_panel) {
    if (at_required_location_specifier === undefined || at_required_location_specifier === null) {
      throw new Error("at_required_location_specifier is required");
    }

    const castedAt = at_required_location_specifier ? castAndEscape(at_required_location_specifier) : null;
    const valueForScriptAt = castedAt && typeof castedAt === 'string' && !castedAt.startsWith('{') && !castedAt.startsWith('date') ? `"${castedAt.replace(/"/g, "'")}"` : castedAt;
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;
    const castedWith_properties_optional_pple_current_panel = with_properties_optional_pple_current_panel ? castAndEscape(with_properties_optional_pple_current_panel) : null;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        make new preferences window  at ${valueForScriptAt}${to_optional_specifier ? ' to ' + valueForScriptTo : ''}${buildPropertiesRecord([{param: 'with_properties_optional_pple_current_panel', prop: 'current panel', value: with_properties_optional_pple_current_panel, type: 'pple'}])}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      at: at_required_location_specifier || null,
      to: to_optional_specifier || null,
      current_panel: with_properties_optional_pple_current_panel || null
    };
  }

  async makeComputerObject(at_required_location_specifier, to_optional_specifier) {
    if (at_required_location_specifier === undefined || at_required_location_specifier === null) {
      throw new Error("at_required_location_specifier is required");
    }

    const castedAt = at_required_location_specifier ? castAndEscape(at_required_location_specifier) : null;
    const valueForScriptAt = castedAt && typeof castedAt === 'string' && !castedAt.startsWith('{') && !castedAt.startsWith('date') ? `"${castedAt.replace(/"/g, "'")}"` : castedAt;
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        make new computer-object  at ${valueForScriptAt}${to_optional_specifier ? ' to ' + valueForScriptTo : ''}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      at: at_required_location_specifier || null,
      to: to_optional_specifier || null
    };
  }

  async makeAliasFileOfContainer(at_required_location_specifier_container, to_optional_specifier, with_properties_optional_specifier_original_item) {
    if (!at_required_location_specifier_container || typeof at_required_location_specifier_container !== "string") {
      throw new Error("at_required_location_specifier_container is required and must be a string");
    }

    const castedContainer = castAndEscape(at_required_location_specifier_container);
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;
    const castedWith_properties_optional_specifier_original_item = with_properties_optional_specifier_original_item ? castAndEscape(with_properties_optional_specifier_original_item) : null;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          make new alias file at it ${to_optional_specifier ? ' to ' + valueForScriptTo : ''}${buildPropertiesRecord([{param: 'with_properties_optional_specifier_original_item', prop: 'original item', value: with_properties_optional_specifier_original_item, type: 'specifier'}])}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      container: at_required_location_specifier_container,
      to: to_optional_specifier || null,
      original_item: with_properties_optional_specifier_original_item || null
    };
  }

  async makeApplicationFileOfContainer(at_required_location_specifier_container, to_optional_specifier, with_properties_optional_integer_preferred_size, with_properties_optional_boolean_opens_in_classic, with_properties_optional_integer_minimum_size) {
    if (!at_required_location_specifier_container || typeof at_required_location_specifier_container !== "string") {
      throw new Error("at_required_location_specifier_container is required and must be a string");
    }

    const castedContainer = castAndEscape(at_required_location_specifier_container);
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;
    const castedWith_properties_optional_integer_preferred_size = with_properties_optional_integer_preferred_size ? castAndEscape(with_properties_optional_integer_preferred_size) : null;
    const castedWith_properties_optional_boolean_opens_in_classic = with_properties_optional_boolean_opens_in_classic ? castAndEscape(with_properties_optional_boolean_opens_in_classic) : null;
    const castedWith_properties_optional_integer_minimum_size = with_properties_optional_integer_minimum_size ? castAndEscape(with_properties_optional_integer_minimum_size) : null;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          make new application file at it ${to_optional_specifier ? ' to ' + valueForScriptTo : ''}${buildPropertiesRecord([{param: 'with_properties_optional_integer_preferred_size', prop: 'preferred size', value: with_properties_optional_integer_preferred_size, type: 'integer'}, {param: 'with_properties_optional_boolean_opens_in_classic', prop: 'opens in Classic', value: with_properties_optional_boolean_opens_in_classic, type: 'boolean'}, {param: 'with_properties_optional_integer_minimum_size', prop: 'minimum size', value: with_properties_optional_integer_minimum_size, type: 'integer'}])}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      container: at_required_location_specifier_container,
      to: to_optional_specifier || null,
      preferred_size: with_properties_optional_integer_preferred_size || null,
      opens_in_classic: with_properties_optional_boolean_opens_in_classic || null,
      minimum_size: with_properties_optional_integer_minimum_size || null
    };
  }

  async makeInformationWindow(at_required_location_specifier, to_optional_specifier, with_properties_optional_ipnl_current_panel) {
    if (at_required_location_specifier === undefined || at_required_location_specifier === null) {
      throw new Error("at_required_location_specifier is required");
    }

    const castedAt = at_required_location_specifier ? castAndEscape(at_required_location_specifier) : null;
    const valueForScriptAt = castedAt && typeof castedAt === 'string' && !castedAt.startsWith('{') && !castedAt.startsWith('date') ? `"${castedAt.replace(/"/g, "'")}"` : castedAt;
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;
    const castedWith_properties_optional_ipnl_current_panel = with_properties_optional_ipnl_current_panel ? castAndEscape(with_properties_optional_ipnl_current_panel) : null;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        make new information window  at ${valueForScriptAt}${to_optional_specifier ? ' to ' + valueForScriptTo : ''}${buildPropertiesRecord([{param: 'with_properties_optional_ipnl_current_panel', prop: 'current panel', value: with_properties_optional_ipnl_current_panel, type: 'ipnl'}])}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      at: at_required_location_specifier || null,
      to: to_optional_specifier || null,
      current_panel: with_properties_optional_ipnl_current_panel || null
    };
  }

  async makeItemOfContainer(at_required_location_specifier_container, to_optional_specifier, with_properties_optional_boolean_locked, with_properties_optional_point_position, with_properties_optional_priv_everyones_privileges, with_properties_optional_icon_family_icon, with_properties_optional_point_desktop_position, with_properties_optional_text_owner, with_properties_optional_priv_owner_privileges, with_properties_optional_text_name_extension, with_properties_optional_text_name, with_properties_optional_text_group, with_properties_optional_integer_label_index, with_properties_optional_rectangle_bounds, with_properties_optional_priv_group_privileges, with_properties_optional_boolean_extension_hidden, with_properties_optional_date_modification_date, with_properties_optional_record_properties, with_properties_optional_text_comment) {
    if (!at_required_location_specifier_container || typeof at_required_location_specifier_container !== "string") {
      throw new Error("at_required_location_specifier_container is required and must be a string");
    }

    const castedContainer = castAndEscape(at_required_location_specifier_container);
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;
    const castedWith_properties_optional_boolean_locked = with_properties_optional_boolean_locked ? castAndEscape(with_properties_optional_boolean_locked) : null;
    const castedWith_properties_optional_point_position = with_properties_optional_point_position ? castAndEscape(with_properties_optional_point_position) : null;
    const castedWith_properties_optional_priv_everyones_privileges = with_properties_optional_priv_everyones_privileges ? castAndEscape(with_properties_optional_priv_everyones_privileges) : null;
    const castedWith_properties_optional_icon_family_icon = with_properties_optional_icon_family_icon ? castAndEscape(with_properties_optional_icon_family_icon) : null;
    const castedWith_properties_optional_point_desktop_position = with_properties_optional_point_desktop_position ? castAndEscape(with_properties_optional_point_desktop_position) : null;
    const castedWith_properties_optional_text_owner = with_properties_optional_text_owner ? castAndEscape(with_properties_optional_text_owner) : null;
    const castedWith_properties_optional_priv_owner_privileges = with_properties_optional_priv_owner_privileges ? castAndEscape(with_properties_optional_priv_owner_privileges) : null;
    const castedWith_properties_optional_text_name_extension = with_properties_optional_text_name_extension ? castAndEscape(with_properties_optional_text_name_extension) : null;
    const castedWith_properties_optional_text_name = with_properties_optional_text_name ? castAndEscape(with_properties_optional_text_name) : null;
    const castedWith_properties_optional_text_group = with_properties_optional_text_group ? castAndEscape(with_properties_optional_text_group) : null;
    const castedWith_properties_optional_integer_label_index = with_properties_optional_integer_label_index ? castAndEscape(with_properties_optional_integer_label_index) : null;
    const castedWith_properties_optional_rectangle_bounds = with_properties_optional_rectangle_bounds ? castAndEscape(with_properties_optional_rectangle_bounds) : null;
    const castedWith_properties_optional_priv_group_privileges = with_properties_optional_priv_group_privileges ? castAndEscape(with_properties_optional_priv_group_privileges) : null;
    const castedWith_properties_optional_boolean_extension_hidden = with_properties_optional_boolean_extension_hidden ? castAndEscape(with_properties_optional_boolean_extension_hidden) : null;
    const castedWith_properties_optional_date_modification_date = with_properties_optional_date_modification_date ? castAndEscape(with_properties_optional_date_modification_date) : null;
    const castedWith_properties_optional_record_properties = with_properties_optional_record_properties ? castAndEscape(with_properties_optional_record_properties) : null;
    const castedWith_properties_optional_text_comment = with_properties_optional_text_comment ? castAndEscape(with_properties_optional_text_comment) : null;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          make new item at it ${to_optional_specifier ? ' to ' + valueForScriptTo : ''}${buildPropertiesRecord([{param: 'with_properties_optional_boolean_locked', prop: 'locked', value: with_properties_optional_boolean_locked, type: 'boolean'}, {param: 'with_properties_optional_point_position', prop: 'position', value: with_properties_optional_point_position, type: 'point'}, {param: 'with_properties_optional_priv_everyones_privileges', prop: 'everyones privileges', value: with_properties_optional_priv_everyones_privileges, type: 'priv'}, {param: 'with_properties_optional_icon_family_icon', prop: 'icon', value: with_properties_optional_icon_family_icon, type: 'icon family'}, {param: 'with_properties_optional_point_desktop_position', prop: 'desktop position', value: with_properties_optional_point_desktop_position, type: 'point'}, {param: 'with_properties_optional_text_owner', prop: 'owner', value: with_properties_optional_text_owner, type: 'text'}, {param: 'with_properties_optional_priv_owner_privileges', prop: 'owner privileges', value: with_properties_optional_priv_owner_privileges, type: 'priv'}, {param: 'with_properties_optional_text_name_extension', prop: 'name extension', value: with_properties_optional_text_name_extension, type: 'text'}, {param: 'with_properties_optional_text_name', prop: 'name', value: with_properties_optional_text_name, type: 'text'}, {param: 'with_properties_optional_text_group', prop: 'group', value: with_properties_optional_text_group, type: 'text'}, {param: 'with_properties_optional_integer_label_index', prop: 'label index', value: with_properties_optional_integer_label_index, type: 'integer'}, {param: 'with_properties_optional_rectangle_bounds', prop: 'bounds', value: with_properties_optional_rectangle_bounds, type: 'rectangle'}, {param: 'with_properties_optional_priv_group_privileges', prop: 'group privileges', value: with_properties_optional_priv_group_privileges, type: 'priv'}, {param: 'with_properties_optional_boolean_extension_hidden', prop: 'extension hidden', value: with_properties_optional_boolean_extension_hidden, type: 'boolean'}, {param: 'with_properties_optional_date_modification_date', prop: 'modification date', value: with_properties_optional_date_modification_date, type: 'date'}, {param: 'with_properties_optional_record_properties', prop: 'properties', value: with_properties_optional_record_properties, type: 'record'}, {param: 'with_properties_optional_text_comment', prop: 'comment', value: with_properties_optional_text_comment, type: 'text'}])}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      container: at_required_location_specifier_container,
      to: to_optional_specifier || null,
      locked: with_properties_optional_boolean_locked || null,
      position: with_properties_optional_point_position || null,
      everyones_privileges: with_properties_optional_priv_everyones_privileges || null,
      icon: with_properties_optional_icon_family_icon || null,
      desktop_position: with_properties_optional_point_desktop_position || null,
      owner: with_properties_optional_text_owner || null,
      owner_privileges: with_properties_optional_priv_owner_privileges || null,
      name_extension: with_properties_optional_text_name_extension || null,
      name: with_properties_optional_text_name || null,
      group: with_properties_optional_text_group || null,
      label_index: with_properties_optional_integer_label_index || null,
      bounds: with_properties_optional_rectangle_bounds || null,
      group_privileges: with_properties_optional_priv_group_privileges || null,
      extension_hidden: with_properties_optional_boolean_extension_hidden || null,
      modification_date: with_properties_optional_date_modification_date || null,
      properties: with_properties_optional_record_properties || null,
      comment: with_properties_optional_text_comment || null
    };
  }

  async makeApplicationProcess(at_required_location_specifier, to_optional_specifier) {
    if (at_required_location_specifier === undefined || at_required_location_specifier === null) {
      throw new Error("at_required_location_specifier is required");
    }

    const castedAt = at_required_location_specifier ? castAndEscape(at_required_location_specifier) : null;
    const valueForScriptAt = castedAt && typeof castedAt === 'string' && !castedAt.startsWith('{') && !castedAt.startsWith('date') ? `"${castedAt.replace(/"/g, "'")}"` : castedAt;
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        make new application process  at ${valueForScriptAt}${to_optional_specifier ? ' to ' + valueForScriptTo : ''}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      at: at_required_location_specifier || null,
      to: to_optional_specifier || null
    };
  }

  async makeClippingOfContainer(at_required_location_specifier_container, to_optional_specifier) {
    if (!at_required_location_specifier_container || typeof at_required_location_specifier_container !== "string") {
      throw new Error("at_required_location_specifier_container is required and must be a string");
    }

    const castedContainer = castAndEscape(at_required_location_specifier_container);
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          make new clipping at it ${to_optional_specifier ? ' to ' + valueForScriptTo : ''}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      container: at_required_location_specifier_container,
      to: to_optional_specifier || null
    };
  }

  async makeDocumentFileOfContainer(at_required_location_specifier_container, to_optional_specifier) {
    if (!at_required_location_specifier_container || typeof at_required_location_specifier_container !== "string") {
      throw new Error("at_required_location_specifier_container is required and must be a string");
    }

    const castedContainer = castAndEscape(at_required_location_specifier_container);
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          make new document file at it ${to_optional_specifier ? ' to ' + valueForScriptTo : ''}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      container: at_required_location_specifier_container,
      to: to_optional_specifier || null
    };
  }

  async makeAliasList(at_required_location_specifier, to_optional_specifier) {
    if (at_required_location_specifier === undefined || at_required_location_specifier === null) {
      throw new Error("at_required_location_specifier is required");
    }

    const castedAt = at_required_location_specifier ? castAndEscape(at_required_location_specifier) : null;
    const valueForScriptAt = castedAt && typeof castedAt === 'string' && !castedAt.startsWith('{') && !castedAt.startsWith('date') ? `"${castedAt.replace(/"/g, "'")}"` : castedAt;
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        make new alias list  at ${valueForScriptAt}${to_optional_specifier ? ' to ' + valueForScriptTo : ''}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      at: at_required_location_specifier || null,
      to: to_optional_specifier || null
    };
  }

  async makeDesktopWindow(at_required_location_specifier, to_optional_specifier) {
    if (at_required_location_specifier === undefined || at_required_location_specifier === null) {
      throw new Error("at_required_location_specifier is required");
    }

    const castedAt = at_required_location_specifier ? castAndEscape(at_required_location_specifier) : null;
    const valueForScriptAt = castedAt && typeof castedAt === 'string' && !castedAt.startsWith('{') && !castedAt.startsWith('date') ? `"${castedAt.replace(/"/g, "'")}"` : castedAt;
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        make new desktop window  at ${valueForScriptAt}${to_optional_specifier ? ' to ' + valueForScriptTo : ''}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      at: at_required_location_specifier || null,
      to: to_optional_specifier || null
    };
  }

  async makeIconFamily(at_required_location_specifier, to_optional_specifier) {
    if (at_required_location_specifier === undefined || at_required_location_specifier === null) {
      throw new Error("at_required_location_specifier is required");
    }

    const castedAt = at_required_location_specifier ? castAndEscape(at_required_location_specifier) : null;
    const valueForScriptAt = castedAt && typeof castedAt === 'string' && !castedAt.startsWith('{') && !castedAt.startsWith('date') ? `"${castedAt.replace(/"/g, "'")}"` : castedAt;
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        make new icon family  at ${valueForScriptAt}${to_optional_specifier ? ' to ' + valueForScriptTo : ''}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      at: at_required_location_specifier || null,
      to: to_optional_specifier || null
    };
  }

  async makePackageOfContainer(at_required_location_specifier_container, to_optional_specifier) {
    if (!at_required_location_specifier_container || typeof at_required_location_specifier_container !== "string") {
      throw new Error("at_required_location_specifier_container is required and must be a string");
    }

    const castedContainer = castAndEscape(at_required_location_specifier_container);
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          make new package at it ${to_optional_specifier ? ' to ' + valueForScriptTo : ''}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      container: at_required_location_specifier_container,
      to: to_optional_specifier || null
    };
  }

  async makeClippingWindow(at_required_location_specifier, to_optional_specifier) {
    if (at_required_location_specifier === undefined || at_required_location_specifier === null) {
      throw new Error("at_required_location_specifier is required");
    }

    const castedAt = at_required_location_specifier ? castAndEscape(at_required_location_specifier) : null;
    const valueForScriptAt = castedAt && typeof castedAt === 'string' && !castedAt.startsWith('{') && !castedAt.startsWith('date') ? `"${castedAt.replace(/"/g, "'")}"` : castedAt;
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        make new clipping window  at ${valueForScriptAt}${to_optional_specifier ? ' to ' + valueForScriptTo : ''}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      at: at_required_location_specifier || null,
      to: to_optional_specifier || null
    };
  }

  async makeDocument(at_required_location_specifier, to_optional_specifier) {
    if (at_required_location_specifier === undefined || at_required_location_specifier === null) {
      throw new Error("at_required_location_specifier is required");
    }

    const castedAt = at_required_location_specifier ? castAndEscape(at_required_location_specifier) : null;
    const valueForScriptAt = castedAt && typeof castedAt === 'string' && !castedAt.startsWith('{') && !castedAt.startsWith('date') ? `"${castedAt.replace(/"/g, "'")}"` : castedAt;
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        make new document  at ${valueForScriptAt}${to_optional_specifier ? ' to ' + valueForScriptTo : ''}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      at: at_required_location_specifier || null,
      to: to_optional_specifier || null
    };
  }

  async makeTrashObject(at_required_location_specifier, to_optional_specifier, with_properties_optional_boolean_warns_before_emptying) {
    if (at_required_location_specifier === undefined || at_required_location_specifier === null) {
      throw new Error("at_required_location_specifier is required");
    }

    const castedAt = at_required_location_specifier ? castAndEscape(at_required_location_specifier) : null;
    const valueForScriptAt = castedAt && typeof castedAt === 'string' && !castedAt.startsWith('{') && !castedAt.startsWith('date') ? `"${castedAt.replace(/"/g, "'")}"` : castedAt;
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;
    const castedWith_properties_optional_boolean_warns_before_emptying = with_properties_optional_boolean_warns_before_emptying ? castAndEscape(with_properties_optional_boolean_warns_before_emptying) : null;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        make new trash-object  at ${valueForScriptAt}${to_optional_specifier ? ' to ' + valueForScriptTo : ''}${buildPropertiesRecord([{param: 'with_properties_optional_boolean_warns_before_emptying', prop: 'warns before emptying', value: with_properties_optional_boolean_warns_before_emptying, type: 'boolean'}])}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      at: at_required_location_specifier || null,
      to: to_optional_specifier || null,
      warns_before_emptying: with_properties_optional_boolean_warns_before_emptying || null
    };
  }

  async makeDiskOfDesktopObject(at_required_location_specifier_desktop_object, to_optional_specifier, with_properties_optional_boolean_ignore_privileges) {
    if (!at_required_location_specifier_desktop_object || typeof at_required_location_specifier_desktop_object !== "string") {
      throw new Error("at_required_location_specifier_desktop_object is required and must be a string");
    }

    const castedDesktopObject = castAndEscape(at_required_location_specifier_desktop_object);
    const castedTo = to_optional_specifier ? castAndEscape(to_optional_specifier) : null;
    const valueForScriptTo = castedTo && typeof castedTo === 'string' && !castedTo.startsWith('{') && !castedTo.startsWith('date') ? `"${castedTo.replace(/"/g, "'")}"` : castedTo;
    const castedWith_properties_optional_boolean_ignore_privileges = with_properties_optional_boolean_ignore_privileges ? castAndEscape(with_properties_optional_boolean_ignore_privileges) : null;

    // Helper function to build properties record from individual property parameters
    function buildPropertiesRecord(propertyParams) {
      const definedProps = propertyParams.filter(p => p.value !== undefined && p.value !== null && p.value !== '');
      if (definedProps.length === 0) return '';
      const propStrings = definedProps.map(p => {
        const castedValue = castAndEscape(p.value, p.type || null);
        // For strings that got escaped, wrap in quotes and replace inner quotes
        if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
          return `${p.prop}:"${castedValue.replace(/"/g, "'")}"`;
        }
        // For numbers, booleans, lists, records, dates - no quotes
        return `${p.prop}:${castedValue}`;
      });
      return ` with properties {${propStrings.join(', ')}}`;
    }

    const script = `
      tell application "Finder"
        tell ${castedDesktopObject}
          make new disk at it ${to_optional_specifier ? ' to ' + valueForScriptTo : ''}${buildPropertiesRecord([{param: 'with_properties_optional_boolean_ignore_privileges', prop: 'ignore privileges', value: with_properties_optional_boolean_ignore_privileges, type: 'boolean'}])}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      desktop_object: at_required_location_specifier_desktop_object,
      to: to_optional_specifier || null,
      ignore_privileges: with_properties_optional_boolean_ignore_privileges || null
    };
  }

  async move(direct_parameter_required_specifier, to_required_location_specifier, replacing_optional_boolean, positioned_at_optional_list, routing_suppressed_optional_boolean) {
    if (direct_parameter_required_specifier === undefined || direct_parameter_required_specifier === null) {
      throw new Error("direct_parameter_required_specifier is required");
    }

    if (to_required_location_specifier === undefined || to_required_location_specifier === null) {
      throw new Error("to_required_location_specifier is required");
    }

    const castedDirect_parameter = direct_parameter_required_specifier ? castAndEscape(direct_parameter_required_specifier) : null;
    const castedTo = to_required_location_specifier ? castAndEscape(to_required_location_specifier) : null;
    const castedReplacing = replacing_optional_boolean ? castAndEscape(replacing_optional_boolean) : null;
    const castedPositioned_at = positioned_at_optional_list ? castAndEscape(positioned_at_optional_list) : null;
    const castedRouting_suppressed = routing_suppressed_optional_boolean ? castAndEscape(routing_suppressed_optional_boolean) : null;

    const script = `
      tell application "Finder"
        move ${castedDirect_parameter} to ${castedTo}${replacing_optional_boolean ? ' replacing ' + castedReplacing : ''}${positioned_at_optional_list ? ' positioned at ' + castedPositioned_at : ''}${routing_suppressed_optional_boolean ? ' routing suppressed ' + castedRouting_suppressed : ''}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      direct_parameter: direct_parameter_required_specifier || null,
      to: to_required_location_specifier || null,
      replacing: replacing_optional_boolean || null,
      positioned_at: positioned_at_optional_list || null,
      routing_suppressed: routing_suppressed_optional_boolean || null
    };
  }

  async select(direct_parameter_required_specifier) {
    if (direct_parameter_required_specifier === undefined || direct_parameter_required_specifier === null) {
      throw new Error("direct_parameter_required_specifier is required");
    }

    const castedDirect_parameter = direct_parameter_required_specifier ? castAndEscape(direct_parameter_required_specifier) : null;

    const script = `
      tell application "Finder"
        select ${castedDirect_parameter}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      direct_parameter: direct_parameter_required_specifier || null
    };
  }

  async openvirtuallocation(direct_parameter_required_text) {
    if (direct_parameter_required_text === undefined || direct_parameter_required_text === null) {
      throw new Error("direct_parameter_required_text is required");
    }

    const castedDirect_parameter = direct_parameter_required_text ? castAndEscape(direct_parameter_required_text) : null;

    const script = `
      tell application "Finder"
        openVirtualLocation "${castedDirect_parameter}"
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      direct_parameter: direct_parameter_required_text || null
    };
  }

  async copy() {
    const script = `
      tell application "Finder"
        copy
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async sort(direct_parameter_required_specifier, by_required_property) {
    if (direct_parameter_required_specifier === undefined || direct_parameter_required_specifier === null) {
      throw new Error("direct_parameter_required_specifier is required");
    }

    if (by_required_property === undefined || by_required_property === null) {
      throw new Error("by_required_property is required");
    }

    const castedDirect_parameter = direct_parameter_required_specifier ? castAndEscape(direct_parameter_required_specifier) : null;
    const castedBy = by_required_property ? castAndEscape(by_required_property) : null;

    const script = `
      tell application "Finder"
        sort ${castedDirect_parameter} by ${castedBy}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      direct_parameter: direct_parameter_required_specifier || null,
      by: by_required_property || null
    };
  }

  async getClipboardOfApplication(target_application_required_string) {
    if (!target_application_required_string || typeof target_application_required_string !== "string") {
      throw new Error("target_application_required_string is required and must be a string");
    }

    const escapedApplication = escapeForAppleScript(target_application_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedApplication}
          return clipboard of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application: target_application_required_string
    };
  }

  async getVisibleOfApplication(target_application_required_string) {
    if (!target_application_required_string || typeof target_application_required_string !== "string") {
      throw new Error("target_application_required_string is required and must be a string");
    }

    const escapedApplication = escapeForAppleScript(target_application_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedApplication}
          return visible of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application: target_application_required_string
    };
  }

  async setVisibleOfApplication(target_application_required_string, value_required_boolean) {
    if (!target_application_required_string || typeof target_application_required_string !== "string") {
      throw new Error("target_application_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedApplication = castAndEscape(target_application_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedApplication}
          set visible of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      application: target_application_required_string
    };
  }

  async getSelectionOfApplication(target_application_required_string) {
    if (!target_application_required_string || typeof target_application_required_string !== "string") {
      throw new Error("target_application_required_string is required and must be a string");
    }

    const escapedApplication = escapeForAppleScript(target_application_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedApplication}
          return selection of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application: target_application_required_string
    };
  }

  async setSelectionOfApplication(target_application_required_string, value_required_specifier) {
    if (!target_application_required_string || typeof target_application_required_string !== "string") {
      throw new Error("target_application_required_string is required and must be a string");
    }
    if (value_required_specifier === undefined || value_required_specifier === null) {
      throw new Error("value_required_specifier is required");
    }

    const castedApplication = castAndEscape(target_application_required_string, 'string');
    const castedValue = castAndEscape(value_required_specifier, 'specifier');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedApplication}
          set selection of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_specifier,
      script: script,
      application: target_application_required_string
    };
  }

  async getInsertionLocationOfApplication(target_application_required_string) {
    if (!target_application_required_string || typeof target_application_required_string !== "string") {
      throw new Error("target_application_required_string is required and must be a string");
    }

    const escapedApplication = escapeForAppleScript(target_application_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedApplication}
          return insertion location of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application: target_application_required_string
    };
  }

  async getProductVersionOfApplication(target_application_required_string) {
    if (!target_application_required_string || typeof target_application_required_string !== "string") {
      throw new Error("target_application_required_string is required and must be a string");
    }

    const escapedApplication = escapeForAppleScript(target_application_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedApplication}
          return product version of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application: target_application_required_string
    };
  }

  async getStartupDiskOfApplication(target_application_required_string) {
    if (!target_application_required_string || typeof target_application_required_string !== "string") {
      throw new Error("target_application_required_string is required and must be a string");
    }

    const escapedApplication = escapeForAppleScript(target_application_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedApplication}
          return startup disk of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application: target_application_required_string
    };
  }

  async getDesktopOfApplication(target_application_required_string) {
    if (!target_application_required_string || typeof target_application_required_string !== "string") {
      throw new Error("target_application_required_string is required and must be a string");
    }

    const escapedApplication = escapeForAppleScript(target_application_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedApplication}
          return desktop of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application: target_application_required_string
    };
  }

  async getTrashOfApplication(target_application_required_string) {
    if (!target_application_required_string || typeof target_application_required_string !== "string") {
      throw new Error("target_application_required_string is required and must be a string");
    }

    const escapedApplication = escapeForAppleScript(target_application_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedApplication}
          return trash of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application: target_application_required_string
    };
  }

  async getHomeOfApplication(target_application_required_string) {
    if (!target_application_required_string || typeof target_application_required_string !== "string") {
      throw new Error("target_application_required_string is required and must be a string");
    }

    const escapedApplication = escapeForAppleScript(target_application_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedApplication}
          return home of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application: target_application_required_string
    };
  }

  async getComputerContainerOfApplication(target_application_required_string) {
    if (!target_application_required_string || typeof target_application_required_string !== "string") {
      throw new Error("target_application_required_string is required and must be a string");
    }

    const escapedApplication = escapeForAppleScript(target_application_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedApplication}
          return computer container of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application: target_application_required_string
    };
  }

  async getFinderPreferencesOfApplication(target_application_required_string) {
    if (!target_application_required_string || typeof target_application_required_string !== "string") {
      throw new Error("target_application_required_string is required and must be a string");
    }

    const escapedApplication = escapeForAppleScript(target_application_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedApplication}
          return Finder preferences of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application: target_application_required_string
    };
  }

  async cleanUp(direct_parameter_required_specifier, by_optional_property) {
    if (direct_parameter_required_specifier === undefined || direct_parameter_required_specifier === null) {
      throw new Error("direct_parameter_required_specifier is required");
    }

    const castedDirect_parameter = direct_parameter_required_specifier ? castAndEscape(direct_parameter_required_specifier) : null;
    const castedBy = by_optional_property ? castAndEscape(by_optional_property) : null;

    const script = `
      tell application "Finder"
        clean up ${castedDirect_parameter}${by_optional_property ? ' by ' + castedBy : ''}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      direct_parameter: direct_parameter_required_specifier || null,
      by: by_optional_property || null
    };
  }

  async eject(direct_parameter_optional_specifier) {
    const castedDirect_parameter = direct_parameter_optional_specifier ? castAndEscape(direct_parameter_optional_specifier) : null;

    const script = `
      tell application "Finder"
        eject${direct_parameter_optional_specifier ? ' ' + castedDirect_parameter : ''}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      direct_parameter: direct_parameter_optional_specifier || null
    };
  }

  async empty(direct_parameter_optional_specifier, security_optional_boolean) {
    const castedDirect_parameter = direct_parameter_optional_specifier ? castAndEscape(direct_parameter_optional_specifier) : null;
    const castedSecurity = security_optional_boolean ? castAndEscape(security_optional_boolean) : null;

    const script = `
      tell application "Finder"
        empty${direct_parameter_optional_specifier ? ' ' + castedDirect_parameter : ''}${security_optional_boolean ? ' security ' + castedSecurity : ''}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      direct_parameter: direct_parameter_optional_specifier || null,
      security: security_optional_boolean || null
    };
  }

  async erase(direct_parameter_required_specifier) {
    if (direct_parameter_required_specifier === undefined || direct_parameter_required_specifier === null) {
      throw new Error("direct_parameter_required_specifier is required");
    }

    const castedDirect_parameter = direct_parameter_required_specifier ? castAndEscape(direct_parameter_required_specifier) : null;

    const script = `
      tell application "Finder"
        erase ${castedDirect_parameter}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      direct_parameter: direct_parameter_required_specifier || null
    };
  }

  async reveal(direct_parameter_required_specifier) {
    if (direct_parameter_required_specifier === undefined || direct_parameter_required_specifier === null) {
      throw new Error("direct_parameter_required_specifier is required");
    }

    const castedDirect_parameter = direct_parameter_required_specifier ? castAndEscape(direct_parameter_required_specifier) : null;

    const script = `
      tell application "Finder"
        reveal ${castedDirect_parameter}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      direct_parameter: direct_parameter_required_specifier || null
    };
  }

  async update(direct_parameter_required_specifier, necessity_optional_boolean, registering_applications_optional_boolean) {
    if (direct_parameter_required_specifier === undefined || direct_parameter_required_specifier === null) {
      throw new Error("direct_parameter_required_specifier is required");
    }

    const castedDirect_parameter = direct_parameter_required_specifier ? castAndEscape(direct_parameter_required_specifier) : null;
    const castedNecessity = necessity_optional_boolean ? castAndEscape(necessity_optional_boolean) : null;
    const castedRegistering_applications = registering_applications_optional_boolean ? castAndEscape(registering_applications_optional_boolean) : null;

    const script = `
      tell application "Finder"
        update ${castedDirect_parameter}${necessity_optional_boolean ? ' necessity ' + castedNecessity : ''}${registering_applications_optional_boolean ? ' registering applications ' + castedRegistering_applications : ''}
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script,
      direct_parameter: direct_parameter_required_specifier || null,
      necessity: necessity_optional_boolean || null,
      registering_applications: registering_applications_optional_boolean || null
    };
  }

  async getNameOfItem(target_item_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedItem}
          return name of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string
    };
  }

  async setNameOfItem(target_item_required_string, value_required_text) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (value_required_text === undefined || value_required_text === null) {
      throw new Error("value_required_text is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedValue = castAndEscape(value_required_text, 'text');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedItem}
          set name of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_text,
      script: script,
      item: target_item_required_string
    };
  }

  async getNameOfItemOfContainer(target_item_required_string, target_container_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedContainer})
          return name of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async setNameOfItemOfContainer(target_item_required_string, target_container_required_string, value_required_text) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (value_required_text === undefined || value_required_text === null) {
      throw new Error("value_required_text is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedValue = castAndEscape(value_required_text, 'text');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedContainer})
          set name of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_text,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async getNameOfItemOfDisk(target_item_required_string, target_disk_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDisk})
          return name of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async setNameOfItemOfDisk(target_item_required_string, target_disk_required_string, value_required_text) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (value_required_text === undefined || value_required_text === null) {
      throw new Error("value_required_text is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDisk = castAndEscape(target_disk_required_string, 'string');
    const castedValue = castAndEscape(value_required_text, 'text');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDisk})
          set name of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_text,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async getNameOfItemOfFolder(target_item_required_string, target_folder_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedFolder})
          return name of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async setNameOfItemOfFolder(target_item_required_string, target_folder_required_string, value_required_text) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }
    if (value_required_text === undefined || value_required_text === null) {
      throw new Error("value_required_text is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedFolder = castAndEscape(target_folder_required_string, 'string');
    const castedValue = castAndEscape(value_required_text, 'text');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedFolder})
          set name of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_text,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async getNameOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDesktopObject})
          return name of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async setNameOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string, value_required_text) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }
    if (value_required_text === undefined || value_required_text === null) {
      throw new Error("value_required_text is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDesktopObject = castAndEscape(target_desktop_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_text, 'text');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDesktopObject})
          set name of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_text,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getNameOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedTrashObject})
          return name of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async setNameOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string, value_required_text) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }
    if (value_required_text === undefined || value_required_text === null) {
      throw new Error("value_required_text is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedTrashObject = castAndEscape(target_trash_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_text, 'text');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedTrashObject})
          set name of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_text,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getDisplayedNameOfItem(target_item_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedItem}
          return displayed name of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string
    };
  }

  async getDisplayedNameOfItemOfContainer(target_item_required_string, target_container_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedContainer})
          return displayed name of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async getDisplayedNameOfItemOfDisk(target_item_required_string, target_disk_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDisk})
          return displayed name of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async getDisplayedNameOfItemOfFolder(target_item_required_string, target_folder_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedFolder})
          return displayed name of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async getDisplayedNameOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDesktopObject})
          return displayed name of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getDisplayedNameOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedTrashObject})
          return displayed name of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getNameExtensionOfItem(target_item_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedItem}
          return name extension of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string
    };
  }

  async setNameExtensionOfItem(target_item_required_string, value_required_text) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (value_required_text === undefined || value_required_text === null) {
      throw new Error("value_required_text is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedValue = castAndEscape(value_required_text, 'text');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedItem}
          set name extension of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_text,
      script: script,
      item: target_item_required_string
    };
  }

  async getNameExtensionOfItemOfContainer(target_item_required_string, target_container_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedContainer})
          return name extension of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async setNameExtensionOfItemOfContainer(target_item_required_string, target_container_required_string, value_required_text) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (value_required_text === undefined || value_required_text === null) {
      throw new Error("value_required_text is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedValue = castAndEscape(value_required_text, 'text');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedContainer})
          set name extension of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_text,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async getNameExtensionOfItemOfDisk(target_item_required_string, target_disk_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDisk})
          return name extension of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async setNameExtensionOfItemOfDisk(target_item_required_string, target_disk_required_string, value_required_text) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (value_required_text === undefined || value_required_text === null) {
      throw new Error("value_required_text is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDisk = castAndEscape(target_disk_required_string, 'string');
    const castedValue = castAndEscape(value_required_text, 'text');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDisk})
          set name extension of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_text,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async getNameExtensionOfItemOfFolder(target_item_required_string, target_folder_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedFolder})
          return name extension of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async setNameExtensionOfItemOfFolder(target_item_required_string, target_folder_required_string, value_required_text) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }
    if (value_required_text === undefined || value_required_text === null) {
      throw new Error("value_required_text is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedFolder = castAndEscape(target_folder_required_string, 'string');
    const castedValue = castAndEscape(value_required_text, 'text');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedFolder})
          set name extension of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_text,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async getNameExtensionOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDesktopObject})
          return name extension of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async setNameExtensionOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string, value_required_text) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }
    if (value_required_text === undefined || value_required_text === null) {
      throw new Error("value_required_text is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDesktopObject = castAndEscape(target_desktop_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_text, 'text');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDesktopObject})
          set name extension of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_text,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getNameExtensionOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedTrashObject})
          return name extension of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async setNameExtensionOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string, value_required_text) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }
    if (value_required_text === undefined || value_required_text === null) {
      throw new Error("value_required_text is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedTrashObject = castAndEscape(target_trash_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_text, 'text');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedTrashObject})
          set name extension of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_text,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getExtensionHiddenOfItem(target_item_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedItem}
          return extension hidden of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string
    };
  }

  async setExtensionHiddenOfItem(target_item_required_string, value_required_boolean) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedItem}
          set extension hidden of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      item: target_item_required_string
    };
  }

  async getExtensionHiddenOfItemOfContainer(target_item_required_string, target_container_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedContainer})
          return extension hidden of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async setExtensionHiddenOfItemOfContainer(target_item_required_string, target_container_required_string, value_required_boolean) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedContainer})
          set extension hidden of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async getExtensionHiddenOfItemOfDisk(target_item_required_string, target_disk_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDisk})
          return extension hidden of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async setExtensionHiddenOfItemOfDisk(target_item_required_string, target_disk_required_string, value_required_boolean) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDisk = castAndEscape(target_disk_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDisk})
          set extension hidden of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async getExtensionHiddenOfItemOfFolder(target_item_required_string, target_folder_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedFolder})
          return extension hidden of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async setExtensionHiddenOfItemOfFolder(target_item_required_string, target_folder_required_string, value_required_boolean) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedFolder = castAndEscape(target_folder_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedFolder})
          set extension hidden of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async getExtensionHiddenOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDesktopObject})
          return extension hidden of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async setExtensionHiddenOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string, value_required_boolean) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDesktopObject = castAndEscape(target_desktop_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDesktopObject})
          set extension hidden of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getExtensionHiddenOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedTrashObject})
          return extension hidden of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async setExtensionHiddenOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string, value_required_boolean) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedTrashObject = castAndEscape(target_trash_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedTrashObject})
          set extension hidden of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getIndexOfItem(target_item_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedItem}
          return index of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string
    };
  }

  async getIndexOfItemOfContainer(target_item_required_string, target_container_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedContainer})
          return index of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async getIndexOfItemOfDisk(target_item_required_string, target_disk_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDisk})
          return index of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async getIndexOfItemOfFolder(target_item_required_string, target_folder_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedFolder})
          return index of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async getIndexOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDesktopObject})
          return index of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getIndexOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedTrashObject})
          return index of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getContainerOfItem(target_item_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedItem}
          return container of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string
    };
  }

  async getContainerOfItemOfContainer(target_item_required_string, target_container_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedContainer})
          return container of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async getContainerOfItemOfDisk(target_item_required_string, target_disk_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDisk})
          return container of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async getContainerOfItemOfFolder(target_item_required_string, target_folder_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedFolder})
          return container of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async getContainerOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDesktopObject})
          return container of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getContainerOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedTrashObject})
          return container of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getDiskOfItem(target_item_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedItem}
          return disk of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string
    };
  }

  async getDiskOfItemOfContainer(target_item_required_string, target_container_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedContainer})
          return disk of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async getDiskOfItemOfDisk(target_item_required_string, target_disk_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDisk})
          return disk of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async getDiskOfItemOfFolder(target_item_required_string, target_folder_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedFolder})
          return disk of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async getDiskOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDesktopObject})
          return disk of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getDiskOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedTrashObject})
          return disk of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getPositionOfItem(target_item_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedItem}
          return position of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string
    };
  }

  async setPositionOfItem(target_item_required_string, value_required_point) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (value_required_point === undefined || value_required_point === null) {
      throw new Error("value_required_point is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedValue = castAndEscape(value_required_point, 'point');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedItem}
          set position of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_point,
      script: script,
      item: target_item_required_string
    };
  }

  async getPositionOfItemOfContainer(target_item_required_string, target_container_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedContainer})
          return position of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async setPositionOfItemOfContainer(target_item_required_string, target_container_required_string, value_required_point) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (value_required_point === undefined || value_required_point === null) {
      throw new Error("value_required_point is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedValue = castAndEscape(value_required_point, 'point');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedContainer})
          set position of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_point,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async getPositionOfItemOfDisk(target_item_required_string, target_disk_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDisk})
          return position of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async setPositionOfItemOfDisk(target_item_required_string, target_disk_required_string, value_required_point) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (value_required_point === undefined || value_required_point === null) {
      throw new Error("value_required_point is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDisk = castAndEscape(target_disk_required_string, 'string');
    const castedValue = castAndEscape(value_required_point, 'point');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDisk})
          set position of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_point,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async getPositionOfItemOfFolder(target_item_required_string, target_folder_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedFolder})
          return position of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async setPositionOfItemOfFolder(target_item_required_string, target_folder_required_string, value_required_point) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }
    if (value_required_point === undefined || value_required_point === null) {
      throw new Error("value_required_point is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedFolder = castAndEscape(target_folder_required_string, 'string');
    const castedValue = castAndEscape(value_required_point, 'point');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedFolder})
          set position of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_point,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async getPositionOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDesktopObject})
          return position of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async setPositionOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string, value_required_point) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }
    if (value_required_point === undefined || value_required_point === null) {
      throw new Error("value_required_point is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDesktopObject = castAndEscape(target_desktop_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_point, 'point');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDesktopObject})
          set position of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_point,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getPositionOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedTrashObject})
          return position of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async setPositionOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string, value_required_point) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }
    if (value_required_point === undefined || value_required_point === null) {
      throw new Error("value_required_point is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedTrashObject = castAndEscape(target_trash_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_point, 'point');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedTrashObject})
          set position of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_point,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getDesktopPositionOfItem(target_item_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedItem}
          return desktop position of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string
    };
  }

  async setDesktopPositionOfItem(target_item_required_string, value_required_point) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (value_required_point === undefined || value_required_point === null) {
      throw new Error("value_required_point is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedValue = castAndEscape(value_required_point, 'point');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedItem}
          set desktop position of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_point,
      script: script,
      item: target_item_required_string
    };
  }

  async getDesktopPositionOfItemOfContainer(target_item_required_string, target_container_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedContainer})
          return desktop position of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async setDesktopPositionOfItemOfContainer(target_item_required_string, target_container_required_string, value_required_point) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (value_required_point === undefined || value_required_point === null) {
      throw new Error("value_required_point is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedValue = castAndEscape(value_required_point, 'point');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedContainer})
          set desktop position of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_point,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async getDesktopPositionOfItemOfDisk(target_item_required_string, target_disk_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDisk})
          return desktop position of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async setDesktopPositionOfItemOfDisk(target_item_required_string, target_disk_required_string, value_required_point) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (value_required_point === undefined || value_required_point === null) {
      throw new Error("value_required_point is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDisk = castAndEscape(target_disk_required_string, 'string');
    const castedValue = castAndEscape(value_required_point, 'point');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDisk})
          set desktop position of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_point,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async getDesktopPositionOfItemOfFolder(target_item_required_string, target_folder_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedFolder})
          return desktop position of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async setDesktopPositionOfItemOfFolder(target_item_required_string, target_folder_required_string, value_required_point) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }
    if (value_required_point === undefined || value_required_point === null) {
      throw new Error("value_required_point is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedFolder = castAndEscape(target_folder_required_string, 'string');
    const castedValue = castAndEscape(value_required_point, 'point');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedFolder})
          set desktop position of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_point,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async getDesktopPositionOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDesktopObject})
          return desktop position of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async setDesktopPositionOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string, value_required_point) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }
    if (value_required_point === undefined || value_required_point === null) {
      throw new Error("value_required_point is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDesktopObject = castAndEscape(target_desktop_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_point, 'point');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDesktopObject})
          set desktop position of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_point,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getDesktopPositionOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedTrashObject})
          return desktop position of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async setDesktopPositionOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string, value_required_point) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }
    if (value_required_point === undefined || value_required_point === null) {
      throw new Error("value_required_point is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedTrashObject = castAndEscape(target_trash_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_point, 'point');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedTrashObject})
          set desktop position of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_point,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getBoundsOfItem(target_item_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedItem}
          return bounds of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string
    };
  }

  async setBoundsOfItem(target_item_required_string, value_required_rectangle) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (value_required_rectangle === undefined || value_required_rectangle === null) {
      throw new Error("value_required_rectangle is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedValue = castAndEscape(value_required_rectangle, 'rectangle');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedItem}
          set bounds of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_rectangle,
      script: script,
      item: target_item_required_string
    };
  }

  async getBoundsOfItemOfContainer(target_item_required_string, target_container_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedContainer})
          return bounds of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async setBoundsOfItemOfContainer(target_item_required_string, target_container_required_string, value_required_rectangle) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (value_required_rectangle === undefined || value_required_rectangle === null) {
      throw new Error("value_required_rectangle is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedValue = castAndEscape(value_required_rectangle, 'rectangle');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedContainer})
          set bounds of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_rectangle,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async getBoundsOfItemOfDisk(target_item_required_string, target_disk_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDisk})
          return bounds of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async setBoundsOfItemOfDisk(target_item_required_string, target_disk_required_string, value_required_rectangle) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (value_required_rectangle === undefined || value_required_rectangle === null) {
      throw new Error("value_required_rectangle is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDisk = castAndEscape(target_disk_required_string, 'string');
    const castedValue = castAndEscape(value_required_rectangle, 'rectangle');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDisk})
          set bounds of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_rectangle,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async getBoundsOfItemOfFolder(target_item_required_string, target_folder_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedFolder})
          return bounds of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async setBoundsOfItemOfFolder(target_item_required_string, target_folder_required_string, value_required_rectangle) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }
    if (value_required_rectangle === undefined || value_required_rectangle === null) {
      throw new Error("value_required_rectangle is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedFolder = castAndEscape(target_folder_required_string, 'string');
    const castedValue = castAndEscape(value_required_rectangle, 'rectangle');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedFolder})
          set bounds of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_rectangle,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async getBoundsOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDesktopObject})
          return bounds of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async setBoundsOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string, value_required_rectangle) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }
    if (value_required_rectangle === undefined || value_required_rectangle === null) {
      throw new Error("value_required_rectangle is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDesktopObject = castAndEscape(target_desktop_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_rectangle, 'rectangle');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDesktopObject})
          set bounds of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_rectangle,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getBoundsOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedTrashObject})
          return bounds of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async setBoundsOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string, value_required_rectangle) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }
    if (value_required_rectangle === undefined || value_required_rectangle === null) {
      throw new Error("value_required_rectangle is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedTrashObject = castAndEscape(target_trash_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_rectangle, 'rectangle');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedTrashObject})
          set bounds of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_rectangle,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getLabelIndexOfItem(target_item_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedItem}
          return label index of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string
    };
  }

  async setLabelIndexOfItem(target_item_required_string, value_required_integer) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (value_required_integer === undefined || value_required_integer === null) {
      throw new Error("value_required_integer is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedValue = castAndEscape(value_required_integer, 'integer');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedItem}
          set label index of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_integer,
      script: script,
      item: target_item_required_string
    };
  }

  async getLabelIndexOfItemOfContainer(target_item_required_string, target_container_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedContainer})
          return label index of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async setLabelIndexOfItemOfContainer(target_item_required_string, target_container_required_string, value_required_integer) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (value_required_integer === undefined || value_required_integer === null) {
      throw new Error("value_required_integer is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedValue = castAndEscape(value_required_integer, 'integer');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedContainer})
          set label index of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_integer,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async getLabelIndexOfItemOfDisk(target_item_required_string, target_disk_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDisk})
          return label index of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async setLabelIndexOfItemOfDisk(target_item_required_string, target_disk_required_string, value_required_integer) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (value_required_integer === undefined || value_required_integer === null) {
      throw new Error("value_required_integer is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDisk = castAndEscape(target_disk_required_string, 'string');
    const castedValue = castAndEscape(value_required_integer, 'integer');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDisk})
          set label index of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_integer,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async getLabelIndexOfItemOfFolder(target_item_required_string, target_folder_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedFolder})
          return label index of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async setLabelIndexOfItemOfFolder(target_item_required_string, target_folder_required_string, value_required_integer) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }
    if (value_required_integer === undefined || value_required_integer === null) {
      throw new Error("value_required_integer is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedFolder = castAndEscape(target_folder_required_string, 'string');
    const castedValue = castAndEscape(value_required_integer, 'integer');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedFolder})
          set label index of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_integer,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async getLabelIndexOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDesktopObject})
          return label index of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async setLabelIndexOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string, value_required_integer) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }
    if (value_required_integer === undefined || value_required_integer === null) {
      throw new Error("value_required_integer is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDesktopObject = castAndEscape(target_desktop_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_integer, 'integer');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDesktopObject})
          set label index of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_integer,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getLabelIndexOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedTrashObject})
          return label index of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async setLabelIndexOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string, value_required_integer) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }
    if (value_required_integer === undefined || value_required_integer === null) {
      throw new Error("value_required_integer is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedTrashObject = castAndEscape(target_trash_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_integer, 'integer');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedTrashObject})
          set label index of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_integer,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getLockedOfItem(target_item_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedItem}
          return locked of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string
    };
  }

  async setLockedOfItem(target_item_required_string, value_required_boolean) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedItem}
          set locked of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      item: target_item_required_string
    };
  }

  async getLockedOfItemOfContainer(target_item_required_string, target_container_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedContainer})
          return locked of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async setLockedOfItemOfContainer(target_item_required_string, target_container_required_string, value_required_boolean) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedContainer})
          set locked of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async getLockedOfItemOfDisk(target_item_required_string, target_disk_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDisk})
          return locked of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async setLockedOfItemOfDisk(target_item_required_string, target_disk_required_string, value_required_boolean) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDisk = castAndEscape(target_disk_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDisk})
          set locked of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async getLockedOfItemOfFolder(target_item_required_string, target_folder_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedFolder})
          return locked of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async setLockedOfItemOfFolder(target_item_required_string, target_folder_required_string, value_required_boolean) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedFolder = castAndEscape(target_folder_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedFolder})
          set locked of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async getLockedOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDesktopObject})
          return locked of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async setLockedOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string, value_required_boolean) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDesktopObject = castAndEscape(target_desktop_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDesktopObject})
          set locked of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getLockedOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedTrashObject})
          return locked of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async setLockedOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string, value_required_boolean) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedTrashObject = castAndEscape(target_trash_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedTrashObject})
          set locked of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getKindOfItem(target_item_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedItem}
          return kind of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string
    };
  }

  async getKindOfItemOfContainer(target_item_required_string, target_container_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedContainer})
          return kind of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async getKindOfItemOfDisk(target_item_required_string, target_disk_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDisk})
          return kind of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async getKindOfItemOfFolder(target_item_required_string, target_folder_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedFolder})
          return kind of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async getKindOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDesktopObject})
          return kind of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getKindOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedTrashObject})
          return kind of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getDescriptionOfItem(target_item_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedItem}
          return description of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string
    };
  }

  async getDescriptionOfItemOfContainer(target_item_required_string, target_container_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedContainer})
          return description of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async getDescriptionOfItemOfDisk(target_item_required_string, target_disk_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDisk})
          return description of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async getDescriptionOfItemOfFolder(target_item_required_string, target_folder_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedFolder})
          return description of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async getDescriptionOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDesktopObject})
          return description of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getDescriptionOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedTrashObject})
          return description of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getCommentOfItem(target_item_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedItem}
          return comment of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string
    };
  }

  async setCommentOfItem(target_item_required_string, value_required_text) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (value_required_text === undefined || value_required_text === null) {
      throw new Error("value_required_text is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedValue = castAndEscape(value_required_text, 'text');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedItem}
          set comment of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_text,
      script: script,
      item: target_item_required_string
    };
  }

  async getCommentOfItemOfContainer(target_item_required_string, target_container_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedContainer})
          return comment of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async setCommentOfItemOfContainer(target_item_required_string, target_container_required_string, value_required_text) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (value_required_text === undefined || value_required_text === null) {
      throw new Error("value_required_text is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedValue = castAndEscape(value_required_text, 'text');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedContainer})
          set comment of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_text,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async getCommentOfItemOfDisk(target_item_required_string, target_disk_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDisk})
          return comment of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async setCommentOfItemOfDisk(target_item_required_string, target_disk_required_string, value_required_text) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (value_required_text === undefined || value_required_text === null) {
      throw new Error("value_required_text is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDisk = castAndEscape(target_disk_required_string, 'string');
    const castedValue = castAndEscape(value_required_text, 'text');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDisk})
          set comment of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_text,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async getCommentOfItemOfFolder(target_item_required_string, target_folder_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedFolder})
          return comment of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async setCommentOfItemOfFolder(target_item_required_string, target_folder_required_string, value_required_text) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }
    if (value_required_text === undefined || value_required_text === null) {
      throw new Error("value_required_text is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedFolder = castAndEscape(target_folder_required_string, 'string');
    const castedValue = castAndEscape(value_required_text, 'text');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedFolder})
          set comment of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_text,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async getCommentOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDesktopObject})
          return comment of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async setCommentOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string, value_required_text) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }
    if (value_required_text === undefined || value_required_text === null) {
      throw new Error("value_required_text is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDesktopObject = castAndEscape(target_desktop_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_text, 'text');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDesktopObject})
          set comment of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_text,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getCommentOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedTrashObject})
          return comment of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async setCommentOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string, value_required_text) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }
    if (value_required_text === undefined || value_required_text === null) {
      throw new Error("value_required_text is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedTrashObject = castAndEscape(target_trash_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_text, 'text');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedTrashObject})
          set comment of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_text,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getSizeOfItem(target_item_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedItem}
          return size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string
    };
  }

  async getSizeOfItemOfContainer(target_item_required_string, target_container_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedContainer})
          return size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async getSizeOfItemOfDisk(target_item_required_string, target_disk_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDisk})
          return size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async getSizeOfItemOfFolder(target_item_required_string, target_folder_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedFolder})
          return size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async getSizeOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDesktopObject})
          return size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getSizeOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedTrashObject})
          return size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getPhysicalSizeOfItem(target_item_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedItem}
          return physical size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string
    };
  }

  async getPhysicalSizeOfItemOfContainer(target_item_required_string, target_container_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedContainer})
          return physical size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async getPhysicalSizeOfItemOfDisk(target_item_required_string, target_disk_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDisk})
          return physical size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async getPhysicalSizeOfItemOfFolder(target_item_required_string, target_folder_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedFolder})
          return physical size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async getPhysicalSizeOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDesktopObject})
          return physical size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getPhysicalSizeOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedTrashObject})
          return physical size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getCreationDateOfItem(target_item_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedItem}
          return creation date of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string
    };
  }

  async getCreationDateOfItemOfContainer(target_item_required_string, target_container_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedContainer})
          return creation date of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async getCreationDateOfItemOfDisk(target_item_required_string, target_disk_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDisk})
          return creation date of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async getCreationDateOfItemOfFolder(target_item_required_string, target_folder_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedFolder})
          return creation date of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async getCreationDateOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDesktopObject})
          return creation date of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getCreationDateOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedTrashObject})
          return creation date of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getModificationDateOfItem(target_item_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedItem}
          return modification date of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string
    };
  }

  async setModificationDateOfItem(target_item_required_string, value_required_date) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (value_required_date === undefined || value_required_date === null) {
      throw new Error("value_required_date is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedValue = castAndEscape(value_required_date, 'date');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedItem}
          set modification date of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_date,
      script: script,
      item: target_item_required_string
    };
  }

  async getModificationDateOfItemOfContainer(target_item_required_string, target_container_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedContainer})
          return modification date of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async setModificationDateOfItemOfContainer(target_item_required_string, target_container_required_string, value_required_date) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (value_required_date === undefined || value_required_date === null) {
      throw new Error("value_required_date is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedValue = castAndEscape(value_required_date, 'date');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedContainer})
          set modification date of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_date,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async getModificationDateOfItemOfDisk(target_item_required_string, target_disk_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDisk})
          return modification date of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async setModificationDateOfItemOfDisk(target_item_required_string, target_disk_required_string, value_required_date) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (value_required_date === undefined || value_required_date === null) {
      throw new Error("value_required_date is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDisk = castAndEscape(target_disk_required_string, 'string');
    const castedValue = castAndEscape(value_required_date, 'date');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDisk})
          set modification date of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_date,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async getModificationDateOfItemOfFolder(target_item_required_string, target_folder_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedFolder})
          return modification date of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async setModificationDateOfItemOfFolder(target_item_required_string, target_folder_required_string, value_required_date) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }
    if (value_required_date === undefined || value_required_date === null) {
      throw new Error("value_required_date is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedFolder = castAndEscape(target_folder_required_string, 'string');
    const castedValue = castAndEscape(value_required_date, 'date');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedFolder})
          set modification date of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_date,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async getModificationDateOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDesktopObject})
          return modification date of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async setModificationDateOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string, value_required_date) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }
    if (value_required_date === undefined || value_required_date === null) {
      throw new Error("value_required_date is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDesktopObject = castAndEscape(target_desktop_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_date, 'date');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDesktopObject})
          set modification date of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_date,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getModificationDateOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedTrashObject})
          return modification date of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async setModificationDateOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string, value_required_date) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }
    if (value_required_date === undefined || value_required_date === null) {
      throw new Error("value_required_date is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedTrashObject = castAndEscape(target_trash_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_date, 'date');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedTrashObject})
          set modification date of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_date,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getIconOfItem(target_item_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedItem}
          return icon of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string
    };
  }

  async setIconOfItem(target_item_required_string, value_required_icon_family) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (value_required_icon_family === undefined || value_required_icon_family === null) {
      throw new Error("value_required_icon_family is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedValue = castAndEscape(value_required_icon_family, 'icon family');
    // Determine value format for AppleScript
    let valueForScript;
    // Property type 'icon family' is a class reference - treat as object
    valueForScript = castedValue; // Object reference - no quotes

    const script = `
      tell application "Finder"
        tell ${castedItem}
          set icon of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_icon_family,
      script: script,
      item: target_item_required_string
    };
  }

  async getIconOfItemOfContainer(target_item_required_string, target_container_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedContainer})
          return icon of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async setIconOfItemOfContainer(target_item_required_string, target_container_required_string, value_required_icon_family) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (value_required_icon_family === undefined || value_required_icon_family === null) {
      throw new Error("value_required_icon_family is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedValue = castAndEscape(value_required_icon_family, 'icon family');
    // Determine value format for AppleScript
    let valueForScript;
    // Property type 'icon family' is a class reference - treat as object
    valueForScript = castedValue; // Object reference - no quotes

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedContainer})
          set icon of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_icon_family,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async getIconOfItemOfDisk(target_item_required_string, target_disk_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDisk})
          return icon of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async setIconOfItemOfDisk(target_item_required_string, target_disk_required_string, value_required_icon_family) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (value_required_icon_family === undefined || value_required_icon_family === null) {
      throw new Error("value_required_icon_family is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDisk = castAndEscape(target_disk_required_string, 'string');
    const castedValue = castAndEscape(value_required_icon_family, 'icon family');
    // Determine value format for AppleScript
    let valueForScript;
    // Property type 'icon family' is a class reference - treat as object
    valueForScript = castedValue; // Object reference - no quotes

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDisk})
          set icon of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_icon_family,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async getIconOfItemOfFolder(target_item_required_string, target_folder_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedFolder})
          return icon of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async setIconOfItemOfFolder(target_item_required_string, target_folder_required_string, value_required_icon_family) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }
    if (value_required_icon_family === undefined || value_required_icon_family === null) {
      throw new Error("value_required_icon_family is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedFolder = castAndEscape(target_folder_required_string, 'string');
    const castedValue = castAndEscape(value_required_icon_family, 'icon family');
    // Determine value format for AppleScript
    let valueForScript;
    // Property type 'icon family' is a class reference - treat as object
    valueForScript = castedValue; // Object reference - no quotes

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedFolder})
          set icon of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_icon_family,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async getIconOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDesktopObject})
          return icon of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async setIconOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string, value_required_icon_family) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }
    if (value_required_icon_family === undefined || value_required_icon_family === null) {
      throw new Error("value_required_icon_family is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDesktopObject = castAndEscape(target_desktop_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_icon_family, 'icon family');
    // Determine value format for AppleScript
    let valueForScript;
    // Property type 'icon family' is a class reference - treat as object
    valueForScript = castedValue; // Object reference - no quotes

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDesktopObject})
          set icon of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_icon_family,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getIconOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedTrashObject})
          return icon of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async setIconOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string, value_required_icon_family) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }
    if (value_required_icon_family === undefined || value_required_icon_family === null) {
      throw new Error("value_required_icon_family is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedTrashObject = castAndEscape(target_trash_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_icon_family, 'icon family');
    // Determine value format for AppleScript
    let valueForScript;
    // Property type 'icon family' is a class reference - treat as object
    valueForScript = castedValue; // Object reference - no quotes

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedTrashObject})
          set icon of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_icon_family,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getUrlOfItem(target_item_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedItem}
          return URL of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string
    };
  }

  async getUrlOfItemOfContainer(target_item_required_string, target_container_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedContainer})
          return URL of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async getUrlOfItemOfDisk(target_item_required_string, target_disk_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDisk})
          return URL of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async getUrlOfItemOfFolder(target_item_required_string, target_folder_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedFolder})
          return URL of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async getUrlOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDesktopObject})
          return URL of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getUrlOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedTrashObject})
          return URL of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getOwnerOfItem(target_item_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedItem}
          return owner of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string
    };
  }

  async setOwnerOfItem(target_item_required_string, value_required_text) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (value_required_text === undefined || value_required_text === null) {
      throw new Error("value_required_text is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedValue = castAndEscape(value_required_text, 'text');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedItem}
          set owner of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_text,
      script: script,
      item: target_item_required_string
    };
  }

  async getOwnerOfItemOfContainer(target_item_required_string, target_container_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedContainer})
          return owner of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async setOwnerOfItemOfContainer(target_item_required_string, target_container_required_string, value_required_text) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (value_required_text === undefined || value_required_text === null) {
      throw new Error("value_required_text is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedValue = castAndEscape(value_required_text, 'text');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedContainer})
          set owner of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_text,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async getOwnerOfItemOfDisk(target_item_required_string, target_disk_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDisk})
          return owner of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async setOwnerOfItemOfDisk(target_item_required_string, target_disk_required_string, value_required_text) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (value_required_text === undefined || value_required_text === null) {
      throw new Error("value_required_text is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDisk = castAndEscape(target_disk_required_string, 'string');
    const castedValue = castAndEscape(value_required_text, 'text');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDisk})
          set owner of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_text,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async getOwnerOfItemOfFolder(target_item_required_string, target_folder_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedFolder})
          return owner of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async setOwnerOfItemOfFolder(target_item_required_string, target_folder_required_string, value_required_text) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }
    if (value_required_text === undefined || value_required_text === null) {
      throw new Error("value_required_text is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedFolder = castAndEscape(target_folder_required_string, 'string');
    const castedValue = castAndEscape(value_required_text, 'text');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedFolder})
          set owner of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_text,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async getOwnerOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDesktopObject})
          return owner of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async setOwnerOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string, value_required_text) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }
    if (value_required_text === undefined || value_required_text === null) {
      throw new Error("value_required_text is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDesktopObject = castAndEscape(target_desktop_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_text, 'text');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDesktopObject})
          set owner of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_text,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getOwnerOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedTrashObject})
          return owner of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async setOwnerOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string, value_required_text) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }
    if (value_required_text === undefined || value_required_text === null) {
      throw new Error("value_required_text is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedTrashObject = castAndEscape(target_trash_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_text, 'text');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedTrashObject})
          set owner of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_text,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getGroupOfItem(target_item_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedItem}
          return group of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string
    };
  }

  async setGroupOfItem(target_item_required_string, value_required_text) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (value_required_text === undefined || value_required_text === null) {
      throw new Error("value_required_text is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedValue = castAndEscape(value_required_text, 'text');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedItem}
          set group of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_text,
      script: script,
      item: target_item_required_string
    };
  }

  async getGroupOfItemOfContainer(target_item_required_string, target_container_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedContainer})
          return group of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async setGroupOfItemOfContainer(target_item_required_string, target_container_required_string, value_required_text) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (value_required_text === undefined || value_required_text === null) {
      throw new Error("value_required_text is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedValue = castAndEscape(value_required_text, 'text');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedContainer})
          set group of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_text,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async getGroupOfItemOfDisk(target_item_required_string, target_disk_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDisk})
          return group of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async setGroupOfItemOfDisk(target_item_required_string, target_disk_required_string, value_required_text) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (value_required_text === undefined || value_required_text === null) {
      throw new Error("value_required_text is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDisk = castAndEscape(target_disk_required_string, 'string');
    const castedValue = castAndEscape(value_required_text, 'text');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDisk})
          set group of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_text,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async getGroupOfItemOfFolder(target_item_required_string, target_folder_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedFolder})
          return group of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async setGroupOfItemOfFolder(target_item_required_string, target_folder_required_string, value_required_text) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }
    if (value_required_text === undefined || value_required_text === null) {
      throw new Error("value_required_text is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedFolder = castAndEscape(target_folder_required_string, 'string');
    const castedValue = castAndEscape(value_required_text, 'text');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedFolder})
          set group of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_text,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async getGroupOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDesktopObject})
          return group of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async setGroupOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string, value_required_text) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }
    if (value_required_text === undefined || value_required_text === null) {
      throw new Error("value_required_text is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDesktopObject = castAndEscape(target_desktop_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_text, 'text');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDesktopObject})
          set group of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_text,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getGroupOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedTrashObject})
          return group of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async setGroupOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string, value_required_text) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }
    if (value_required_text === undefined || value_required_text === null) {
      throw new Error("value_required_text is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedTrashObject = castAndEscape(target_trash_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_text, 'text');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedTrashObject})
          set group of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_text,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getOwnerPrivilegesOfItem(target_item_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedItem}
          return owner privileges of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string
    };
  }

  async setOwnerPrivilegesOfItem(target_item_required_string, value_required_priv) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (value_required_priv === undefined || value_required_priv === null) {
      throw new Error("value_required_priv is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedValue = castAndEscape(value_required_priv, 'priv');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedItem}
          set owner privileges of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_priv,
      script: script,
      item: target_item_required_string
    };
  }

  async getOwnerPrivilegesOfItemOfContainer(target_item_required_string, target_container_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedContainer})
          return owner privileges of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async setOwnerPrivilegesOfItemOfContainer(target_item_required_string, target_container_required_string, value_required_priv) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (value_required_priv === undefined || value_required_priv === null) {
      throw new Error("value_required_priv is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedValue = castAndEscape(value_required_priv, 'priv');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedContainer})
          set owner privileges of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_priv,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async getOwnerPrivilegesOfItemOfDisk(target_item_required_string, target_disk_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDisk})
          return owner privileges of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async setOwnerPrivilegesOfItemOfDisk(target_item_required_string, target_disk_required_string, value_required_priv) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (value_required_priv === undefined || value_required_priv === null) {
      throw new Error("value_required_priv is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDisk = castAndEscape(target_disk_required_string, 'string');
    const castedValue = castAndEscape(value_required_priv, 'priv');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDisk})
          set owner privileges of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_priv,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async getOwnerPrivilegesOfItemOfFolder(target_item_required_string, target_folder_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedFolder})
          return owner privileges of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async setOwnerPrivilegesOfItemOfFolder(target_item_required_string, target_folder_required_string, value_required_priv) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }
    if (value_required_priv === undefined || value_required_priv === null) {
      throw new Error("value_required_priv is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedFolder = castAndEscape(target_folder_required_string, 'string');
    const castedValue = castAndEscape(value_required_priv, 'priv');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedFolder})
          set owner privileges of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_priv,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async getOwnerPrivilegesOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDesktopObject})
          return owner privileges of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async setOwnerPrivilegesOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string, value_required_priv) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }
    if (value_required_priv === undefined || value_required_priv === null) {
      throw new Error("value_required_priv is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDesktopObject = castAndEscape(target_desktop_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_priv, 'priv');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDesktopObject})
          set owner privileges of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_priv,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getOwnerPrivilegesOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedTrashObject})
          return owner privileges of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async setOwnerPrivilegesOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string, value_required_priv) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }
    if (value_required_priv === undefined || value_required_priv === null) {
      throw new Error("value_required_priv is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedTrashObject = castAndEscape(target_trash_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_priv, 'priv');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedTrashObject})
          set owner privileges of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_priv,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getGroupPrivilegesOfItem(target_item_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedItem}
          return group privileges of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string
    };
  }

  async setGroupPrivilegesOfItem(target_item_required_string, value_required_priv) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (value_required_priv === undefined || value_required_priv === null) {
      throw new Error("value_required_priv is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedValue = castAndEscape(value_required_priv, 'priv');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedItem}
          set group privileges of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_priv,
      script: script,
      item: target_item_required_string
    };
  }

  async getGroupPrivilegesOfItemOfContainer(target_item_required_string, target_container_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedContainer})
          return group privileges of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async setGroupPrivilegesOfItemOfContainer(target_item_required_string, target_container_required_string, value_required_priv) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (value_required_priv === undefined || value_required_priv === null) {
      throw new Error("value_required_priv is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedValue = castAndEscape(value_required_priv, 'priv');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedContainer})
          set group privileges of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_priv,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async getGroupPrivilegesOfItemOfDisk(target_item_required_string, target_disk_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDisk})
          return group privileges of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async setGroupPrivilegesOfItemOfDisk(target_item_required_string, target_disk_required_string, value_required_priv) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (value_required_priv === undefined || value_required_priv === null) {
      throw new Error("value_required_priv is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDisk = castAndEscape(target_disk_required_string, 'string');
    const castedValue = castAndEscape(value_required_priv, 'priv');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDisk})
          set group privileges of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_priv,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async getGroupPrivilegesOfItemOfFolder(target_item_required_string, target_folder_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedFolder})
          return group privileges of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async setGroupPrivilegesOfItemOfFolder(target_item_required_string, target_folder_required_string, value_required_priv) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }
    if (value_required_priv === undefined || value_required_priv === null) {
      throw new Error("value_required_priv is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedFolder = castAndEscape(target_folder_required_string, 'string');
    const castedValue = castAndEscape(value_required_priv, 'priv');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedFolder})
          set group privileges of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_priv,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async getGroupPrivilegesOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDesktopObject})
          return group privileges of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async setGroupPrivilegesOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string, value_required_priv) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }
    if (value_required_priv === undefined || value_required_priv === null) {
      throw new Error("value_required_priv is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDesktopObject = castAndEscape(target_desktop_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_priv, 'priv');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDesktopObject})
          set group privileges of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_priv,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getGroupPrivilegesOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedTrashObject})
          return group privileges of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async setGroupPrivilegesOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string, value_required_priv) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }
    if (value_required_priv === undefined || value_required_priv === null) {
      throw new Error("value_required_priv is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedTrashObject = castAndEscape(target_trash_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_priv, 'priv');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedTrashObject})
          set group privileges of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_priv,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getEveryonesPrivilegesOfItem(target_item_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedItem}
          return everyones privileges of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string
    };
  }

  async setEveryonesPrivilegesOfItem(target_item_required_string, value_required_priv) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (value_required_priv === undefined || value_required_priv === null) {
      throw new Error("value_required_priv is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedValue = castAndEscape(value_required_priv, 'priv');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedItem}
          set everyones privileges of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_priv,
      script: script,
      item: target_item_required_string
    };
  }

  async getEveryonesPrivilegesOfItemOfContainer(target_item_required_string, target_container_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedContainer})
          return everyones privileges of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async setEveryonesPrivilegesOfItemOfContainer(target_item_required_string, target_container_required_string, value_required_priv) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (value_required_priv === undefined || value_required_priv === null) {
      throw new Error("value_required_priv is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedValue = castAndEscape(value_required_priv, 'priv');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedContainer})
          set everyones privileges of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_priv,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async getEveryonesPrivilegesOfItemOfDisk(target_item_required_string, target_disk_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDisk})
          return everyones privileges of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async setEveryonesPrivilegesOfItemOfDisk(target_item_required_string, target_disk_required_string, value_required_priv) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (value_required_priv === undefined || value_required_priv === null) {
      throw new Error("value_required_priv is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDisk = castAndEscape(target_disk_required_string, 'string');
    const castedValue = castAndEscape(value_required_priv, 'priv');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDisk})
          set everyones privileges of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_priv,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async getEveryonesPrivilegesOfItemOfFolder(target_item_required_string, target_folder_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedFolder})
          return everyones privileges of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async setEveryonesPrivilegesOfItemOfFolder(target_item_required_string, target_folder_required_string, value_required_priv) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }
    if (value_required_priv === undefined || value_required_priv === null) {
      throw new Error("value_required_priv is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedFolder = castAndEscape(target_folder_required_string, 'string');
    const castedValue = castAndEscape(value_required_priv, 'priv');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedFolder})
          set everyones privileges of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_priv,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async getEveryonesPrivilegesOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDesktopObject})
          return everyones privileges of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async setEveryonesPrivilegesOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string, value_required_priv) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }
    if (value_required_priv === undefined || value_required_priv === null) {
      throw new Error("value_required_priv is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDesktopObject = castAndEscape(target_desktop_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_priv, 'priv');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDesktopObject})
          set everyones privileges of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_priv,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getEveryonesPrivilegesOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedTrashObject})
          return everyones privileges of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async setEveryonesPrivilegesOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string, value_required_priv) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }
    if (value_required_priv === undefined || value_required_priv === null) {
      throw new Error("value_required_priv is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedTrashObject = castAndEscape(target_trash_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_priv, 'priv');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedTrashObject})
          set everyones privileges of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_priv,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getInformationWindowOfItem(target_item_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedItem}
          return information window of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string
    };
  }

  async getInformationWindowOfItemOfContainer(target_item_required_string, target_container_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedContainer})
          return information window of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async getInformationWindowOfItemOfDisk(target_item_required_string, target_disk_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDisk})
          return information window of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async getInformationWindowOfItemOfFolder(target_item_required_string, target_folder_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedFolder})
          return information window of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async getInformationWindowOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDesktopObject})
          return information window of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getInformationWindowOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedTrashObject})
          return information window of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getPropertiesOfItem(target_item_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedItem}
          return properties of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string
    };
  }

  async setPropertiesOfItem(target_item_required_string, value_required_record) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (value_required_record === undefined || value_required_record === null) {
      throw new Error("value_required_record is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedValue = castAndEscape(value_required_record, 'record');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedItem}
          set properties of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_record,
      script: script,
      item: target_item_required_string
    };
  }

  async getPropertiesOfItemOfContainer(target_item_required_string, target_container_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedContainer})
          return properties of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async setPropertiesOfItemOfContainer(target_item_required_string, target_container_required_string, value_required_record) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (value_required_record === undefined || value_required_record === null) {
      throw new Error("value_required_record is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedValue = castAndEscape(value_required_record, 'record');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedContainer})
          set properties of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_record,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async getPropertiesOfItemOfDisk(target_item_required_string, target_disk_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDisk})
          return properties of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async setPropertiesOfItemOfDisk(target_item_required_string, target_disk_required_string, value_required_record) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (value_required_record === undefined || value_required_record === null) {
      throw new Error("value_required_record is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDisk = castAndEscape(target_disk_required_string, 'string');
    const castedValue = castAndEscape(value_required_record, 'record');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDisk})
          set properties of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_record,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async getPropertiesOfItemOfFolder(target_item_required_string, target_folder_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedFolder})
          return properties of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async setPropertiesOfItemOfFolder(target_item_required_string, target_folder_required_string, value_required_record) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }
    if (value_required_record === undefined || value_required_record === null) {
      throw new Error("value_required_record is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedFolder = castAndEscape(target_folder_required_string, 'string');
    const castedValue = castAndEscape(value_required_record, 'record');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedFolder})
          set properties of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_record,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async getPropertiesOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDesktopObject})
          return properties of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async setPropertiesOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string, value_required_record) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }
    if (value_required_record === undefined || value_required_record === null) {
      throw new Error("value_required_record is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedDesktopObject = castAndEscape(target_desktop_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_record, 'record');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedDesktopObject})
          set properties of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_record,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getPropertiesOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedTrashObject})
          return properties of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async setPropertiesOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string, value_required_record) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }
    if (value_required_record === undefined || value_required_record === null) {
      throw new Error("value_required_record is required");
    }

    const castedItem = castAndEscape(target_item_required_string, 'string');
    const castedTrashObject = castAndEscape(target_trash_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_record, 'record');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedItem} of ${castedTrashObject})
          set properties of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_record,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getClassOfItem(target_item_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedItem}
          return class of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string
    };
  }

  async getClassOfItemOfContainer(target_item_required_string, target_container_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedContainer})
          return class of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      container: target_container_required_string
    };
  }

  async getClassOfItemOfDisk(target_item_required_string, target_disk_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDisk})
          return class of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      disk: target_disk_required_string
    };
  }

  async getClassOfItemOfFolder(target_item_required_string, target_folder_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedFolder})
          return class of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      folder: target_folder_required_string
    };
  }

  async getClassOfItemOfDesktopObject(target_item_required_string, target_desktop_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedDesktopObject})
          return class of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getClassOfItemOfTrashObject(target_item_required_string, target_trash_object_required_string) {
    if (!target_item_required_string || typeof target_item_required_string !== "string") {
      throw new Error("target_item_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedItem = escapeForAppleScript(target_item_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedItem} of ${escapedTrashObject})
          return class of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      item: target_item_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getEntireContentsOfContainer(target_container_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedContainer}
          return entire contents of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      container: target_container_required_string
    };
  }

  async getEntireContentsOfContainerOfDisk(target_container_required_string, target_disk_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedContainer = escapeForAppleScript(target_container_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedContainer} of ${escapedDisk})
          return entire contents of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      container: target_container_required_string,
      disk: target_disk_required_string
    };
  }

  async getEntireContentsOfContainerOfFolder(target_container_required_string, target_folder_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedContainer = escapeForAppleScript(target_container_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedContainer} of ${escapedFolder})
          return entire contents of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      container: target_container_required_string,
      folder: target_folder_required_string
    };
  }

  async getEntireContentsOfContainerOfDesktopObject(target_container_required_string, target_desktop_object_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedContainer = escapeForAppleScript(target_container_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedContainer} of ${escapedDesktopObject})
          return entire contents of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      container: target_container_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getEntireContentsOfContainerOfTrashObject(target_container_required_string, target_trash_object_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedContainer = escapeForAppleScript(target_container_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedContainer} of ${escapedTrashObject})
          return entire contents of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      container: target_container_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getExpandableOfContainer(target_container_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedContainer}
          return expandable of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      container: target_container_required_string
    };
  }

  async getExpandableOfContainerOfDisk(target_container_required_string, target_disk_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedContainer = escapeForAppleScript(target_container_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedContainer} of ${escapedDisk})
          return expandable of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      container: target_container_required_string,
      disk: target_disk_required_string
    };
  }

  async getExpandableOfContainerOfFolder(target_container_required_string, target_folder_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedContainer = escapeForAppleScript(target_container_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedContainer} of ${escapedFolder})
          return expandable of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      container: target_container_required_string,
      folder: target_folder_required_string
    };
  }

  async getExpandableOfContainerOfDesktopObject(target_container_required_string, target_desktop_object_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedContainer = escapeForAppleScript(target_container_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedContainer} of ${escapedDesktopObject})
          return expandable of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      container: target_container_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getExpandableOfContainerOfTrashObject(target_container_required_string, target_trash_object_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedContainer = escapeForAppleScript(target_container_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedContainer} of ${escapedTrashObject})
          return expandable of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      container: target_container_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getExpandedOfContainer(target_container_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedContainer}
          return expanded of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      container: target_container_required_string
    };
  }

  async setExpandedOfContainer(target_container_required_string, value_required_boolean) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          set expanded of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      container: target_container_required_string
    };
  }

  async getExpandedOfContainerOfDisk(target_container_required_string, target_disk_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedContainer = escapeForAppleScript(target_container_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedContainer} of ${escapedDisk})
          return expanded of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      container: target_container_required_string,
      disk: target_disk_required_string
    };
  }

  async setExpandedOfContainerOfDisk(target_container_required_string, target_disk_required_string, value_required_boolean) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedDisk = castAndEscape(target_disk_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedContainer} of ${castedDisk})
          set expanded of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      container: target_container_required_string,
      disk: target_disk_required_string
    };
  }

  async getExpandedOfContainerOfFolder(target_container_required_string, target_folder_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedContainer = escapeForAppleScript(target_container_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedContainer} of ${escapedFolder})
          return expanded of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      container: target_container_required_string,
      folder: target_folder_required_string
    };
  }

  async setExpandedOfContainerOfFolder(target_container_required_string, target_folder_required_string, value_required_boolean) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedFolder = castAndEscape(target_folder_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedContainer} of ${castedFolder})
          set expanded of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      container: target_container_required_string,
      folder: target_folder_required_string
    };
  }

  async getExpandedOfContainerOfDesktopObject(target_container_required_string, target_desktop_object_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedContainer = escapeForAppleScript(target_container_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedContainer} of ${escapedDesktopObject})
          return expanded of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      container: target_container_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async setExpandedOfContainerOfDesktopObject(target_container_required_string, target_desktop_object_required_string, value_required_boolean) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedDesktopObject = castAndEscape(target_desktop_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedContainer} of ${castedDesktopObject})
          set expanded of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      container: target_container_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getExpandedOfContainerOfTrashObject(target_container_required_string, target_trash_object_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedContainer = escapeForAppleScript(target_container_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedContainer} of ${escapedTrashObject})
          return expanded of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      container: target_container_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async setExpandedOfContainerOfTrashObject(target_container_required_string, target_trash_object_required_string, value_required_boolean) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedTrashObject = castAndEscape(target_trash_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedContainer} of ${castedTrashObject})
          set expanded of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      container: target_container_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getCompletelyExpandedOfContainer(target_container_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedContainer}
          return completely expanded of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      container: target_container_required_string
    };
  }

  async setCompletelyExpandedOfContainer(target_container_required_string, value_required_boolean) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedContainer}
          set completely expanded of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      container: target_container_required_string
    };
  }

  async getCompletelyExpandedOfContainerOfDisk(target_container_required_string, target_disk_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedContainer = escapeForAppleScript(target_container_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedContainer} of ${escapedDisk})
          return completely expanded of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      container: target_container_required_string,
      disk: target_disk_required_string
    };
  }

  async setCompletelyExpandedOfContainerOfDisk(target_container_required_string, target_disk_required_string, value_required_boolean) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedDisk = castAndEscape(target_disk_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedContainer} of ${castedDisk})
          set completely expanded of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      container: target_container_required_string,
      disk: target_disk_required_string
    };
  }

  async getCompletelyExpandedOfContainerOfFolder(target_container_required_string, target_folder_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedContainer = escapeForAppleScript(target_container_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedContainer} of ${escapedFolder})
          return completely expanded of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      container: target_container_required_string,
      folder: target_folder_required_string
    };
  }

  async setCompletelyExpandedOfContainerOfFolder(target_container_required_string, target_folder_required_string, value_required_boolean) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedFolder = castAndEscape(target_folder_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedContainer} of ${castedFolder})
          set completely expanded of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      container: target_container_required_string,
      folder: target_folder_required_string
    };
  }

  async getCompletelyExpandedOfContainerOfDesktopObject(target_container_required_string, target_desktop_object_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedContainer = escapeForAppleScript(target_container_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedContainer} of ${escapedDesktopObject})
          return completely expanded of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      container: target_container_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async setCompletelyExpandedOfContainerOfDesktopObject(target_container_required_string, target_desktop_object_required_string, value_required_boolean) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedDesktopObject = castAndEscape(target_desktop_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedContainer} of ${castedDesktopObject})
          set completely expanded of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      container: target_container_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getCompletelyExpandedOfContainerOfTrashObject(target_container_required_string, target_trash_object_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedContainer = escapeForAppleScript(target_container_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedContainer} of ${escapedTrashObject})
          return completely expanded of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      container: target_container_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async setCompletelyExpandedOfContainerOfTrashObject(target_container_required_string, target_trash_object_required_string, value_required_boolean) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedTrashObject = castAndEscape(target_trash_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedContainer} of ${castedTrashObject})
          set completely expanded of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      container: target_container_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getContainerWindowOfContainer(target_container_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedContainer}
          return container window of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      container: target_container_required_string
    };
  }

  async getContainerWindowOfContainerOfDisk(target_container_required_string, target_disk_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedContainer = escapeForAppleScript(target_container_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedContainer} of ${escapedDisk})
          return container window of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      container: target_container_required_string,
      disk: target_disk_required_string
    };
  }

  async getContainerWindowOfContainerOfFolder(target_container_required_string, target_folder_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedContainer = escapeForAppleScript(target_container_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedContainer} of ${escapedFolder})
          return container window of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      container: target_container_required_string,
      folder: target_folder_required_string
    };
  }

  async getContainerWindowOfContainerOfDesktopObject(target_container_required_string, target_desktop_object_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedContainer = escapeForAppleScript(target_container_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedContainer} of ${escapedDesktopObject})
          return container window of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      container: target_container_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getContainerWindowOfContainerOfTrashObject(target_container_required_string, target_trash_object_required_string) {
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedContainer = escapeForAppleScript(target_container_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedContainer} of ${escapedTrashObject})
          return container window of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      container: target_container_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getIdOfDisk(target_disk_required_string) {
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedDisk}
          return id of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      disk: target_disk_required_string
    };
  }

  async getIdOfDiskOfDesktopObject(target_disk_required_string, target_desktop_object_required_string) {
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedDisk = escapeForAppleScript(target_disk_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedDisk} of ${escapedDesktopObject})
          return id of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      disk: target_disk_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getCapacityOfDisk(target_disk_required_string) {
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedDisk}
          return capacity of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      disk: target_disk_required_string
    };
  }

  async getCapacityOfDiskOfDesktopObject(target_disk_required_string, target_desktop_object_required_string) {
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedDisk = escapeForAppleScript(target_disk_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedDisk} of ${escapedDesktopObject})
          return capacity of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      disk: target_disk_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getFreeSpaceOfDisk(target_disk_required_string) {
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedDisk}
          return free space of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      disk: target_disk_required_string
    };
  }

  async getFreeSpaceOfDiskOfDesktopObject(target_disk_required_string, target_desktop_object_required_string) {
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedDisk = escapeForAppleScript(target_disk_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedDisk} of ${escapedDesktopObject})
          return free space of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      disk: target_disk_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getEjectableOfDisk(target_disk_required_string) {
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedDisk}
          return ejectable of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      disk: target_disk_required_string
    };
  }

  async getEjectableOfDiskOfDesktopObject(target_disk_required_string, target_desktop_object_required_string) {
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedDisk = escapeForAppleScript(target_disk_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedDisk} of ${escapedDesktopObject})
          return ejectable of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      disk: target_disk_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getLocalVolumeOfDisk(target_disk_required_string) {
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedDisk}
          return local volume of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      disk: target_disk_required_string
    };
  }

  async getLocalVolumeOfDiskOfDesktopObject(target_disk_required_string, target_desktop_object_required_string) {
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedDisk = escapeForAppleScript(target_disk_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedDisk} of ${escapedDesktopObject})
          return local volume of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      disk: target_disk_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getStartupOfDisk(target_disk_required_string) {
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedDisk}
          return startup of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      disk: target_disk_required_string
    };
  }

  async getStartupOfDiskOfDesktopObject(target_disk_required_string, target_desktop_object_required_string) {
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedDisk = escapeForAppleScript(target_disk_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedDisk} of ${escapedDesktopObject})
          return startup of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      disk: target_disk_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getFormatOfDisk(target_disk_required_string) {
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedDisk}
          return format of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      disk: target_disk_required_string
    };
  }

  async getFormatOfDiskOfDesktopObject(target_disk_required_string, target_desktop_object_required_string) {
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedDisk = escapeForAppleScript(target_disk_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedDisk} of ${escapedDesktopObject})
          return format of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      disk: target_disk_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getJournalingEnabledOfDisk(target_disk_required_string) {
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedDisk}
          return journaling enabled of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      disk: target_disk_required_string
    };
  }

  async getJournalingEnabledOfDiskOfDesktopObject(target_disk_required_string, target_desktop_object_required_string) {
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedDisk = escapeForAppleScript(target_disk_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedDisk} of ${escapedDesktopObject})
          return journaling enabled of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      disk: target_disk_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getIgnorePrivilegesOfDisk(target_disk_required_string) {
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedDisk}
          return ignore privileges of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      disk: target_disk_required_string
    };
  }

  async setIgnorePrivilegesOfDisk(target_disk_required_string, value_required_boolean) {
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedDisk = castAndEscape(target_disk_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedDisk}
          set ignore privileges of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      disk: target_disk_required_string
    };
  }

  async getIgnorePrivilegesOfDiskOfDesktopObject(target_disk_required_string, target_desktop_object_required_string) {
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedDisk = escapeForAppleScript(target_disk_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedDisk} of ${escapedDesktopObject})
          return ignore privileges of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      disk: target_disk_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async setIgnorePrivilegesOfDiskOfDesktopObject(target_disk_required_string, target_desktop_object_required_string, value_required_boolean) {
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedDisk = castAndEscape(target_disk_required_string, 'string');
    const castedDesktopObject = castAndEscape(target_desktop_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedDisk} of ${castedDesktopObject})
          set ignore privileges of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      disk: target_disk_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getWarnsBeforeEmptyingOfTrashObject(target_trash_object_required_string) {
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedTrashObject}
          return warns before emptying of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      trash_object: target_trash_object_required_string
    };
  }

  async setWarnsBeforeEmptyingOfTrashObject(target_trash_object_required_string, value_required_boolean) {
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedTrashObject = castAndEscape(target_trash_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedTrashObject}
          set warns before emptying of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      trash_object: target_trash_object_required_string
    };
  }

  async getFileTypeOfFile(target_file_required_string) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }

    const escapedFile = escapeForAppleScript(target_file_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedFile}
          return file type of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      file: target_file_required_string
    };
  }

  async setFileTypeOfFile(target_file_required_string, value_required_type) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (value_required_type === undefined || value_required_type === null) {
      throw new Error("value_required_type is required");
    }

    const castedFile = castAndEscape(target_file_required_string, 'string');
    const castedValue = castAndEscape(value_required_type, 'type');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedFile}
          set file type of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_type,
      script: script,
      file: target_file_required_string
    };
  }

  async getFileTypeOfFileOfContainer(target_file_required_string, target_container_required_string) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedFile = escapeForAppleScript(target_file_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedFile} of ${escapedContainer})
          return file type of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      file: target_file_required_string,
      container: target_container_required_string
    };
  }

  async setFileTypeOfFileOfContainer(target_file_required_string, target_container_required_string, value_required_type) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (value_required_type === undefined || value_required_type === null) {
      throw new Error("value_required_type is required");
    }

    const castedFile = castAndEscape(target_file_required_string, 'string');
    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedValue = castAndEscape(value_required_type, 'type');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedFile} of ${castedContainer})
          set file type of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_type,
      script: script,
      file: target_file_required_string,
      container: target_container_required_string
    };
  }

  async getFileTypeOfFileOfDisk(target_file_required_string, target_disk_required_string) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedFile = escapeForAppleScript(target_file_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedFile} of ${escapedDisk})
          return file type of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      file: target_file_required_string,
      disk: target_disk_required_string
    };
  }

  async setFileTypeOfFileOfDisk(target_file_required_string, target_disk_required_string, value_required_type) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (value_required_type === undefined || value_required_type === null) {
      throw new Error("value_required_type is required");
    }

    const castedFile = castAndEscape(target_file_required_string, 'string');
    const castedDisk = castAndEscape(target_disk_required_string, 'string');
    const castedValue = castAndEscape(value_required_type, 'type');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedFile} of ${castedDisk})
          set file type of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_type,
      script: script,
      file: target_file_required_string,
      disk: target_disk_required_string
    };
  }

  async getFileTypeOfFileOfFolder(target_file_required_string, target_folder_required_string) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedFile = escapeForAppleScript(target_file_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedFile} of ${escapedFolder})
          return file type of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      file: target_file_required_string,
      folder: target_folder_required_string
    };
  }

  async setFileTypeOfFileOfFolder(target_file_required_string, target_folder_required_string, value_required_type) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }
    if (value_required_type === undefined || value_required_type === null) {
      throw new Error("value_required_type is required");
    }

    const castedFile = castAndEscape(target_file_required_string, 'string');
    const castedFolder = castAndEscape(target_folder_required_string, 'string');
    const castedValue = castAndEscape(value_required_type, 'type');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedFile} of ${castedFolder})
          set file type of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_type,
      script: script,
      file: target_file_required_string,
      folder: target_folder_required_string
    };
  }

  async getFileTypeOfFileOfDesktopObject(target_file_required_string, target_desktop_object_required_string) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedFile = escapeForAppleScript(target_file_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedFile} of ${escapedDesktopObject})
          return file type of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      file: target_file_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async setFileTypeOfFileOfDesktopObject(target_file_required_string, target_desktop_object_required_string, value_required_type) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }
    if (value_required_type === undefined || value_required_type === null) {
      throw new Error("value_required_type is required");
    }

    const castedFile = castAndEscape(target_file_required_string, 'string');
    const castedDesktopObject = castAndEscape(target_desktop_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_type, 'type');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedFile} of ${castedDesktopObject})
          set file type of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_type,
      script: script,
      file: target_file_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getFileTypeOfFileOfTrashObject(target_file_required_string, target_trash_object_required_string) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedFile = escapeForAppleScript(target_file_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedFile} of ${escapedTrashObject})
          return file type of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      file: target_file_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async setFileTypeOfFileOfTrashObject(target_file_required_string, target_trash_object_required_string, value_required_type) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }
    if (value_required_type === undefined || value_required_type === null) {
      throw new Error("value_required_type is required");
    }

    const castedFile = castAndEscape(target_file_required_string, 'string');
    const castedTrashObject = castAndEscape(target_trash_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_type, 'type');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedFile} of ${castedTrashObject})
          set file type of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_type,
      script: script,
      file: target_file_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getCreatorTypeOfFile(target_file_required_string) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }

    const escapedFile = escapeForAppleScript(target_file_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedFile}
          return creator type of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      file: target_file_required_string
    };
  }

  async setCreatorTypeOfFile(target_file_required_string, value_required_type) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (value_required_type === undefined || value_required_type === null) {
      throw new Error("value_required_type is required");
    }

    const castedFile = castAndEscape(target_file_required_string, 'string');
    const castedValue = castAndEscape(value_required_type, 'type');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedFile}
          set creator type of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_type,
      script: script,
      file: target_file_required_string
    };
  }

  async getCreatorTypeOfFileOfContainer(target_file_required_string, target_container_required_string) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedFile = escapeForAppleScript(target_file_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedFile} of ${escapedContainer})
          return creator type of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      file: target_file_required_string,
      container: target_container_required_string
    };
  }

  async setCreatorTypeOfFileOfContainer(target_file_required_string, target_container_required_string, value_required_type) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (value_required_type === undefined || value_required_type === null) {
      throw new Error("value_required_type is required");
    }

    const castedFile = castAndEscape(target_file_required_string, 'string');
    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedValue = castAndEscape(value_required_type, 'type');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedFile} of ${castedContainer})
          set creator type of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_type,
      script: script,
      file: target_file_required_string,
      container: target_container_required_string
    };
  }

  async getCreatorTypeOfFileOfDisk(target_file_required_string, target_disk_required_string) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedFile = escapeForAppleScript(target_file_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedFile} of ${escapedDisk})
          return creator type of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      file: target_file_required_string,
      disk: target_disk_required_string
    };
  }

  async setCreatorTypeOfFileOfDisk(target_file_required_string, target_disk_required_string, value_required_type) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (value_required_type === undefined || value_required_type === null) {
      throw new Error("value_required_type is required");
    }

    const castedFile = castAndEscape(target_file_required_string, 'string');
    const castedDisk = castAndEscape(target_disk_required_string, 'string');
    const castedValue = castAndEscape(value_required_type, 'type');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedFile} of ${castedDisk})
          set creator type of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_type,
      script: script,
      file: target_file_required_string,
      disk: target_disk_required_string
    };
  }

  async getCreatorTypeOfFileOfFolder(target_file_required_string, target_folder_required_string) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedFile = escapeForAppleScript(target_file_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedFile} of ${escapedFolder})
          return creator type of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      file: target_file_required_string,
      folder: target_folder_required_string
    };
  }

  async setCreatorTypeOfFileOfFolder(target_file_required_string, target_folder_required_string, value_required_type) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }
    if (value_required_type === undefined || value_required_type === null) {
      throw new Error("value_required_type is required");
    }

    const castedFile = castAndEscape(target_file_required_string, 'string');
    const castedFolder = castAndEscape(target_folder_required_string, 'string');
    const castedValue = castAndEscape(value_required_type, 'type');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedFile} of ${castedFolder})
          set creator type of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_type,
      script: script,
      file: target_file_required_string,
      folder: target_folder_required_string
    };
  }

  async getCreatorTypeOfFileOfDesktopObject(target_file_required_string, target_desktop_object_required_string) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedFile = escapeForAppleScript(target_file_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedFile} of ${escapedDesktopObject})
          return creator type of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      file: target_file_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async setCreatorTypeOfFileOfDesktopObject(target_file_required_string, target_desktop_object_required_string, value_required_type) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }
    if (value_required_type === undefined || value_required_type === null) {
      throw new Error("value_required_type is required");
    }

    const castedFile = castAndEscape(target_file_required_string, 'string');
    const castedDesktopObject = castAndEscape(target_desktop_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_type, 'type');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedFile} of ${castedDesktopObject})
          set creator type of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_type,
      script: script,
      file: target_file_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getCreatorTypeOfFileOfTrashObject(target_file_required_string, target_trash_object_required_string) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedFile = escapeForAppleScript(target_file_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedFile} of ${escapedTrashObject})
          return creator type of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      file: target_file_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async setCreatorTypeOfFileOfTrashObject(target_file_required_string, target_trash_object_required_string, value_required_type) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }
    if (value_required_type === undefined || value_required_type === null) {
      throw new Error("value_required_type is required");
    }

    const castedFile = castAndEscape(target_file_required_string, 'string');
    const castedTrashObject = castAndEscape(target_trash_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_type, 'type');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedFile} of ${castedTrashObject})
          set creator type of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_type,
      script: script,
      file: target_file_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getStationeryOfFile(target_file_required_string) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }

    const escapedFile = escapeForAppleScript(target_file_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedFile}
          return stationery of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      file: target_file_required_string
    };
  }

  async setStationeryOfFile(target_file_required_string, value_required_boolean) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedFile = castAndEscape(target_file_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedFile}
          set stationery of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      file: target_file_required_string
    };
  }

  async getStationeryOfFileOfContainer(target_file_required_string, target_container_required_string) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedFile = escapeForAppleScript(target_file_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedFile} of ${escapedContainer})
          return stationery of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      file: target_file_required_string,
      container: target_container_required_string
    };
  }

  async setStationeryOfFileOfContainer(target_file_required_string, target_container_required_string, value_required_boolean) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedFile = castAndEscape(target_file_required_string, 'string');
    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedFile} of ${castedContainer})
          set stationery of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      file: target_file_required_string,
      container: target_container_required_string
    };
  }

  async getStationeryOfFileOfDisk(target_file_required_string, target_disk_required_string) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedFile = escapeForAppleScript(target_file_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedFile} of ${escapedDisk})
          return stationery of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      file: target_file_required_string,
      disk: target_disk_required_string
    };
  }

  async setStationeryOfFileOfDisk(target_file_required_string, target_disk_required_string, value_required_boolean) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedFile = castAndEscape(target_file_required_string, 'string');
    const castedDisk = castAndEscape(target_disk_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedFile} of ${castedDisk})
          set stationery of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      file: target_file_required_string,
      disk: target_disk_required_string
    };
  }

  async getStationeryOfFileOfFolder(target_file_required_string, target_folder_required_string) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedFile = escapeForAppleScript(target_file_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedFile} of ${escapedFolder})
          return stationery of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      file: target_file_required_string,
      folder: target_folder_required_string
    };
  }

  async setStationeryOfFileOfFolder(target_file_required_string, target_folder_required_string, value_required_boolean) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedFile = castAndEscape(target_file_required_string, 'string');
    const castedFolder = castAndEscape(target_folder_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedFile} of ${castedFolder})
          set stationery of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      file: target_file_required_string,
      folder: target_folder_required_string
    };
  }

  async getStationeryOfFileOfDesktopObject(target_file_required_string, target_desktop_object_required_string) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedFile = escapeForAppleScript(target_file_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedFile} of ${escapedDesktopObject})
          return stationery of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      file: target_file_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async setStationeryOfFileOfDesktopObject(target_file_required_string, target_desktop_object_required_string, value_required_boolean) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedFile = castAndEscape(target_file_required_string, 'string');
    const castedDesktopObject = castAndEscape(target_desktop_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedFile} of ${castedDesktopObject})
          set stationery of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      file: target_file_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getStationeryOfFileOfTrashObject(target_file_required_string, target_trash_object_required_string) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedFile = escapeForAppleScript(target_file_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedFile} of ${escapedTrashObject})
          return stationery of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      file: target_file_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async setStationeryOfFileOfTrashObject(target_file_required_string, target_trash_object_required_string, value_required_boolean) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedFile = castAndEscape(target_file_required_string, 'string');
    const castedTrashObject = castAndEscape(target_trash_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedFile} of ${castedTrashObject})
          set stationery of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      file: target_file_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getProductVersionOfFile(target_file_required_string) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }

    const escapedFile = escapeForAppleScript(target_file_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedFile}
          return product version of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      file: target_file_required_string
    };
  }

  async getProductVersionOfFileOfContainer(target_file_required_string, target_container_required_string) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedFile = escapeForAppleScript(target_file_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedFile} of ${escapedContainer})
          return product version of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      file: target_file_required_string,
      container: target_container_required_string
    };
  }

  async getProductVersionOfFileOfDisk(target_file_required_string, target_disk_required_string) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedFile = escapeForAppleScript(target_file_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedFile} of ${escapedDisk})
          return product version of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      file: target_file_required_string,
      disk: target_disk_required_string
    };
  }

  async getProductVersionOfFileOfFolder(target_file_required_string, target_folder_required_string) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedFile = escapeForAppleScript(target_file_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedFile} of ${escapedFolder})
          return product version of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      file: target_file_required_string,
      folder: target_folder_required_string
    };
  }

  async getProductVersionOfFileOfDesktopObject(target_file_required_string, target_desktop_object_required_string) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedFile = escapeForAppleScript(target_file_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedFile} of ${escapedDesktopObject})
          return product version of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      file: target_file_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getProductVersionOfFileOfTrashObject(target_file_required_string, target_trash_object_required_string) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedFile = escapeForAppleScript(target_file_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedFile} of ${escapedTrashObject})
          return product version of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      file: target_file_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getVersionOfFile(target_file_required_string) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }

    const escapedFile = escapeForAppleScript(target_file_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedFile}
          return version of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      file: target_file_required_string
    };
  }

  async getVersionOfFileOfContainer(target_file_required_string, target_container_required_string) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedFile = escapeForAppleScript(target_file_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedFile} of ${escapedContainer})
          return version of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      file: target_file_required_string,
      container: target_container_required_string
    };
  }

  async getVersionOfFileOfDisk(target_file_required_string, target_disk_required_string) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedFile = escapeForAppleScript(target_file_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedFile} of ${escapedDisk})
          return version of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      file: target_file_required_string,
      disk: target_disk_required_string
    };
  }

  async getVersionOfFileOfFolder(target_file_required_string, target_folder_required_string) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedFile = escapeForAppleScript(target_file_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedFile} of ${escapedFolder})
          return version of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      file: target_file_required_string,
      folder: target_folder_required_string
    };
  }

  async getVersionOfFileOfDesktopObject(target_file_required_string, target_desktop_object_required_string) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedFile = escapeForAppleScript(target_file_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedFile} of ${escapedDesktopObject})
          return version of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      file: target_file_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getVersionOfFileOfTrashObject(target_file_required_string, target_trash_object_required_string) {
    if (!target_file_required_string || typeof target_file_required_string !== "string") {
      throw new Error("target_file_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedFile = escapeForAppleScript(target_file_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedFile} of ${escapedTrashObject})
          return version of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      file: target_file_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getOriginalItemOfAliasFile(target_alias_file_required_string) {
    if (!target_alias_file_required_string || typeof target_alias_file_required_string !== "string") {
      throw new Error("target_alias_file_required_string is required and must be a string");
    }

    const escapedAliasFile = escapeForAppleScript(target_alias_file_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedAliasFile}
          return original item of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      alias_file: target_alias_file_required_string
    };
  }

  async setOriginalItemOfAliasFile(target_alias_file_required_string, value_required_specifier) {
    if (!target_alias_file_required_string || typeof target_alias_file_required_string !== "string") {
      throw new Error("target_alias_file_required_string is required and must be a string");
    }
    if (value_required_specifier === undefined || value_required_specifier === null) {
      throw new Error("value_required_specifier is required");
    }

    const castedAliasFile = castAndEscape(target_alias_file_required_string, 'string');
    const castedValue = castAndEscape(value_required_specifier, 'specifier');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedAliasFile}
          set original item of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_specifier,
      script: script,
      alias_file: target_alias_file_required_string
    };
  }

  async getOriginalItemOfAliasFileOfContainer(target_alias_file_required_string, target_container_required_string) {
    if (!target_alias_file_required_string || typeof target_alias_file_required_string !== "string") {
      throw new Error("target_alias_file_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedAliasFile = escapeForAppleScript(target_alias_file_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedAliasFile} of ${escapedContainer})
          return original item of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      alias_file: target_alias_file_required_string,
      container: target_container_required_string
    };
  }

  async setOriginalItemOfAliasFileOfContainer(target_alias_file_required_string, target_container_required_string, value_required_specifier) {
    if (!target_alias_file_required_string || typeof target_alias_file_required_string !== "string") {
      throw new Error("target_alias_file_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (value_required_specifier === undefined || value_required_specifier === null) {
      throw new Error("value_required_specifier is required");
    }

    const castedAliasFile = castAndEscape(target_alias_file_required_string, 'string');
    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedValue = castAndEscape(value_required_specifier, 'specifier');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedAliasFile} of ${castedContainer})
          set original item of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_specifier,
      script: script,
      alias_file: target_alias_file_required_string,
      container: target_container_required_string
    };
  }

  async getOriginalItemOfAliasFileOfDisk(target_alias_file_required_string, target_disk_required_string) {
    if (!target_alias_file_required_string || typeof target_alias_file_required_string !== "string") {
      throw new Error("target_alias_file_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedAliasFile = escapeForAppleScript(target_alias_file_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedAliasFile} of ${escapedDisk})
          return original item of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      alias_file: target_alias_file_required_string,
      disk: target_disk_required_string
    };
  }

  async setOriginalItemOfAliasFileOfDisk(target_alias_file_required_string, target_disk_required_string, value_required_specifier) {
    if (!target_alias_file_required_string || typeof target_alias_file_required_string !== "string") {
      throw new Error("target_alias_file_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (value_required_specifier === undefined || value_required_specifier === null) {
      throw new Error("value_required_specifier is required");
    }

    const castedAliasFile = castAndEscape(target_alias_file_required_string, 'string');
    const castedDisk = castAndEscape(target_disk_required_string, 'string');
    const castedValue = castAndEscape(value_required_specifier, 'specifier');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedAliasFile} of ${castedDisk})
          set original item of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_specifier,
      script: script,
      alias_file: target_alias_file_required_string,
      disk: target_disk_required_string
    };
  }

  async getOriginalItemOfAliasFileOfFolder(target_alias_file_required_string, target_folder_required_string) {
    if (!target_alias_file_required_string || typeof target_alias_file_required_string !== "string") {
      throw new Error("target_alias_file_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedAliasFile = escapeForAppleScript(target_alias_file_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedAliasFile} of ${escapedFolder})
          return original item of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      alias_file: target_alias_file_required_string,
      folder: target_folder_required_string
    };
  }

  async setOriginalItemOfAliasFileOfFolder(target_alias_file_required_string, target_folder_required_string, value_required_specifier) {
    if (!target_alias_file_required_string || typeof target_alias_file_required_string !== "string") {
      throw new Error("target_alias_file_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }
    if (value_required_specifier === undefined || value_required_specifier === null) {
      throw new Error("value_required_specifier is required");
    }

    const castedAliasFile = castAndEscape(target_alias_file_required_string, 'string');
    const castedFolder = castAndEscape(target_folder_required_string, 'string');
    const castedValue = castAndEscape(value_required_specifier, 'specifier');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedAliasFile} of ${castedFolder})
          set original item of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_specifier,
      script: script,
      alias_file: target_alias_file_required_string,
      folder: target_folder_required_string
    };
  }

  async getOriginalItemOfAliasFileOfDesktopObject(target_alias_file_required_string, target_desktop_object_required_string) {
    if (!target_alias_file_required_string || typeof target_alias_file_required_string !== "string") {
      throw new Error("target_alias_file_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedAliasFile = escapeForAppleScript(target_alias_file_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedAliasFile} of ${escapedDesktopObject})
          return original item of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      alias_file: target_alias_file_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async setOriginalItemOfAliasFileOfDesktopObject(target_alias_file_required_string, target_desktop_object_required_string, value_required_specifier) {
    if (!target_alias_file_required_string || typeof target_alias_file_required_string !== "string") {
      throw new Error("target_alias_file_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }
    if (value_required_specifier === undefined || value_required_specifier === null) {
      throw new Error("value_required_specifier is required");
    }

    const castedAliasFile = castAndEscape(target_alias_file_required_string, 'string');
    const castedDesktopObject = castAndEscape(target_desktop_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_specifier, 'specifier');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedAliasFile} of ${castedDesktopObject})
          set original item of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_specifier,
      script: script,
      alias_file: target_alias_file_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getOriginalItemOfAliasFileOfTrashObject(target_alias_file_required_string, target_trash_object_required_string) {
    if (!target_alias_file_required_string || typeof target_alias_file_required_string !== "string") {
      throw new Error("target_alias_file_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedAliasFile = escapeForAppleScript(target_alias_file_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedAliasFile} of ${escapedTrashObject})
          return original item of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      alias_file: target_alias_file_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async setOriginalItemOfAliasFileOfTrashObject(target_alias_file_required_string, target_trash_object_required_string, value_required_specifier) {
    if (!target_alias_file_required_string || typeof target_alias_file_required_string !== "string") {
      throw new Error("target_alias_file_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }
    if (value_required_specifier === undefined || value_required_specifier === null) {
      throw new Error("value_required_specifier is required");
    }

    const castedAliasFile = castAndEscape(target_alias_file_required_string, 'string');
    const castedTrashObject = castAndEscape(target_trash_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_specifier, 'specifier');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedAliasFile} of ${castedTrashObject})
          set original item of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_specifier,
      script: script,
      alias_file: target_alias_file_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getIdOfApplicationFile(target_application_file_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedApplicationFile}
          return id of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string
    };
  }

  async getIdOfApplicationFileOfContainer(target_application_file_required_string, target_container_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedContainer})
          return id of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      container: target_container_required_string
    };
  }

  async getIdOfApplicationFileOfDisk(target_application_file_required_string, target_disk_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedDisk})
          return id of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      disk: target_disk_required_string
    };
  }

  async getIdOfApplicationFileOfFolder(target_application_file_required_string, target_folder_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedFolder})
          return id of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      folder: target_folder_required_string
    };
  }

  async getIdOfApplicationFileOfDesktopObject(target_application_file_required_string, target_desktop_object_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedDesktopObject})
          return id of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getIdOfApplicationFileOfTrashObject(target_application_file_required_string, target_trash_object_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedTrashObject})
          return id of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getSuggestedSizeOfApplicationFile(target_application_file_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedApplicationFile}
          return suggested size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string
    };
  }

  async getSuggestedSizeOfApplicationFileOfContainer(target_application_file_required_string, target_container_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedContainer})
          return suggested size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      container: target_container_required_string
    };
  }

  async getSuggestedSizeOfApplicationFileOfDisk(target_application_file_required_string, target_disk_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedDisk})
          return suggested size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      disk: target_disk_required_string
    };
  }

  async getSuggestedSizeOfApplicationFileOfFolder(target_application_file_required_string, target_folder_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedFolder})
          return suggested size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      folder: target_folder_required_string
    };
  }

  async getSuggestedSizeOfApplicationFileOfDesktopObject(target_application_file_required_string, target_desktop_object_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedDesktopObject})
          return suggested size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getSuggestedSizeOfApplicationFileOfTrashObject(target_application_file_required_string, target_trash_object_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedTrashObject})
          return suggested size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getMinimumSizeOfApplicationFile(target_application_file_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedApplicationFile}
          return minimum size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string
    };
  }

  async setMinimumSizeOfApplicationFile(target_application_file_required_string, value_required_integer) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (value_required_integer === undefined || value_required_integer === null) {
      throw new Error("value_required_integer is required");
    }

    const castedApplicationFile = castAndEscape(target_application_file_required_string, 'string');
    const castedValue = castAndEscape(value_required_integer, 'integer');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedApplicationFile}
          set minimum size of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_integer,
      script: script,
      application_file: target_application_file_required_string
    };
  }

  async getMinimumSizeOfApplicationFileOfContainer(target_application_file_required_string, target_container_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedContainer})
          return minimum size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      container: target_container_required_string
    };
  }

  async setMinimumSizeOfApplicationFileOfContainer(target_application_file_required_string, target_container_required_string, value_required_integer) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (value_required_integer === undefined || value_required_integer === null) {
      throw new Error("value_required_integer is required");
    }

    const castedApplicationFile = castAndEscape(target_application_file_required_string, 'string');
    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedValue = castAndEscape(value_required_integer, 'integer');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedApplicationFile} of ${castedContainer})
          set minimum size of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_integer,
      script: script,
      application_file: target_application_file_required_string,
      container: target_container_required_string
    };
  }

  async getMinimumSizeOfApplicationFileOfDisk(target_application_file_required_string, target_disk_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedDisk})
          return minimum size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      disk: target_disk_required_string
    };
  }

  async setMinimumSizeOfApplicationFileOfDisk(target_application_file_required_string, target_disk_required_string, value_required_integer) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (value_required_integer === undefined || value_required_integer === null) {
      throw new Error("value_required_integer is required");
    }

    const castedApplicationFile = castAndEscape(target_application_file_required_string, 'string');
    const castedDisk = castAndEscape(target_disk_required_string, 'string');
    const castedValue = castAndEscape(value_required_integer, 'integer');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedApplicationFile} of ${castedDisk})
          set minimum size of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_integer,
      script: script,
      application_file: target_application_file_required_string,
      disk: target_disk_required_string
    };
  }

  async getMinimumSizeOfApplicationFileOfFolder(target_application_file_required_string, target_folder_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedFolder})
          return minimum size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      folder: target_folder_required_string
    };
  }

  async setMinimumSizeOfApplicationFileOfFolder(target_application_file_required_string, target_folder_required_string, value_required_integer) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }
    if (value_required_integer === undefined || value_required_integer === null) {
      throw new Error("value_required_integer is required");
    }

    const castedApplicationFile = castAndEscape(target_application_file_required_string, 'string');
    const castedFolder = castAndEscape(target_folder_required_string, 'string');
    const castedValue = castAndEscape(value_required_integer, 'integer');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedApplicationFile} of ${castedFolder})
          set minimum size of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_integer,
      script: script,
      application_file: target_application_file_required_string,
      folder: target_folder_required_string
    };
  }

  async getMinimumSizeOfApplicationFileOfDesktopObject(target_application_file_required_string, target_desktop_object_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedDesktopObject})
          return minimum size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async setMinimumSizeOfApplicationFileOfDesktopObject(target_application_file_required_string, target_desktop_object_required_string, value_required_integer) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }
    if (value_required_integer === undefined || value_required_integer === null) {
      throw new Error("value_required_integer is required");
    }

    const castedApplicationFile = castAndEscape(target_application_file_required_string, 'string');
    const castedDesktopObject = castAndEscape(target_desktop_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_integer, 'integer');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedApplicationFile} of ${castedDesktopObject})
          set minimum size of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_integer,
      script: script,
      application_file: target_application_file_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getMinimumSizeOfApplicationFileOfTrashObject(target_application_file_required_string, target_trash_object_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedTrashObject})
          return minimum size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async setMinimumSizeOfApplicationFileOfTrashObject(target_application_file_required_string, target_trash_object_required_string, value_required_integer) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }
    if (value_required_integer === undefined || value_required_integer === null) {
      throw new Error("value_required_integer is required");
    }

    const castedApplicationFile = castAndEscape(target_application_file_required_string, 'string');
    const castedTrashObject = castAndEscape(target_trash_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_integer, 'integer');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedApplicationFile} of ${castedTrashObject})
          set minimum size of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_integer,
      script: script,
      application_file: target_application_file_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getPreferredSizeOfApplicationFile(target_application_file_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedApplicationFile}
          return preferred size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string
    };
  }

  async setPreferredSizeOfApplicationFile(target_application_file_required_string, value_required_integer) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (value_required_integer === undefined || value_required_integer === null) {
      throw new Error("value_required_integer is required");
    }

    const castedApplicationFile = castAndEscape(target_application_file_required_string, 'string');
    const castedValue = castAndEscape(value_required_integer, 'integer');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedApplicationFile}
          set preferred size of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_integer,
      script: script,
      application_file: target_application_file_required_string
    };
  }

  async getPreferredSizeOfApplicationFileOfContainer(target_application_file_required_string, target_container_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedContainer})
          return preferred size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      container: target_container_required_string
    };
  }

  async setPreferredSizeOfApplicationFileOfContainer(target_application_file_required_string, target_container_required_string, value_required_integer) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (value_required_integer === undefined || value_required_integer === null) {
      throw new Error("value_required_integer is required");
    }

    const castedApplicationFile = castAndEscape(target_application_file_required_string, 'string');
    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedValue = castAndEscape(value_required_integer, 'integer');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedApplicationFile} of ${castedContainer})
          set preferred size of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_integer,
      script: script,
      application_file: target_application_file_required_string,
      container: target_container_required_string
    };
  }

  async getPreferredSizeOfApplicationFileOfDisk(target_application_file_required_string, target_disk_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedDisk})
          return preferred size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      disk: target_disk_required_string
    };
  }

  async setPreferredSizeOfApplicationFileOfDisk(target_application_file_required_string, target_disk_required_string, value_required_integer) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (value_required_integer === undefined || value_required_integer === null) {
      throw new Error("value_required_integer is required");
    }

    const castedApplicationFile = castAndEscape(target_application_file_required_string, 'string');
    const castedDisk = castAndEscape(target_disk_required_string, 'string');
    const castedValue = castAndEscape(value_required_integer, 'integer');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedApplicationFile} of ${castedDisk})
          set preferred size of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_integer,
      script: script,
      application_file: target_application_file_required_string,
      disk: target_disk_required_string
    };
  }

  async getPreferredSizeOfApplicationFileOfFolder(target_application_file_required_string, target_folder_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedFolder})
          return preferred size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      folder: target_folder_required_string
    };
  }

  async setPreferredSizeOfApplicationFileOfFolder(target_application_file_required_string, target_folder_required_string, value_required_integer) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }
    if (value_required_integer === undefined || value_required_integer === null) {
      throw new Error("value_required_integer is required");
    }

    const castedApplicationFile = castAndEscape(target_application_file_required_string, 'string');
    const castedFolder = castAndEscape(target_folder_required_string, 'string');
    const castedValue = castAndEscape(value_required_integer, 'integer');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedApplicationFile} of ${castedFolder})
          set preferred size of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_integer,
      script: script,
      application_file: target_application_file_required_string,
      folder: target_folder_required_string
    };
  }

  async getPreferredSizeOfApplicationFileOfDesktopObject(target_application_file_required_string, target_desktop_object_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedDesktopObject})
          return preferred size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async setPreferredSizeOfApplicationFileOfDesktopObject(target_application_file_required_string, target_desktop_object_required_string, value_required_integer) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }
    if (value_required_integer === undefined || value_required_integer === null) {
      throw new Error("value_required_integer is required");
    }

    const castedApplicationFile = castAndEscape(target_application_file_required_string, 'string');
    const castedDesktopObject = castAndEscape(target_desktop_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_integer, 'integer');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedApplicationFile} of ${castedDesktopObject})
          set preferred size of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_integer,
      script: script,
      application_file: target_application_file_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getPreferredSizeOfApplicationFileOfTrashObject(target_application_file_required_string, target_trash_object_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedTrashObject})
          return preferred size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async setPreferredSizeOfApplicationFileOfTrashObject(target_application_file_required_string, target_trash_object_required_string, value_required_integer) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }
    if (value_required_integer === undefined || value_required_integer === null) {
      throw new Error("value_required_integer is required");
    }

    const castedApplicationFile = castAndEscape(target_application_file_required_string, 'string');
    const castedTrashObject = castAndEscape(target_trash_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_integer, 'integer');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedApplicationFile} of ${castedTrashObject})
          set preferred size of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_integer,
      script: script,
      application_file: target_application_file_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getAcceptsHighLevelEventsOfApplicationFile(target_application_file_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedApplicationFile}
          return accepts high level events of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string
    };
  }

  async getAcceptsHighLevelEventsOfApplicationFileOfContainer(target_application_file_required_string, target_container_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedContainer})
          return accepts high level events of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      container: target_container_required_string
    };
  }

  async getAcceptsHighLevelEventsOfApplicationFileOfDisk(target_application_file_required_string, target_disk_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedDisk})
          return accepts high level events of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      disk: target_disk_required_string
    };
  }

  async getAcceptsHighLevelEventsOfApplicationFileOfFolder(target_application_file_required_string, target_folder_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedFolder})
          return accepts high level events of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      folder: target_folder_required_string
    };
  }

  async getAcceptsHighLevelEventsOfApplicationFileOfDesktop(target_application_file_required_string, target_desktop_object_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedDesktopObject})
          return accepts high level events of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getAcceptsHighLevelEventsOfApplicationFileOfTrash(target_application_file_required_string, target_trash_object_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedTrashObject})
          return accepts high level events of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getHasScriptingTerminologyOfApplicationFile(target_application_file_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedApplicationFile}
          return has scripting terminology of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string
    };
  }

  async getHasScriptingTerminologyOfApplicationFileOfContainer(target_application_file_required_string, target_container_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedContainer})
          return has scripting terminology of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      container: target_container_required_string
    };
  }

  async getHasScriptingTerminologyOfApplicationFileOfDisk(target_application_file_required_string, target_disk_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedDisk})
          return has scripting terminology of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      disk: target_disk_required_string
    };
  }

  async getHasScriptingTerminologyOfApplicationFileOfFolder(target_application_file_required_string, target_folder_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedFolder})
          return has scripting terminology of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      folder: target_folder_required_string
    };
  }

  async getHasScriptingTerminologyOfApplicationFileOfDesktop(target_application_file_required_string, target_desktop_object_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedDesktopObject})
          return has scripting terminology of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getHasScriptingTerminologyOfApplicationFileOfTrash(target_application_file_required_string, target_trash_object_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedTrashObject})
          return has scripting terminology of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getOpensInClassicOfApplicationFile(target_application_file_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedApplicationFile}
          return opens in Classic of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string
    };
  }

  async setOpensInClassicOfApplicationFile(target_application_file_required_string, value_required_boolean) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedApplicationFile = castAndEscape(target_application_file_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedApplicationFile}
          set opens in Classic of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      application_file: target_application_file_required_string
    };
  }

  async getOpensInClassicOfApplicationFileOfContainer(target_application_file_required_string, target_container_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedContainer})
          return opens in Classic of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      container: target_container_required_string
    };
  }

  async setOpensInClassicOfApplicationFileOfContainer(target_application_file_required_string, target_container_required_string, value_required_boolean) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedApplicationFile = castAndEscape(target_application_file_required_string, 'string');
    const castedContainer = castAndEscape(target_container_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedApplicationFile} of ${castedContainer})
          set opens in Classic of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      application_file: target_application_file_required_string,
      container: target_container_required_string
    };
  }

  async getOpensInClassicOfApplicationFileOfDisk(target_application_file_required_string, target_disk_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedDisk})
          return opens in Classic of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      disk: target_disk_required_string
    };
  }

  async setOpensInClassicOfApplicationFileOfDisk(target_application_file_required_string, target_disk_required_string, value_required_boolean) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedApplicationFile = castAndEscape(target_application_file_required_string, 'string');
    const castedDisk = castAndEscape(target_disk_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedApplicationFile} of ${castedDisk})
          set opens in Classic of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      application_file: target_application_file_required_string,
      disk: target_disk_required_string
    };
  }

  async getOpensInClassicOfApplicationFileOfFolder(target_application_file_required_string, target_folder_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedFolder})
          return opens in Classic of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      folder: target_folder_required_string
    };
  }

  async setOpensInClassicOfApplicationFileOfFolder(target_application_file_required_string, target_folder_required_string, value_required_boolean) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedApplicationFile = castAndEscape(target_application_file_required_string, 'string');
    const castedFolder = castAndEscape(target_folder_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedApplicationFile} of ${castedFolder})
          set opens in Classic of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      application_file: target_application_file_required_string,
      folder: target_folder_required_string
    };
  }

  async getOpensInClassicOfApplicationFileOfDesktopObject(target_application_file_required_string, target_desktop_object_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedDesktopObject})
          return opens in Classic of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async setOpensInClassicOfApplicationFileOfDesktopObject(target_application_file_required_string, target_desktop_object_required_string, value_required_boolean) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedApplicationFile = castAndEscape(target_application_file_required_string, 'string');
    const castedDesktopObject = castAndEscape(target_desktop_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedApplicationFile} of ${castedDesktopObject})
          set opens in Classic of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      application_file: target_application_file_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getOpensInClassicOfApplicationFileOfTrashObject(target_application_file_required_string, target_trash_object_required_string) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedApplicationFile = escapeForAppleScript(target_application_file_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedApplicationFile} of ${escapedTrashObject})
          return opens in Classic of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_file: target_application_file_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async setOpensInClassicOfApplicationFileOfTrashObject(target_application_file_required_string, target_trash_object_required_string, value_required_boolean) {
    if (!target_application_file_required_string || typeof target_application_file_required_string !== "string") {
      throw new Error("target_application_file_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedApplicationFile = castAndEscape(target_application_file_required_string, 'string');
    const castedTrashObject = castAndEscape(target_trash_object_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell (${castedApplicationFile} of ${castedTrashObject})
          set opens in Classic of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      application_file: target_application_file_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getLocationOfInternetLocationFile(target_internet_location_file_required_string) {
    if (!target_internet_location_file_required_string || typeof target_internet_location_file_required_string !== "string") {
      throw new Error("target_internet_location_file_required_string is required and must be a string");
    }

    const escapedInternetLocationFile = escapeForAppleScript(target_internet_location_file_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedInternetLocationFile}
          return location of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      internet_location_file: target_internet_location_file_required_string
    };
  }

  async getLocationOfInternetLocationFileOfContainer(target_internet_location_file_required_string, target_container_required_string) {
    if (!target_internet_location_file_required_string || typeof target_internet_location_file_required_string !== "string") {
      throw new Error("target_internet_location_file_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedInternetLocationFile = escapeForAppleScript(target_internet_location_file_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedInternetLocationFile} of ${escapedContainer})
          return location of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      internet_location_file: target_internet_location_file_required_string,
      container: target_container_required_string
    };
  }

  async getLocationOfInternetLocationFileOfDisk(target_internet_location_file_required_string, target_disk_required_string) {
    if (!target_internet_location_file_required_string || typeof target_internet_location_file_required_string !== "string") {
      throw new Error("target_internet_location_file_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedInternetLocationFile = escapeForAppleScript(target_internet_location_file_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedInternetLocationFile} of ${escapedDisk})
          return location of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      internet_location_file: target_internet_location_file_required_string,
      disk: target_disk_required_string
    };
  }

  async getLocationOfInternetLocationFileOfFolder(target_internet_location_file_required_string, target_folder_required_string) {
    if (!target_internet_location_file_required_string || typeof target_internet_location_file_required_string !== "string") {
      throw new Error("target_internet_location_file_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedInternetLocationFile = escapeForAppleScript(target_internet_location_file_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedInternetLocationFile} of ${escapedFolder})
          return location of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      internet_location_file: target_internet_location_file_required_string,
      folder: target_folder_required_string
    };
  }

  async getLocationOfInternetLocationFileOfDesktopObject(target_internet_location_file_required_string, target_desktop_object_required_string) {
    if (!target_internet_location_file_required_string || typeof target_internet_location_file_required_string !== "string") {
      throw new Error("target_internet_location_file_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedInternetLocationFile = escapeForAppleScript(target_internet_location_file_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedInternetLocationFile} of ${escapedDesktopObject})
          return location of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      internet_location_file: target_internet_location_file_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getLocationOfInternetLocationFileOfTrashObject(target_internet_location_file_required_string, target_trash_object_required_string) {
    if (!target_internet_location_file_required_string || typeof target_internet_location_file_required_string !== "string") {
      throw new Error("target_internet_location_file_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedInternetLocationFile = escapeForAppleScript(target_internet_location_file_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedInternetLocationFile} of ${escapedTrashObject})
          return location of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      internet_location_file: target_internet_location_file_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getClippingWindowOfClipping(target_clipping_required_string) {
    if (!target_clipping_required_string || typeof target_clipping_required_string !== "string") {
      throw new Error("target_clipping_required_string is required and must be a string");
    }

    const escapedClipping = escapeForAppleScript(target_clipping_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedClipping}
          return clipping window of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      clipping: target_clipping_required_string
    };
  }

  async getClippingWindowOfClippingOfContainer(target_clipping_required_string, target_container_required_string) {
    if (!target_clipping_required_string || typeof target_clipping_required_string !== "string") {
      throw new Error("target_clipping_required_string is required and must be a string");
    }
    if (!target_container_required_string || typeof target_container_required_string !== "string") {
      throw new Error("target_container_required_string is required and must be a string");
    }

    const escapedClipping = escapeForAppleScript(target_clipping_required_string);
    const escapedContainer = escapeForAppleScript(target_container_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedClipping} of ${escapedContainer})
          return clipping window of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      clipping: target_clipping_required_string,
      container: target_container_required_string
    };
  }

  async getClippingWindowOfClippingOfDisk(target_clipping_required_string, target_disk_required_string) {
    if (!target_clipping_required_string || typeof target_clipping_required_string !== "string") {
      throw new Error("target_clipping_required_string is required and must be a string");
    }
    if (!target_disk_required_string || typeof target_disk_required_string !== "string") {
      throw new Error("target_disk_required_string is required and must be a string");
    }

    const escapedClipping = escapeForAppleScript(target_clipping_required_string);
    const escapedDisk = escapeForAppleScript(target_disk_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedClipping} of ${escapedDisk})
          return clipping window of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      clipping: target_clipping_required_string,
      disk: target_disk_required_string
    };
  }

  async getClippingWindowOfClippingOfFolder(target_clipping_required_string, target_folder_required_string) {
    if (!target_clipping_required_string || typeof target_clipping_required_string !== "string") {
      throw new Error("target_clipping_required_string is required and must be a string");
    }
    if (!target_folder_required_string || typeof target_folder_required_string !== "string") {
      throw new Error("target_folder_required_string is required and must be a string");
    }

    const escapedClipping = escapeForAppleScript(target_clipping_required_string);
    const escapedFolder = escapeForAppleScript(target_folder_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedClipping} of ${escapedFolder})
          return clipping window of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      clipping: target_clipping_required_string,
      folder: target_folder_required_string
    };
  }

  async getClippingWindowOfClippingOfDesktopObject(target_clipping_required_string, target_desktop_object_required_string) {
    if (!target_clipping_required_string || typeof target_clipping_required_string !== "string") {
      throw new Error("target_clipping_required_string is required and must be a string");
    }
    if (!target_desktop_object_required_string || typeof target_desktop_object_required_string !== "string") {
      throw new Error("target_desktop_object_required_string is required and must be a string");
    }

    const escapedClipping = escapeForAppleScript(target_clipping_required_string);
    const escapedDesktopObject = escapeForAppleScript(target_desktop_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedClipping} of ${escapedDesktopObject})
          return clipping window of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      clipping: target_clipping_required_string,
      desktop_object: target_desktop_object_required_string
    };
  }

  async getClippingWindowOfClippingOfTrashObject(target_clipping_required_string, target_trash_object_required_string) {
    if (!target_clipping_required_string || typeof target_clipping_required_string !== "string") {
      throw new Error("target_clipping_required_string is required and must be a string");
    }
    if (!target_trash_object_required_string || typeof target_trash_object_required_string !== "string") {
      throw new Error("target_trash_object_required_string is required and must be a string");
    }

    const escapedClipping = escapeForAppleScript(target_clipping_required_string);
    const escapedTrashObject = escapeForAppleScript(target_trash_object_required_string);

    const script = `
      tell application "Finder"
        tell (${escapedClipping} of ${escapedTrashObject})
          return clipping window of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      clipping: target_clipping_required_string,
      trash_object: target_trash_object_required_string
    };
  }

  async getPositionOfWindow(target_window_required_string) {
    if (!target_window_required_string || typeof target_window_required_string !== "string") {
      throw new Error("target_window_required_string is required and must be a string");
    }

    const escapedWindow = escapeForAppleScript(target_window_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedWindow}
          return position of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      window: target_window_required_string
    };
  }

  async setPositionOfWindow(target_window_required_string, value_required_point) {
    if (!target_window_required_string || typeof target_window_required_string !== "string") {
      throw new Error("target_window_required_string is required and must be a string");
    }
    if (value_required_point === undefined || value_required_point === null) {
      throw new Error("value_required_point is required");
    }

    const castedWindow = castAndEscape(target_window_required_string, 'string');
    const castedValue = castAndEscape(value_required_point, 'point');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedWindow}
          set position of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_point,
      script: script,
      window: target_window_required_string
    };
  }

  async getTitledOfWindow(target_window_required_string) {
    if (!target_window_required_string || typeof target_window_required_string !== "string") {
      throw new Error("target_window_required_string is required and must be a string");
    }

    const escapedWindow = escapeForAppleScript(target_window_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedWindow}
          return titled of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      window: target_window_required_string
    };
  }

  async getFloatingOfWindow(target_window_required_string) {
    if (!target_window_required_string || typeof target_window_required_string !== "string") {
      throw new Error("target_window_required_string is required and must be a string");
    }

    const escapedWindow = escapeForAppleScript(target_window_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedWindow}
          return floating of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      window: target_window_required_string
    };
  }

  async getModalOfWindow(target_window_required_string) {
    if (!target_window_required_string || typeof target_window_required_string !== "string") {
      throw new Error("target_window_required_string is required and must be a string");
    }

    const escapedWindow = escapeForAppleScript(target_window_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedWindow}
          return modal of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      window: target_window_required_string
    };
  }

  async getCollapsedOfWindow(target_window_required_string) {
    if (!target_window_required_string || typeof target_window_required_string !== "string") {
      throw new Error("target_window_required_string is required and must be a string");
    }

    const escapedWindow = escapeForAppleScript(target_window_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedWindow}
          return collapsed of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      window: target_window_required_string
    };
  }

  async setCollapsedOfWindow(target_window_required_string, value_required_boolean) {
    if (!target_window_required_string || typeof target_window_required_string !== "string") {
      throw new Error("target_window_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedWindow = castAndEscape(target_window_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedWindow}
          set collapsed of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      window: target_window_required_string
    };
  }

  async getPropertiesOfWindow(target_window_required_string) {
    if (!target_window_required_string || typeof target_window_required_string !== "string") {
      throw new Error("target_window_required_string is required and must be a string");
    }

    const escapedWindow = escapeForAppleScript(target_window_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedWindow}
          return properties of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      window: target_window_required_string
    };
  }

  async setPropertiesOfWindow(target_window_required_string, value_required_record) {
    if (!target_window_required_string || typeof target_window_required_string !== "string") {
      throw new Error("target_window_required_string is required and must be a string");
    }
    if (value_required_record === undefined || value_required_record === null) {
      throw new Error("value_required_record is required");
    }

    const castedWindow = castAndEscape(target_window_required_string, 'string');
    const castedValue = castAndEscape(value_required_record, 'record');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedWindow}
          set properties of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_record,
      script: script,
      window: target_window_required_string
    };
  }

  async getTargetOfFinderWindow(target_finder_window_required_string) {
    if (!target_finder_window_required_string || typeof target_finder_window_required_string !== "string") {
      throw new Error("target_finder_window_required_string is required and must be a string");
    }

    const escapedFinderWindow = escapeForAppleScript(target_finder_window_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedFinderWindow}
          return target of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      finder_window: target_finder_window_required_string
    };
  }

  async setTargetOfFinderWindow(target_finder_window_required_string, value_required_specifier) {
    if (!target_finder_window_required_string || typeof target_finder_window_required_string !== "string") {
      throw new Error("target_finder_window_required_string is required and must be a string");
    }
    if (value_required_specifier === undefined || value_required_specifier === null) {
      throw new Error("value_required_specifier is required");
    }

    const castedFinderWindow = castAndEscape(target_finder_window_required_string, 'string');
    const castedValue = castAndEscape(value_required_specifier, 'specifier');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedFinderWindow}
          set target of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_specifier,
      script: script,
      finder_window: target_finder_window_required_string
    };
  }

  async getCurrentViewOfFinderWindow(target_finder_window_required_string) {
    if (!target_finder_window_required_string || typeof target_finder_window_required_string !== "string") {
      throw new Error("target_finder_window_required_string is required and must be a string");
    }

    const escapedFinderWindow = escapeForAppleScript(target_finder_window_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedFinderWindow}
          return current view of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      finder_window: target_finder_window_required_string
    };
  }

  async setCurrentViewOfFinderWindow(target_finder_window_required_string, value_required_ecvw) {
    if (!target_finder_window_required_string || typeof target_finder_window_required_string !== "string") {
      throw new Error("target_finder_window_required_string is required and must be a string");
    }
    if (value_required_ecvw === undefined || value_required_ecvw === null) {
      throw new Error("value_required_ecvw is required");
    }

    const castedFinderWindow = castAndEscape(target_finder_window_required_string, 'string');
    const castedValue = castAndEscape(value_required_ecvw, 'ecvw');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedFinderWindow}
          set current view of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_ecvw,
      script: script,
      finder_window: target_finder_window_required_string
    };
  }

  async getIconViewOptionsOfFinderWindow(target_finder_window_required_string) {
    if (!target_finder_window_required_string || typeof target_finder_window_required_string !== "string") {
      throw new Error("target_finder_window_required_string is required and must be a string");
    }

    const escapedFinderWindow = escapeForAppleScript(target_finder_window_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedFinderWindow}
          return icon view options of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      finder_window: target_finder_window_required_string
    };
  }

  async getListViewOptionsOfFinderWindow(target_finder_window_required_string) {
    if (!target_finder_window_required_string || typeof target_finder_window_required_string !== "string") {
      throw new Error("target_finder_window_required_string is required and must be a string");
    }

    const escapedFinderWindow = escapeForAppleScript(target_finder_window_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedFinderWindow}
          return list view options of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      finder_window: target_finder_window_required_string
    };
  }

  async getColumnViewOptionsOfFinderWindow(target_finder_window_required_string) {
    if (!target_finder_window_required_string || typeof target_finder_window_required_string !== "string") {
      throw new Error("target_finder_window_required_string is required and must be a string");
    }

    const escapedFinderWindow = escapeForAppleScript(target_finder_window_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedFinderWindow}
          return column view options of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      finder_window: target_finder_window_required_string
    };
  }

  async getToolbarVisibleOfFinderWindow(target_finder_window_required_string) {
    if (!target_finder_window_required_string || typeof target_finder_window_required_string !== "string") {
      throw new Error("target_finder_window_required_string is required and must be a string");
    }

    const escapedFinderWindow = escapeForAppleScript(target_finder_window_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedFinderWindow}
          return toolbar visible of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      finder_window: target_finder_window_required_string
    };
  }

  async setToolbarVisibleOfFinderWindow(target_finder_window_required_string, value_required_boolean) {
    if (!target_finder_window_required_string || typeof target_finder_window_required_string !== "string") {
      throw new Error("target_finder_window_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedFinderWindow = castAndEscape(target_finder_window_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedFinderWindow}
          set toolbar visible of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      finder_window: target_finder_window_required_string
    };
  }

  async getStatusbarVisibleOfFinderWindow(target_finder_window_required_string) {
    if (!target_finder_window_required_string || typeof target_finder_window_required_string !== "string") {
      throw new Error("target_finder_window_required_string is required and must be a string");
    }

    const escapedFinderWindow = escapeForAppleScript(target_finder_window_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedFinderWindow}
          return statusbar visible of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      finder_window: target_finder_window_required_string
    };
  }

  async setStatusbarVisibleOfFinderWindow(target_finder_window_required_string, value_required_boolean) {
    if (!target_finder_window_required_string || typeof target_finder_window_required_string !== "string") {
      throw new Error("target_finder_window_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedFinderWindow = castAndEscape(target_finder_window_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedFinderWindow}
          set statusbar visible of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      finder_window: target_finder_window_required_string
    };
  }

  async getPathbarVisibleOfFinderWindow(target_finder_window_required_string) {
    if (!target_finder_window_required_string || typeof target_finder_window_required_string !== "string") {
      throw new Error("target_finder_window_required_string is required and must be a string");
    }

    const escapedFinderWindow = escapeForAppleScript(target_finder_window_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedFinderWindow}
          return pathbar visible of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      finder_window: target_finder_window_required_string
    };
  }

  async setPathbarVisibleOfFinderWindow(target_finder_window_required_string, value_required_boolean) {
    if (!target_finder_window_required_string || typeof target_finder_window_required_string !== "string") {
      throw new Error("target_finder_window_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedFinderWindow = castAndEscape(target_finder_window_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedFinderWindow}
          set pathbar visible of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      finder_window: target_finder_window_required_string
    };
  }

  async getSidebarWidthOfFinderWindow(target_finder_window_required_string) {
    if (!target_finder_window_required_string || typeof target_finder_window_required_string !== "string") {
      throw new Error("target_finder_window_required_string is required and must be a string");
    }

    const escapedFinderWindow = escapeForAppleScript(target_finder_window_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedFinderWindow}
          return sidebar width of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      finder_window: target_finder_window_required_string
    };
  }

  async setSidebarWidthOfFinderWindow(target_finder_window_required_string, value_required_integer) {
    if (!target_finder_window_required_string || typeof target_finder_window_required_string !== "string") {
      throw new Error("target_finder_window_required_string is required and must be a string");
    }
    if (value_required_integer === undefined || value_required_integer === null) {
      throw new Error("value_required_integer is required");
    }

    const castedFinderWindow = castAndEscape(target_finder_window_required_string, 'string');
    const castedValue = castAndEscape(value_required_integer, 'integer');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedFinderWindow}
          set sidebar width of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_integer,
      script: script,
      finder_window: target_finder_window_required_string
    };
  }

  async getItemOfInformationWindow(target_information_window_required_string) {
    if (!target_information_window_required_string || typeof target_information_window_required_string !== "string") {
      throw new Error("target_information_window_required_string is required and must be a string");
    }

    const escapedInformationWindow = escapeForAppleScript(target_information_window_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedInformationWindow}
          return item of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      information_window: target_information_window_required_string
    };
  }

  async getCurrentPanelOfInformationWindow(target_information_window_required_string) {
    if (!target_information_window_required_string || typeof target_information_window_required_string !== "string") {
      throw new Error("target_information_window_required_string is required and must be a string");
    }

    const escapedInformationWindow = escapeForAppleScript(target_information_window_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedInformationWindow}
          return current panel of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      information_window: target_information_window_required_string
    };
  }

  async setCurrentPanelOfInformationWindow(target_information_window_required_string, value_required_ipnl) {
    if (!target_information_window_required_string || typeof target_information_window_required_string !== "string") {
      throw new Error("target_information_window_required_string is required and must be a string");
    }
    if (value_required_ipnl === undefined || value_required_ipnl === null) {
      throw new Error("value_required_ipnl is required");
    }

    const castedInformationWindow = castAndEscape(target_information_window_required_string, 'string');
    const castedValue = castAndEscape(value_required_ipnl, 'ipnl');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedInformationWindow}
          set current panel of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_ipnl,
      script: script,
      information_window: target_information_window_required_string
    };
  }

  async getCurrentPanelOfPreferencesWindow(target_preferences_window_required_string) {
    if (!target_preferences_window_required_string || typeof target_preferences_window_required_string !== "string") {
      throw new Error("target_preferences_window_required_string is required and must be a string");
    }

    const escapedPreferencesWindow = escapeForAppleScript(target_preferences_window_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedPreferencesWindow}
          return current panel of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      preferences_window: target_preferences_window_required_string
    };
  }

  async setCurrentPanelOfPreferencesWindow(target_preferences_window_required_string, value_required_pple) {
    if (!target_preferences_window_required_string || typeof target_preferences_window_required_string !== "string") {
      throw new Error("target_preferences_window_required_string is required and must be a string");
    }
    if (value_required_pple === undefined || value_required_pple === null) {
      throw new Error("value_required_pple is required");
    }

    const castedPreferencesWindow = castAndEscape(target_preferences_window_required_string, 'string');
    const castedValue = castAndEscape(value_required_pple, 'pple');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedPreferencesWindow}
          set current panel of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_pple,
      script: script,
      preferences_window: target_preferences_window_required_string
    };
  }

  async restart() {
    const script = `
      tell application "Finder"
        restart
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async shutDown() {
    const script = `
      tell application "Finder"
        shut down
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async sleep() {
    const script = `
      tell application "Finder"
        sleep
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: result,
      script: script
    };
  }

  async getDesktopPictureOfApplication(target_application_required_string) {
    if (!target_application_required_string || typeof target_application_required_string !== "string") {
      throw new Error("target_application_required_string is required and must be a string");
    }

    const escapedApplication = escapeForAppleScript(target_application_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedApplication}
          return desktop picture of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application: target_application_required_string
    };
  }

  async setDesktopPictureOfApplication(target_application_required_string, value_required_file) {
    if (!target_application_required_string || typeof target_application_required_string !== "string") {
      throw new Error("target_application_required_string is required and must be a string");
    }
    if (value_required_file === undefined || value_required_file === null) {
      throw new Error("value_required_file is required");
    }

    const castedApplication = castAndEscape(target_application_required_string, 'string');
    const castedValue = castAndEscape(value_required_file, 'file');
    // Determine value format for AppleScript
    let valueForScript;
    // Property type 'file' is a class reference - treat as object
    valueForScript = castedValue; // Object reference - no quotes

    const script = `
      tell application "Finder"
        tell ${castedApplication}
          set desktop picture of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_file,
      script: script,
      application: target_application_required_string
    };
  }

  async getNameOfProcess(target_process_required_string) {
    if (!target_process_required_string || typeof target_process_required_string !== "string") {
      throw new Error("target_process_required_string is required and must be a string");
    }

    const escapedProcess = escapeForAppleScript(target_process_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedProcess}
          return name of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      process: target_process_required_string
    };
  }

  async getVisibleOfProcess(target_process_required_string) {
    if (!target_process_required_string || typeof target_process_required_string !== "string") {
      throw new Error("target_process_required_string is required and must be a string");
    }

    const escapedProcess = escapeForAppleScript(target_process_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedProcess}
          return visible of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      process: target_process_required_string
    };
  }

  async setVisibleOfProcess(target_process_required_string, value_required_boolean) {
    if (!target_process_required_string || typeof target_process_required_string !== "string") {
      throw new Error("target_process_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedProcess = castAndEscape(target_process_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedProcess}
          set visible of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      process: target_process_required_string
    };
  }

  async getFrontmostOfProcess(target_process_required_string) {
    if (!target_process_required_string || typeof target_process_required_string !== "string") {
      throw new Error("target_process_required_string is required and must be a string");
    }

    const escapedProcess = escapeForAppleScript(target_process_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedProcess}
          return frontmost of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      process: target_process_required_string
    };
  }

  async setFrontmostOfProcess(target_process_required_string, value_required_boolean) {
    if (!target_process_required_string || typeof target_process_required_string !== "string") {
      throw new Error("target_process_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedProcess = castAndEscape(target_process_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedProcess}
          set frontmost of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      process: target_process_required_string
    };
  }

  async getFileOfProcess(target_process_required_string) {
    if (!target_process_required_string || typeof target_process_required_string !== "string") {
      throw new Error("target_process_required_string is required and must be a string");
    }

    const escapedProcess = escapeForAppleScript(target_process_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedProcess}
          return file of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      process: target_process_required_string
    };
  }

  async getFileTypeOfProcess(target_process_required_string) {
    if (!target_process_required_string || typeof target_process_required_string !== "string") {
      throw new Error("target_process_required_string is required and must be a string");
    }

    const escapedProcess = escapeForAppleScript(target_process_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedProcess}
          return file type of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      process: target_process_required_string
    };
  }

  async getCreatorTypeOfProcess(target_process_required_string) {
    if (!target_process_required_string || typeof target_process_required_string !== "string") {
      throw new Error("target_process_required_string is required and must be a string");
    }

    const escapedProcess = escapeForAppleScript(target_process_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedProcess}
          return creator type of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      process: target_process_required_string
    };
  }

  async getAcceptsHighLevelEventsOfProcess(target_process_required_string) {
    if (!target_process_required_string || typeof target_process_required_string !== "string") {
      throw new Error("target_process_required_string is required and must be a string");
    }

    const escapedProcess = escapeForAppleScript(target_process_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedProcess}
          return accepts high level events of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      process: target_process_required_string
    };
  }

  async getAcceptsRemoteEventsOfProcess(target_process_required_string) {
    if (!target_process_required_string || typeof target_process_required_string !== "string") {
      throw new Error("target_process_required_string is required and must be a string");
    }

    const escapedProcess = escapeForAppleScript(target_process_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedProcess}
          return accepts remote events of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      process: target_process_required_string
    };
  }

  async getHasScriptingTerminologyOfProcess(target_process_required_string) {
    if (!target_process_required_string || typeof target_process_required_string !== "string") {
      throw new Error("target_process_required_string is required and must be a string");
    }

    const escapedProcess = escapeForAppleScript(target_process_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedProcess}
          return has scripting terminology of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      process: target_process_required_string
    };
  }

  async getTotalPartitionSizeOfProcess(target_process_required_string) {
    if (!target_process_required_string || typeof target_process_required_string !== "string") {
      throw new Error("target_process_required_string is required and must be a string");
    }

    const escapedProcess = escapeForAppleScript(target_process_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedProcess}
          return total partition size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      process: target_process_required_string
    };
  }

  async getPartitionSpaceUsedOfProcess(target_process_required_string) {
    if (!target_process_required_string || typeof target_process_required_string !== "string") {
      throw new Error("target_process_required_string is required and must be a string");
    }

    const escapedProcess = escapeForAppleScript(target_process_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedProcess}
          return partition space used of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      process: target_process_required_string
    };
  }

  async getApplicationFileOfApplicationProcess(target_application_process_required_string) {
    if (!target_application_process_required_string || typeof target_application_process_required_string !== "string") {
      throw new Error("target_application_process_required_string is required and must be a string");
    }

    const escapedApplicationProcess = escapeForAppleScript(target_application_process_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedApplicationProcess}
          return application file of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      application_process: target_application_process_required_string
    };
  }

  async getDeskAccessoryFileOfDeskAccessoryProcess(target_desk_accessory_process_required_string) {
    if (!target_desk_accessory_process_required_string || typeof target_desk_accessory_process_required_string !== "string") {
      throw new Error("target_desk_accessory_process_required_string is required and must be a string");
    }

    const escapedDeskAccessoryProcess = escapeForAppleScript(target_desk_accessory_process_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedDeskAccessoryProcess}
          return desk accessory file of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      desk_accessory_process: target_desk_accessory_process_required_string
    };
  }

  async getWindowOfPreferences(target_preferences_required_string) {
    if (!target_preferences_required_string || typeof target_preferences_required_string !== "string") {
      throw new Error("target_preferences_required_string is required and must be a string");
    }

    const escapedPreferences = escapeForAppleScript(target_preferences_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedPreferences}
          return window of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      preferences: target_preferences_required_string
    };
  }

  async getIconViewOptionsOfPreferences(target_preferences_required_string) {
    if (!target_preferences_required_string || typeof target_preferences_required_string !== "string") {
      throw new Error("target_preferences_required_string is required and must be a string");
    }

    const escapedPreferences = escapeForAppleScript(target_preferences_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedPreferences}
          return icon view options of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      preferences: target_preferences_required_string
    };
  }

  async getListViewOptionsOfPreferences(target_preferences_required_string) {
    if (!target_preferences_required_string || typeof target_preferences_required_string !== "string") {
      throw new Error("target_preferences_required_string is required and must be a string");
    }

    const escapedPreferences = escapeForAppleScript(target_preferences_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedPreferences}
          return list view options of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      preferences: target_preferences_required_string
    };
  }

  async getColumnViewOptionsOfPreferences(target_preferences_required_string) {
    if (!target_preferences_required_string || typeof target_preferences_required_string !== "string") {
      throw new Error("target_preferences_required_string is required and must be a string");
    }

    const escapedPreferences = escapeForAppleScript(target_preferences_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedPreferences}
          return column view options of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      preferences: target_preferences_required_string
    };
  }

  async getFoldersSpringOpenOfPreferences(target_preferences_required_string) {
    if (!target_preferences_required_string || typeof target_preferences_required_string !== "string") {
      throw new Error("target_preferences_required_string is required and must be a string");
    }

    const escapedPreferences = escapeForAppleScript(target_preferences_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedPreferences}
          return folders spring open of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      preferences: target_preferences_required_string
    };
  }

  async setFoldersSpringOpenOfPreferences(target_preferences_required_string, value_required_boolean) {
    if (!target_preferences_required_string || typeof target_preferences_required_string !== "string") {
      throw new Error("target_preferences_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedPreferences = castAndEscape(target_preferences_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedPreferences}
          set folders spring open of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      preferences: target_preferences_required_string
    };
  }

  async getDelayBeforeSpringingOfPreferences(target_preferences_required_string) {
    if (!target_preferences_required_string || typeof target_preferences_required_string !== "string") {
      throw new Error("target_preferences_required_string is required and must be a string");
    }

    const escapedPreferences = escapeForAppleScript(target_preferences_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedPreferences}
          return delay before springing of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      preferences: target_preferences_required_string
    };
  }

  async setDelayBeforeSpringingOfPreferences(target_preferences_required_string, value_required_real) {
    if (!target_preferences_required_string || typeof target_preferences_required_string !== "string") {
      throw new Error("target_preferences_required_string is required and must be a string");
    }
    if (value_required_real === undefined || value_required_real === null) {
      throw new Error("value_required_real is required");
    }

    const castedPreferences = castAndEscape(target_preferences_required_string, 'string');
    const castedValue = castAndEscape(value_required_real, 'real');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedPreferences}
          set delay before springing of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_real,
      script: script,
      preferences: target_preferences_required_string
    };
  }

  async getDesktopShowsHardDisksOfPreferences(target_preferences_required_string) {
    if (!target_preferences_required_string || typeof target_preferences_required_string !== "string") {
      throw new Error("target_preferences_required_string is required and must be a string");
    }

    const escapedPreferences = escapeForAppleScript(target_preferences_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedPreferences}
          return desktop shows hard disks of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      preferences: target_preferences_required_string
    };
  }

  async setDesktopShowsHardDisksOfPreferences(target_preferences_required_string, value_required_boolean) {
    if (!target_preferences_required_string || typeof target_preferences_required_string !== "string") {
      throw new Error("target_preferences_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedPreferences = castAndEscape(target_preferences_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedPreferences}
          set desktop shows hard disks of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      preferences: target_preferences_required_string
    };
  }

  async getDesktopShowsExternalHardDisksOfPreferences(target_preferences_required_string) {
    if (!target_preferences_required_string || typeof target_preferences_required_string !== "string") {
      throw new Error("target_preferences_required_string is required and must be a string");
    }

    const escapedPreferences = escapeForAppleScript(target_preferences_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedPreferences}
          return desktop shows external hard disks of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      preferences: target_preferences_required_string
    };
  }

  async setDesktopShowsExternalHardDisksOfPreferences(target_preferences_required_string, value_required_boolean) {
    if (!target_preferences_required_string || typeof target_preferences_required_string !== "string") {
      throw new Error("target_preferences_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedPreferences = castAndEscape(target_preferences_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedPreferences}
          set desktop shows external hard disks of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      preferences: target_preferences_required_string
    };
  }

  async getDesktopShowsRemovableMediaOfPreferences(target_preferences_required_string) {
    if (!target_preferences_required_string || typeof target_preferences_required_string !== "string") {
      throw new Error("target_preferences_required_string is required and must be a string");
    }

    const escapedPreferences = escapeForAppleScript(target_preferences_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedPreferences}
          return desktop shows removable media of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      preferences: target_preferences_required_string
    };
  }

  async setDesktopShowsRemovableMediaOfPreferences(target_preferences_required_string, value_required_boolean) {
    if (!target_preferences_required_string || typeof target_preferences_required_string !== "string") {
      throw new Error("target_preferences_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedPreferences = castAndEscape(target_preferences_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedPreferences}
          set desktop shows removable media of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      preferences: target_preferences_required_string
    };
  }

  async getDesktopShowsConnectedServersOfPreferences(target_preferences_required_string) {
    if (!target_preferences_required_string || typeof target_preferences_required_string !== "string") {
      throw new Error("target_preferences_required_string is required and must be a string");
    }

    const escapedPreferences = escapeForAppleScript(target_preferences_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedPreferences}
          return desktop shows connected servers of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      preferences: target_preferences_required_string
    };
  }

  async setDesktopShowsConnectedServersOfPreferences(target_preferences_required_string, value_required_boolean) {
    if (!target_preferences_required_string || typeof target_preferences_required_string !== "string") {
      throw new Error("target_preferences_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedPreferences = castAndEscape(target_preferences_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedPreferences}
          set desktop shows connected servers of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      preferences: target_preferences_required_string
    };
  }

  async getNewWindowTargetOfPreferences(target_preferences_required_string) {
    if (!target_preferences_required_string || typeof target_preferences_required_string !== "string") {
      throw new Error("target_preferences_required_string is required and must be a string");
    }

    const escapedPreferences = escapeForAppleScript(target_preferences_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedPreferences}
          return new window target of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      preferences: target_preferences_required_string
    };
  }

  async setNewWindowTargetOfPreferences(target_preferences_required_string, value_required_specifier) {
    if (!target_preferences_required_string || typeof target_preferences_required_string !== "string") {
      throw new Error("target_preferences_required_string is required and must be a string");
    }
    if (value_required_specifier === undefined || value_required_specifier === null) {
      throw new Error("value_required_specifier is required");
    }

    const castedPreferences = castAndEscape(target_preferences_required_string, 'string');
    const castedValue = castAndEscape(value_required_specifier, 'specifier');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedPreferences}
          set new window target of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_specifier,
      script: script,
      preferences: target_preferences_required_string
    };
  }

  async getFoldersOpenInNewWindowsOfPreferences(target_preferences_required_string) {
    if (!target_preferences_required_string || typeof target_preferences_required_string !== "string") {
      throw new Error("target_preferences_required_string is required and must be a string");
    }

    const escapedPreferences = escapeForAppleScript(target_preferences_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedPreferences}
          return folders open in new windows of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      preferences: target_preferences_required_string
    };
  }

  async setFoldersOpenInNewWindowsOfPreferences(target_preferences_required_string, value_required_boolean) {
    if (!target_preferences_required_string || typeof target_preferences_required_string !== "string") {
      throw new Error("target_preferences_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedPreferences = castAndEscape(target_preferences_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedPreferences}
          set folders open in new windows of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      preferences: target_preferences_required_string
    };
  }

  async getFoldersOpenInNewTabsOfPreferences(target_preferences_required_string) {
    if (!target_preferences_required_string || typeof target_preferences_required_string !== "string") {
      throw new Error("target_preferences_required_string is required and must be a string");
    }

    const escapedPreferences = escapeForAppleScript(target_preferences_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedPreferences}
          return folders open in new tabs of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      preferences: target_preferences_required_string
    };
  }

  async setFoldersOpenInNewTabsOfPreferences(target_preferences_required_string, value_required_boolean) {
    if (!target_preferences_required_string || typeof target_preferences_required_string !== "string") {
      throw new Error("target_preferences_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedPreferences = castAndEscape(target_preferences_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedPreferences}
          set folders open in new tabs of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      preferences: target_preferences_required_string
    };
  }

  async getNewWindowsOpenInColumnViewOfPreferences(target_preferences_required_string) {
    if (!target_preferences_required_string || typeof target_preferences_required_string !== "string") {
      throw new Error("target_preferences_required_string is required and must be a string");
    }

    const escapedPreferences = escapeForAppleScript(target_preferences_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedPreferences}
          return new windows open in column view of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      preferences: target_preferences_required_string
    };
  }

  async setNewWindowsOpenInColumnViewOfPreferences(target_preferences_required_string, value_required_boolean) {
    if (!target_preferences_required_string || typeof target_preferences_required_string !== "string") {
      throw new Error("target_preferences_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedPreferences = castAndEscape(target_preferences_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedPreferences}
          set new windows open in column view of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      preferences: target_preferences_required_string
    };
  }

  async getAllNameExtensionsShowingOfPreferences(target_preferences_required_string) {
    if (!target_preferences_required_string || typeof target_preferences_required_string !== "string") {
      throw new Error("target_preferences_required_string is required and must be a string");
    }

    const escapedPreferences = escapeForAppleScript(target_preferences_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedPreferences}
          return all name extensions showing of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      preferences: target_preferences_required_string
    };
  }

  async setAllNameExtensionsShowingOfPreferences(target_preferences_required_string, value_required_boolean) {
    if (!target_preferences_required_string || typeof target_preferences_required_string !== "string") {
      throw new Error("target_preferences_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedPreferences = castAndEscape(target_preferences_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedPreferences}
          set all name extensions showing of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      preferences: target_preferences_required_string
    };
  }

  async getNameOfLabel(target_label_required_string) {
    if (!target_label_required_string || typeof target_label_required_string !== "string") {
      throw new Error("target_label_required_string is required and must be a string");
    }

    const escapedLabel = escapeForAppleScript(target_label_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedLabel}
          return name of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      label: target_label_required_string
    };
  }

  async setNameOfLabel(target_label_required_string, value_required_text) {
    if (!target_label_required_string || typeof target_label_required_string !== "string") {
      throw new Error("target_label_required_string is required and must be a string");
    }
    if (value_required_text === undefined || value_required_text === null) {
      throw new Error("value_required_text is required");
    }

    const castedLabel = castAndEscape(target_label_required_string, 'string');
    const castedValue = castAndEscape(value_required_text, 'text');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedLabel}
          set name of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_text,
      script: script,
      label: target_label_required_string
    };
  }

  async getIndexOfLabel(target_label_required_string) {
    if (!target_label_required_string || typeof target_label_required_string !== "string") {
      throw new Error("target_label_required_string is required and must be a string");
    }

    const escapedLabel = escapeForAppleScript(target_label_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedLabel}
          return index of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      label: target_label_required_string
    };
  }

  async setIndexOfLabel(target_label_required_string, value_required_integer) {
    if (!target_label_required_string || typeof target_label_required_string !== "string") {
      throw new Error("target_label_required_string is required and must be a string");
    }
    if (value_required_integer === undefined || value_required_integer === null) {
      throw new Error("value_required_integer is required");
    }

    const castedLabel = castAndEscape(target_label_required_string, 'string');
    const castedValue = castAndEscape(value_required_integer, 'integer');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedLabel}
          set index of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_integer,
      script: script,
      label: target_label_required_string
    };
  }

  async getColorOfLabel(target_label_required_string) {
    if (!target_label_required_string || typeof target_label_required_string !== "string") {
      throw new Error("target_label_required_string is required and must be a string");
    }

    const escapedLabel = escapeForAppleScript(target_label_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedLabel}
          return color of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      label: target_label_required_string
    };
  }

  async setColorOfLabel(target_label_required_string, value_required_rgb_color) {
    if (!target_label_required_string || typeof target_label_required_string !== "string") {
      throw new Error("target_label_required_string is required and must be a string");
    }
    if (value_required_rgb_color === undefined || value_required_rgb_color === null) {
      throw new Error("value_required_rgb_color is required");
    }

    const castedLabel = castAndEscape(target_label_required_string, 'string');
    const castedValue = castAndEscape(value_required_rgb_color, 'RGB color');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedLabel}
          set color of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_rgb_color,
      script: script,
      label: target_label_required_string
    };
  }

  async getLargeMonochromeIconAndMaskOfIconFamily(target_icon_family_required_string) {
    if (!target_icon_family_required_string || typeof target_icon_family_required_string !== "string") {
      throw new Error("target_icon_family_required_string is required and must be a string");
    }

    const escapedIconFamily = escapeForAppleScript(target_icon_family_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedIconFamily}
          return large monochrome icon and mask of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      icon_family: target_icon_family_required_string
    };
  }

  async getLarge8BitMaskOfIconFamily(target_icon_family_required_string) {
    if (!target_icon_family_required_string || typeof target_icon_family_required_string !== "string") {
      throw new Error("target_icon_family_required_string is required and must be a string");
    }

    const escapedIconFamily = escapeForAppleScript(target_icon_family_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedIconFamily}
          return large 8 bit mask of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      icon_family: target_icon_family_required_string
    };
  }

  async getLarge32BitIconOfIconFamily(target_icon_family_required_string) {
    if (!target_icon_family_required_string || typeof target_icon_family_required_string !== "string") {
      throw new Error("target_icon_family_required_string is required and must be a string");
    }

    const escapedIconFamily = escapeForAppleScript(target_icon_family_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedIconFamily}
          return large 32 bit icon of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      icon_family: target_icon_family_required_string
    };
  }

  async getLarge8BitIconOfIconFamily(target_icon_family_required_string) {
    if (!target_icon_family_required_string || typeof target_icon_family_required_string !== "string") {
      throw new Error("target_icon_family_required_string is required and must be a string");
    }

    const escapedIconFamily = escapeForAppleScript(target_icon_family_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedIconFamily}
          return large 8 bit icon of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      icon_family: target_icon_family_required_string
    };
  }

  async getLarge4BitIconOfIconFamily(target_icon_family_required_string) {
    if (!target_icon_family_required_string || typeof target_icon_family_required_string !== "string") {
      throw new Error("target_icon_family_required_string is required and must be a string");
    }

    const escapedIconFamily = escapeForAppleScript(target_icon_family_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedIconFamily}
          return large 4 bit icon of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      icon_family: target_icon_family_required_string
    };
  }

  async getSmallMonochromeIconAndMaskOfIconFamily(target_icon_family_required_string) {
    if (!target_icon_family_required_string || typeof target_icon_family_required_string !== "string") {
      throw new Error("target_icon_family_required_string is required and must be a string");
    }

    const escapedIconFamily = escapeForAppleScript(target_icon_family_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedIconFamily}
          return small monochrome icon and mask of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      icon_family: target_icon_family_required_string
    };
  }

  async getSmall8BitMaskOfIconFamily(target_icon_family_required_string) {
    if (!target_icon_family_required_string || typeof target_icon_family_required_string !== "string") {
      throw new Error("target_icon_family_required_string is required and must be a string");
    }

    const escapedIconFamily = escapeForAppleScript(target_icon_family_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedIconFamily}
          return small 8 bit mask of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      icon_family: target_icon_family_required_string
    };
  }

  async getSmall32BitIconOfIconFamily(target_icon_family_required_string) {
    if (!target_icon_family_required_string || typeof target_icon_family_required_string !== "string") {
      throw new Error("target_icon_family_required_string is required and must be a string");
    }

    const escapedIconFamily = escapeForAppleScript(target_icon_family_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedIconFamily}
          return small 32 bit icon of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      icon_family: target_icon_family_required_string
    };
  }

  async getSmall8BitIconOfIconFamily(target_icon_family_required_string) {
    if (!target_icon_family_required_string || typeof target_icon_family_required_string !== "string") {
      throw new Error("target_icon_family_required_string is required and must be a string");
    }

    const escapedIconFamily = escapeForAppleScript(target_icon_family_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedIconFamily}
          return small 8 bit icon of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      icon_family: target_icon_family_required_string
    };
  }

  async getSmall4BitIconOfIconFamily(target_icon_family_required_string) {
    if (!target_icon_family_required_string || typeof target_icon_family_required_string !== "string") {
      throw new Error("target_icon_family_required_string is required and must be a string");
    }

    const escapedIconFamily = escapeForAppleScript(target_icon_family_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedIconFamily}
          return small 4 bit icon of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      icon_family: target_icon_family_required_string
    };
  }

  async getArrangementOfIconViewOptions(target_icon_view_options_required_string) {
    if (!target_icon_view_options_required_string || typeof target_icon_view_options_required_string !== "string") {
      throw new Error("target_icon_view_options_required_string is required and must be a string");
    }

    const escapedIconViewOptions = escapeForAppleScript(target_icon_view_options_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedIconViewOptions}
          return arrangement of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      icon_view_options: target_icon_view_options_required_string
    };
  }

  async setArrangementOfIconViewOptions(target_icon_view_options_required_string, value_required_earr) {
    if (!target_icon_view_options_required_string || typeof target_icon_view_options_required_string !== "string") {
      throw new Error("target_icon_view_options_required_string is required and must be a string");
    }
    if (value_required_earr === undefined || value_required_earr === null) {
      throw new Error("value_required_earr is required");
    }

    const castedIconViewOptions = castAndEscape(target_icon_view_options_required_string, 'string');
    const castedValue = castAndEscape(value_required_earr, 'earr');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedIconViewOptions}
          set arrangement of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_earr,
      script: script,
      icon_view_options: target_icon_view_options_required_string
    };
  }

  async getIconSizeOfIconViewOptions(target_icon_view_options_required_string) {
    if (!target_icon_view_options_required_string || typeof target_icon_view_options_required_string !== "string") {
      throw new Error("target_icon_view_options_required_string is required and must be a string");
    }

    const escapedIconViewOptions = escapeForAppleScript(target_icon_view_options_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedIconViewOptions}
          return icon size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      icon_view_options: target_icon_view_options_required_string
    };
  }

  async setIconSizeOfIconViewOptions(target_icon_view_options_required_string, value_required_integer) {
    if (!target_icon_view_options_required_string || typeof target_icon_view_options_required_string !== "string") {
      throw new Error("target_icon_view_options_required_string is required and must be a string");
    }
    if (value_required_integer === undefined || value_required_integer === null) {
      throw new Error("value_required_integer is required");
    }

    const castedIconViewOptions = castAndEscape(target_icon_view_options_required_string, 'string');
    const castedValue = castAndEscape(value_required_integer, 'integer');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedIconViewOptions}
          set icon size of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_integer,
      script: script,
      icon_view_options: target_icon_view_options_required_string
    };
  }

  async getShowsItemInfoOfIconViewOptions(target_icon_view_options_required_string) {
    if (!target_icon_view_options_required_string || typeof target_icon_view_options_required_string !== "string") {
      throw new Error("target_icon_view_options_required_string is required and must be a string");
    }

    const escapedIconViewOptions = escapeForAppleScript(target_icon_view_options_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedIconViewOptions}
          return shows item info of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      icon_view_options: target_icon_view_options_required_string
    };
  }

  async setShowsItemInfoOfIconViewOptions(target_icon_view_options_required_string, value_required_boolean) {
    if (!target_icon_view_options_required_string || typeof target_icon_view_options_required_string !== "string") {
      throw new Error("target_icon_view_options_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedIconViewOptions = castAndEscape(target_icon_view_options_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedIconViewOptions}
          set shows item info of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      icon_view_options: target_icon_view_options_required_string
    };
  }

  async getShowsIconPreviewOfIconViewOptions(target_icon_view_options_required_string) {
    if (!target_icon_view_options_required_string || typeof target_icon_view_options_required_string !== "string") {
      throw new Error("target_icon_view_options_required_string is required and must be a string");
    }

    const escapedIconViewOptions = escapeForAppleScript(target_icon_view_options_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedIconViewOptions}
          return shows icon preview of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      icon_view_options: target_icon_view_options_required_string
    };
  }

  async setShowsIconPreviewOfIconViewOptions(target_icon_view_options_required_string, value_required_boolean) {
    if (!target_icon_view_options_required_string || typeof target_icon_view_options_required_string !== "string") {
      throw new Error("target_icon_view_options_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedIconViewOptions = castAndEscape(target_icon_view_options_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedIconViewOptions}
          set shows icon preview of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      icon_view_options: target_icon_view_options_required_string
    };
  }

  async getTextSizeOfIconViewOptions(target_icon_view_options_required_string) {
    if (!target_icon_view_options_required_string || typeof target_icon_view_options_required_string !== "string") {
      throw new Error("target_icon_view_options_required_string is required and must be a string");
    }

    const escapedIconViewOptions = escapeForAppleScript(target_icon_view_options_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedIconViewOptions}
          return text size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      icon_view_options: target_icon_view_options_required_string
    };
  }

  async setTextSizeOfIconViewOptions(target_icon_view_options_required_string, value_required_integer) {
    if (!target_icon_view_options_required_string || typeof target_icon_view_options_required_string !== "string") {
      throw new Error("target_icon_view_options_required_string is required and must be a string");
    }
    if (value_required_integer === undefined || value_required_integer === null) {
      throw new Error("value_required_integer is required");
    }

    const castedIconViewOptions = castAndEscape(target_icon_view_options_required_string, 'string');
    const castedValue = castAndEscape(value_required_integer, 'integer');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedIconViewOptions}
          set text size of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_integer,
      script: script,
      icon_view_options: target_icon_view_options_required_string
    };
  }

  async getLabelPositionOfIconViewOptions(target_icon_view_options_required_string) {
    if (!target_icon_view_options_required_string || typeof target_icon_view_options_required_string !== "string") {
      throw new Error("target_icon_view_options_required_string is required and must be a string");
    }

    const escapedIconViewOptions = escapeForAppleScript(target_icon_view_options_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedIconViewOptions}
          return label position of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      icon_view_options: target_icon_view_options_required_string
    };
  }

  async setLabelPositionOfIconViewOptions(target_icon_view_options_required_string, value_required_epos) {
    if (!target_icon_view_options_required_string || typeof target_icon_view_options_required_string !== "string") {
      throw new Error("target_icon_view_options_required_string is required and must be a string");
    }
    if (value_required_epos === undefined || value_required_epos === null) {
      throw new Error("value_required_epos is required");
    }

    const castedIconViewOptions = castAndEscape(target_icon_view_options_required_string, 'string');
    const castedValue = castAndEscape(value_required_epos, 'epos');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedIconViewOptions}
          set label position of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_epos,
      script: script,
      icon_view_options: target_icon_view_options_required_string
    };
  }

  async getBackgroundPictureOfIconViewOptions(target_icon_view_options_required_string) {
    if (!target_icon_view_options_required_string || typeof target_icon_view_options_required_string !== "string") {
      throw new Error("target_icon_view_options_required_string is required and must be a string");
    }

    const escapedIconViewOptions = escapeForAppleScript(target_icon_view_options_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedIconViewOptions}
          return background picture of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      icon_view_options: target_icon_view_options_required_string
    };
  }

  async setBackgroundPictureOfIconViewOptions(target_icon_view_options_required_string, value_required_file) {
    if (!target_icon_view_options_required_string || typeof target_icon_view_options_required_string !== "string") {
      throw new Error("target_icon_view_options_required_string is required and must be a string");
    }
    if (value_required_file === undefined || value_required_file === null) {
      throw new Error("value_required_file is required");
    }

    const castedIconViewOptions = castAndEscape(target_icon_view_options_required_string, 'string');
    const castedValue = castAndEscape(value_required_file, 'file');
    // Determine value format for AppleScript
    let valueForScript;
    // Property type 'file' is a class reference - treat as object
    valueForScript = castedValue; // Object reference - no quotes

    const script = `
      tell application "Finder"
        tell ${castedIconViewOptions}
          set background picture of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_file,
      script: script,
      icon_view_options: target_icon_view_options_required_string
    };
  }

  async getBackgroundColorOfIconViewOptions(target_icon_view_options_required_string) {
    if (!target_icon_view_options_required_string || typeof target_icon_view_options_required_string !== "string") {
      throw new Error("target_icon_view_options_required_string is required and must be a string");
    }

    const escapedIconViewOptions = escapeForAppleScript(target_icon_view_options_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedIconViewOptions}
          return background color of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      icon_view_options: target_icon_view_options_required_string
    };
  }

  async setBackgroundColorOfIconViewOptions(target_icon_view_options_required_string, value_required_rgb_color) {
    if (!target_icon_view_options_required_string || typeof target_icon_view_options_required_string !== "string") {
      throw new Error("target_icon_view_options_required_string is required and must be a string");
    }
    if (value_required_rgb_color === undefined || value_required_rgb_color === null) {
      throw new Error("value_required_rgb_color is required");
    }

    const castedIconViewOptions = castAndEscape(target_icon_view_options_required_string, 'string');
    const castedValue = castAndEscape(value_required_rgb_color, 'RGB color');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedIconViewOptions}
          set background color of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_rgb_color,
      script: script,
      icon_view_options: target_icon_view_options_required_string
    };
  }

  async getTextSizeOfColumnViewOptions(target_column_view_options_required_string) {
    if (!target_column_view_options_required_string || typeof target_column_view_options_required_string !== "string") {
      throw new Error("target_column_view_options_required_string is required and must be a string");
    }

    const escapedColumnViewOptions = escapeForAppleScript(target_column_view_options_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedColumnViewOptions}
          return text size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      column_view_options: target_column_view_options_required_string
    };
  }

  async setTextSizeOfColumnViewOptions(target_column_view_options_required_string, value_required_integer) {
    if (!target_column_view_options_required_string || typeof target_column_view_options_required_string !== "string") {
      throw new Error("target_column_view_options_required_string is required and must be a string");
    }
    if (value_required_integer === undefined || value_required_integer === null) {
      throw new Error("value_required_integer is required");
    }

    const castedColumnViewOptions = castAndEscape(target_column_view_options_required_string, 'string');
    const castedValue = castAndEscape(value_required_integer, 'integer');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedColumnViewOptions}
          set text size of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_integer,
      script: script,
      column_view_options: target_column_view_options_required_string
    };
  }

  async getShowsIconOfColumnViewOptions(target_column_view_options_required_string) {
    if (!target_column_view_options_required_string || typeof target_column_view_options_required_string !== "string") {
      throw new Error("target_column_view_options_required_string is required and must be a string");
    }

    const escapedColumnViewOptions = escapeForAppleScript(target_column_view_options_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedColumnViewOptions}
          return shows icon of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      column_view_options: target_column_view_options_required_string
    };
  }

  async setShowsIconOfColumnViewOptions(target_column_view_options_required_string, value_required_boolean) {
    if (!target_column_view_options_required_string || typeof target_column_view_options_required_string !== "string") {
      throw new Error("target_column_view_options_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedColumnViewOptions = castAndEscape(target_column_view_options_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedColumnViewOptions}
          set shows icon of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      column_view_options: target_column_view_options_required_string
    };
  }

  async getShowsIconPreviewOfColumnViewOptions(target_column_view_options_required_string) {
    if (!target_column_view_options_required_string || typeof target_column_view_options_required_string !== "string") {
      throw new Error("target_column_view_options_required_string is required and must be a string");
    }

    const escapedColumnViewOptions = escapeForAppleScript(target_column_view_options_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedColumnViewOptions}
          return shows icon preview of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      column_view_options: target_column_view_options_required_string
    };
  }

  async setShowsIconPreviewOfColumnViewOptions(target_column_view_options_required_string, value_required_boolean) {
    if (!target_column_view_options_required_string || typeof target_column_view_options_required_string !== "string") {
      throw new Error("target_column_view_options_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedColumnViewOptions = castAndEscape(target_column_view_options_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedColumnViewOptions}
          set shows icon preview of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      column_view_options: target_column_view_options_required_string
    };
  }

  async getShowsPreviewColumnOfColumnViewOptions(target_column_view_options_required_string) {
    if (!target_column_view_options_required_string || typeof target_column_view_options_required_string !== "string") {
      throw new Error("target_column_view_options_required_string is required and must be a string");
    }

    const escapedColumnViewOptions = escapeForAppleScript(target_column_view_options_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedColumnViewOptions}
          return shows preview column of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      column_view_options: target_column_view_options_required_string
    };
  }

  async setShowsPreviewColumnOfColumnViewOptions(target_column_view_options_required_string, value_required_boolean) {
    if (!target_column_view_options_required_string || typeof target_column_view_options_required_string !== "string") {
      throw new Error("target_column_view_options_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedColumnViewOptions = castAndEscape(target_column_view_options_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedColumnViewOptions}
          set shows preview column of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      column_view_options: target_column_view_options_required_string
    };
  }

  async getDisclosesPreviewPaneOfColumnViewOptions(target_column_view_options_required_string) {
    if (!target_column_view_options_required_string || typeof target_column_view_options_required_string !== "string") {
      throw new Error("target_column_view_options_required_string is required and must be a string");
    }

    const escapedColumnViewOptions = escapeForAppleScript(target_column_view_options_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedColumnViewOptions}
          return discloses preview pane of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      column_view_options: target_column_view_options_required_string
    };
  }

  async setDisclosesPreviewPaneOfColumnViewOptions(target_column_view_options_required_string, value_required_boolean) {
    if (!target_column_view_options_required_string || typeof target_column_view_options_required_string !== "string") {
      throw new Error("target_column_view_options_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedColumnViewOptions = castAndEscape(target_column_view_options_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedColumnViewOptions}
          set discloses preview pane of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      column_view_options: target_column_view_options_required_string
    };
  }

  async getCalculatesFolderSizesOfListViewOptions(target_list_view_options_required_string) {
    if (!target_list_view_options_required_string || typeof target_list_view_options_required_string !== "string") {
      throw new Error("target_list_view_options_required_string is required and must be a string");
    }

    const escapedListViewOptions = escapeForAppleScript(target_list_view_options_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedListViewOptions}
          return calculates folder sizes of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      list_view_options: target_list_view_options_required_string
    };
  }

  async setCalculatesFolderSizesOfListViewOptions(target_list_view_options_required_string, value_required_boolean) {
    if (!target_list_view_options_required_string || typeof target_list_view_options_required_string !== "string") {
      throw new Error("target_list_view_options_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedListViewOptions = castAndEscape(target_list_view_options_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedListViewOptions}
          set calculates folder sizes of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      list_view_options: target_list_view_options_required_string
    };
  }

  async getShowsIconPreviewOfListViewOptions(target_list_view_options_required_string) {
    if (!target_list_view_options_required_string || typeof target_list_view_options_required_string !== "string") {
      throw new Error("target_list_view_options_required_string is required and must be a string");
    }

    const escapedListViewOptions = escapeForAppleScript(target_list_view_options_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedListViewOptions}
          return shows icon preview of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      list_view_options: target_list_view_options_required_string
    };
  }

  async setShowsIconPreviewOfListViewOptions(target_list_view_options_required_string, value_required_boolean) {
    if (!target_list_view_options_required_string || typeof target_list_view_options_required_string !== "string") {
      throw new Error("target_list_view_options_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedListViewOptions = castAndEscape(target_list_view_options_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedListViewOptions}
          set shows icon preview of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      list_view_options: target_list_view_options_required_string
    };
  }

  async getIconSizeOfListViewOptions(target_list_view_options_required_string) {
    if (!target_list_view_options_required_string || typeof target_list_view_options_required_string !== "string") {
      throw new Error("target_list_view_options_required_string is required and must be a string");
    }

    const escapedListViewOptions = escapeForAppleScript(target_list_view_options_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedListViewOptions}
          return icon size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      list_view_options: target_list_view_options_required_string
    };
  }

  async setIconSizeOfListViewOptions(target_list_view_options_required_string, value_required_lvic) {
    if (!target_list_view_options_required_string || typeof target_list_view_options_required_string !== "string") {
      throw new Error("target_list_view_options_required_string is required and must be a string");
    }
    if (value_required_lvic === undefined || value_required_lvic === null) {
      throw new Error("value_required_lvic is required");
    }

    const castedListViewOptions = castAndEscape(target_list_view_options_required_string, 'string');
    const castedValue = castAndEscape(value_required_lvic, 'lvic');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedListViewOptions}
          set icon size of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_lvic,
      script: script,
      list_view_options: target_list_view_options_required_string
    };
  }

  async getTextSizeOfListViewOptions(target_list_view_options_required_string) {
    if (!target_list_view_options_required_string || typeof target_list_view_options_required_string !== "string") {
      throw new Error("target_list_view_options_required_string is required and must be a string");
    }

    const escapedListViewOptions = escapeForAppleScript(target_list_view_options_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedListViewOptions}
          return text size of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      list_view_options: target_list_view_options_required_string
    };
  }

  async setTextSizeOfListViewOptions(target_list_view_options_required_string, value_required_integer) {
    if (!target_list_view_options_required_string || typeof target_list_view_options_required_string !== "string") {
      throw new Error("target_list_view_options_required_string is required and must be a string");
    }
    if (value_required_integer === undefined || value_required_integer === null) {
      throw new Error("value_required_integer is required");
    }

    const castedListViewOptions = castAndEscape(target_list_view_options_required_string, 'string');
    const castedValue = castAndEscape(value_required_integer, 'integer');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedListViewOptions}
          set text size of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_integer,
      script: script,
      list_view_options: target_list_view_options_required_string
    };
  }

  async getSortColumnOfListViewOptions(target_list_view_options_required_string) {
    if (!target_list_view_options_required_string || typeof target_list_view_options_required_string !== "string") {
      throw new Error("target_list_view_options_required_string is required and must be a string");
    }

    const escapedListViewOptions = escapeForAppleScript(target_list_view_options_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedListViewOptions}
          return sort column of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      list_view_options: target_list_view_options_required_string
    };
  }

  async setSortColumnOfListViewOptions(target_list_view_options_required_string, value_required_column) {
    if (!target_list_view_options_required_string || typeof target_list_view_options_required_string !== "string") {
      throw new Error("target_list_view_options_required_string is required and must be a string");
    }
    if (value_required_column === undefined || value_required_column === null) {
      throw new Error("value_required_column is required");
    }

    const castedListViewOptions = castAndEscape(target_list_view_options_required_string, 'string');
    const castedValue = castAndEscape(value_required_column, 'column');
    // Determine value format for AppleScript
    let valueForScript;
    // Property type 'column' is a class reference - treat as object
    valueForScript = castedValue; // Object reference - no quotes

    const script = `
      tell application "Finder"
        tell ${castedListViewOptions}
          set sort column of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_column,
      script: script,
      list_view_options: target_list_view_options_required_string
    };
  }

  async getUsesRelativeDatesOfListViewOptions(target_list_view_options_required_string) {
    if (!target_list_view_options_required_string || typeof target_list_view_options_required_string !== "string") {
      throw new Error("target_list_view_options_required_string is required and must be a string");
    }

    const escapedListViewOptions = escapeForAppleScript(target_list_view_options_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedListViewOptions}
          return uses relative dates of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      list_view_options: target_list_view_options_required_string
    };
  }

  async setUsesRelativeDatesOfListViewOptions(target_list_view_options_required_string, value_required_boolean) {
    if (!target_list_view_options_required_string || typeof target_list_view_options_required_string !== "string") {
      throw new Error("target_list_view_options_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedListViewOptions = castAndEscape(target_list_view_options_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedListViewOptions}
          set uses relative dates of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      list_view_options: target_list_view_options_required_string
    };
  }

  async getIndexOfColumn(target_column_required_string) {
    if (!target_column_required_string || typeof target_column_required_string !== "string") {
      throw new Error("target_column_required_string is required and must be a string");
    }

    const escapedColumn = escapeForAppleScript(target_column_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedColumn}
          return index of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      column: target_column_required_string
    };
  }

  async setIndexOfColumn(target_column_required_string, value_required_integer) {
    if (!target_column_required_string || typeof target_column_required_string !== "string") {
      throw new Error("target_column_required_string is required and must be a string");
    }
    if (value_required_integer === undefined || value_required_integer === null) {
      throw new Error("value_required_integer is required");
    }

    const castedColumn = castAndEscape(target_column_required_string, 'string');
    const castedValue = castAndEscape(value_required_integer, 'integer');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedColumn}
          set index of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_integer,
      script: script,
      column: target_column_required_string
    };
  }

  async getNameOfColumn(target_column_required_string) {
    if (!target_column_required_string || typeof target_column_required_string !== "string") {
      throw new Error("target_column_required_string is required and must be a string");
    }

    const escapedColumn = escapeForAppleScript(target_column_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedColumn}
          return name of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      column: target_column_required_string
    };
  }

  async getSortDirectionOfColumn(target_column_required_string) {
    if (!target_column_required_string || typeof target_column_required_string !== "string") {
      throw new Error("target_column_required_string is required and must be a string");
    }

    const escapedColumn = escapeForAppleScript(target_column_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedColumn}
          return sort direction of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      column: target_column_required_string
    };
  }

  async setSortDirectionOfColumn(target_column_required_string, value_required_sodr) {
    if (!target_column_required_string || typeof target_column_required_string !== "string") {
      throw new Error("target_column_required_string is required and must be a string");
    }
    if (value_required_sodr === undefined || value_required_sodr === null) {
      throw new Error("value_required_sodr is required");
    }

    const castedColumn = castAndEscape(target_column_required_string, 'string');
    const castedValue = castAndEscape(value_required_sodr, 'sodr');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedColumn}
          set sort direction of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_sodr,
      script: script,
      column: target_column_required_string
    };
  }

  async getWidthOfColumn(target_column_required_string) {
    if (!target_column_required_string || typeof target_column_required_string !== "string") {
      throw new Error("target_column_required_string is required and must be a string");
    }

    const escapedColumn = escapeForAppleScript(target_column_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedColumn}
          return width of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      column: target_column_required_string
    };
  }

  async setWidthOfColumn(target_column_required_string, value_required_integer) {
    if (!target_column_required_string || typeof target_column_required_string !== "string") {
      throw new Error("target_column_required_string is required and must be a string");
    }
    if (value_required_integer === undefined || value_required_integer === null) {
      throw new Error("value_required_integer is required");
    }

    const castedColumn = castAndEscape(target_column_required_string, 'string');
    const castedValue = castAndEscape(value_required_integer, 'integer');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedColumn}
          set width of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_integer,
      script: script,
      column: target_column_required_string
    };
  }

  async getMinimumWidthOfColumn(target_column_required_string) {
    if (!target_column_required_string || typeof target_column_required_string !== "string") {
      throw new Error("target_column_required_string is required and must be a string");
    }

    const escapedColumn = escapeForAppleScript(target_column_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedColumn}
          return minimum width of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      column: target_column_required_string
    };
  }

  async getMaximumWidthOfColumn(target_column_required_string) {
    if (!target_column_required_string || typeof target_column_required_string !== "string") {
      throw new Error("target_column_required_string is required and must be a string");
    }

    const escapedColumn = escapeForAppleScript(target_column_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedColumn}
          return maximum width of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      column: target_column_required_string
    };
  }

  async getVisibleOfColumn(target_column_required_string) {
    if (!target_column_required_string || typeof target_column_required_string !== "string") {
      throw new Error("target_column_required_string is required and must be a string");
    }

    const escapedColumn = escapeForAppleScript(target_column_required_string);

    const script = `
      tell application "Finder"
        tell ${escapedColumn}
          return visible of it
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      value: result,
      script: script,
      column: target_column_required_string
    };
  }

  async setVisibleOfColumn(target_column_required_string, value_required_boolean) {
    if (!target_column_required_string || typeof target_column_required_string !== "string") {
      throw new Error("target_column_required_string is required and must be a string");
    }
    if (value_required_boolean === undefined || value_required_boolean === null) {
      throw new Error("value_required_boolean is required");
    }

    const castedColumn = castAndEscape(target_column_required_string, 'string');
    const castedValue = castAndEscape(value_required_boolean, 'boolean');
    // Determine value format for AppleScript
    let valueForScript;
    if (typeof castedValue === 'string' && !castedValue.startsWith('{') && !castedValue.startsWith('date')) {
      valueForScript = `"${castedValue}"`; // Wrap strings in quotes
    } else {
      valueForScript = castedValue; // Use as-is for numbers, booleans, lists, records
    }

    const script = `
      tell application "Finder"
        tell ${castedColumn}
          set visible of it to ${valueForScript}
        end tell
      end tell
    `;

    const result = await executeAppleScript(script);
    return {
      success: result !== "Error",
      message: "Property set successfully",
      value: value_required_boolean,
      script: script,
      column: target_column_required_string
    };
  }

  sendResponse(response) {
    const responseStr = JSON.stringify(response);
    console.error("Sending response:", response.method || 'result', response.id);
    process.stdout.write(responseStr + '\n');
  }
}

// Start the server
async function startServer() {
  console.error("Testing Finder availability...");
  await checkFinderAvailable();
  
  console.error("Creating Finder MCP server...");
  const server = new FinderMCPServer();
  
  console.error("Finder AppleScript MCP server running on stdio");
  
  // Keep the process alive
  process.on('SIGINT', () => {
    console.error("Shutting down Finder AppleScript MCP server");
    process.exit(0);
  });
  
  process.on('SIGTERM', () => {
    console.error("Shutting down Finder AppleScript MCP server");
    process.exit(0);
  });
}

startServer().catch(error => {
  console.error("Fatal error starting server:", error);
  process.exit(1);
});
